# Copyright 2023 Canonical Ltd.
# Licensed under the Apache V2, see LICENCE file for details.
from __future__ import annotations

import argparse
import builtins
import functools
import json
import keyword
import pprint
import re
import textwrap
import typing
from collections import defaultdict
from glob import glob
from pathlib import Path
from typing import Any, Mapping, Sequence

import packaging.version
import typing_inspect
from typing_extensions import TypeAlias

from . import codegen

# Plain JSON, what is received from Juju
_JsonLeaf: TypeAlias = "None | bool | int | float | str"
_Json: TypeAlias = "_JsonLeaf|list[_Json]|dict[str, _Json]"

# Type-enriched JSON, what can be sent to Juju
_RichLeaf: TypeAlias = "_JsonLeaf|Type"
_RichJson: TypeAlias = "_RichLeaf|list[_RichJson]|dict[str, _RichJson]"

_marker = object()

JUJU_VERSION = re.compile(r"[0-9]+\.[0-9-]+[\.\-][0-9a-z]+(\.[0-9]+)?")
# Workaround for https://bugs.launchpad.net/juju/+bug/1683906
NAUGHTY_CLASSES = ["ClientFacade", "Client", "ModelStatusInfo"]


# Map basic types to Python's typing with a callable
SCHEMA_TO_PYTHON = {
    "string": str,
    "integer": int,
    "float": float,
    "number": float,
    "boolean": bool,
    "object": Any,
}


# Friendly warning message to stick at the top of generated files.
HEADER = """\
# DO NOT CHANGE THIS FILE! This file is auto-generated by facade.py.
# Changes will be overwritten/lost when the file is regenerated.

"""


# Classes and helper functions that we'll write to _client.py
LOOKUP_FACADE = '''
def lookup_facade(name, version):
    """
    Given a facade name and version, attempt to pull that facade out
    of the correct client<version>.py file.

    """
    for _version in range(int(version), 0, -1):
        try:
            facade = getattr(CLIENTS[str(_version)], name)
            return facade
        except (KeyError, AttributeError):
            continue
    else:
        raise ImportError("No supported version for facade: "
                          "{}".format(name))

'''

TYPE_FACTORY = '''
class TypeFactory:
    @classmethod
    def from_connection(cls, connection):
        """
        Given a connected Connection object, return an initialized and
        connected instance of an API Interface matching the name of
        this class.

        @param connection: initialized Connection object.

        """
        facade_name = cls.__name__
        if not facade_name.endswith('Facade'):
           raise TypeError('Unexpected class name: {}'.format(facade_name))
        facade_name = facade_name[:-len('Facade')]
        version = connection.facades.get(facade_name)
        if version is None:
            raise Exception('No facade {} in facades {}'.format(facade_name,
                                                                connection.facades))

        c = lookup_facade(cls.__name__, version)
        c = c()
        c.connect(connection)

        return c

    @classmethod
    def best_facade_version(cls, connection):
        """
        Returns the best facade version for a given facade. This will help with
        trying to provide different functionality for different facade versions.

        @param connection: initialized Connection object.
        """
        facade_name = cls.__name__
        if not facade_name.endswith('Facade'):
           raise TypeError('Unexpected class name: {}'.format(facade_name))
        facade_name = facade_name[:-len('Facade')]
        return connection.facades.get(facade_name)


'''

CLIENT_TABLE = """
CLIENTS = {{
    {clients}
}}

"""


class KindRegistry(dict):
    def register(self, name, version, obj):
        self[name] = {
            version: {
                "object": obj,
            }
        }

    def lookup(self, name, version=None):
        """If version is omitted, max version is used"""
        versions = self.get(name)
        if not versions:
            return None
        if version:
            return versions[version]
        return versions[max(versions)]

    def get_obj(self, name, version=None):
        result = self.lookup(name, version)
        if result:
            obj = result["object"]
            return obj
        return None


class TypeRegistry(dict):
    def __init__(self, schema):
        self.schema = schema

    def get(self, name):
        # Two way mapping
        refname = self.schema.reference_name(name)
        if refname not in self:
            result = typing.TypeVar(refname)
            self[refname] = result
            self[result] = refname

        return self[refname]

    def get_ref_type(self, ref):
        return self.get(ref)

    def obj_type(self, obj):
        kind = obj.get("type")
        if not kind:
            raise ValueError("%s has no type" % obj)
        result = SCHEMA_TO_PYTHON.get(kind)
        if not result:
            raise ValueError("%s has type %s" % (obj, kind))
        return result

    def ref_type(self, obj):
        return self.get_ref_type(obj["$ref"])


CLASSES = {}
factories = codegen.Capture()


def booler(v):
    if v == "false":
        return False
    return bool(v)


basic_types = [str, bool, int, float]


type_mapping = {
    "str": "(bytes, str)",
    "Sequence": "(bytes, str, list)",
    "Union": "dict",
    "Mapping": "dict",
}


def name_to_py(name):
    result = name.replace("-", "_")
    result = result.lower()
    if keyword.iskeyword(result) or result in dir(builtins):
        result += "_"
    return result


def var_type_to_py(kind):
    return "None"


def kind_to_py(kind):
    if kind is None or kind is typing.Any:
        return "None", "", False

    name = ""
    if typing_inspect.is_generic_type(kind):
        origin = typing_inspect.get_origin(kind)
        name = origin.__name__
    else:
        name = kind.__name__

    if kind in basic_types or type(kind) in basic_types:
        return name, type_mapping.get(name) or name, True
    if name in type_mapping:
        return name, type_mapping[name], True

    suffix = name.lstrip("~")
    return suffix, f"(dict, {suffix})", True


def strcast(kind, keep_builtins=False):
    if (kind in basic_types or type(kind) in basic_types) and keep_builtins is False:
        return kind.__name__
    if str(kind).startswith("~"):
        return str(kind)[1:]
    if kind is typing.Any:
        return "Any"
    try:
        if issubclass(kind, typing.GenericMeta):
            return str(kind)[1:]
    except AttributeError:
        pass
    return kind


class Args(list):
    def __init__(self, schema, defs):
        self.schema = schema
        self.defs = defs
        if defs:
            rtypes = schema.registry.get_obj(schema.types[defs])
            if len(rtypes) == 1:
                if not self.do_explode(rtypes[0][1]):
                    for name, rtype in rtypes:
                        self.append((name, rtype))
            else:
                for name, rtype in rtypes:
                    self.append((name, rtype))

    def do_explode(self, kind):
        if kind is Any:
            return False
        if kind in basic_types or type(kind) is typing.TypeVar:
            return False
        if typing_inspect.is_generic_type(kind) and issubclass(
            typing_inspect.get_origin(kind), Sequence
        ):
            return False
        if typing_inspect.is_generic_type(kind) and issubclass(
            typing_inspect.get_origin(kind), Mapping
        ):
            return False
        self.clear()
        self.extend(Args(self.schema, kind))
        return True

    def py_to_schema_mapping(self):
        m = {}
        for n, _ in self:
            m[name_to_py(n)] = n
        return m

    def schema_to_py_mapping(self):
        m = {}
        for n, _ in self:
            m[n] = name_to_py(n)
        return m

    def _format(self, name, rtype, typed=True):
        if typed:
            return f"{name_to_py(name)} : {strcast(rtype)}"
        else:
            return name_to_py(name)

    def _get_arg_str(self, typed=False, joined=", "):
        if self:
            parts = [self._format(item[0], item[1], typed) for item in self]
            if joined:
                return joined.join(parts)
            return parts
        return ""

    def as_kwargs(self):
        if self:
            parts = []
            for item in self:
                var_name = name_to_py(item[0])
                var_type = var_type_to_py(item[1])
                parts.append(f"{var_name}={var_type}")
            return ", ".join(parts)
        return ""

    def as_validation(self):
        """as_validation returns a series of validation statements for every item
        in the the Args.
        """
        parts = []
        for item in self:
            var_name = name_to_py(item[0])
            var_type, var_sub_type, ok = kind_to_py(item[1])
            if ok:
                parts.append(build_validation(var_name, var_type, var_sub_type))
        return "\n".join(parts)

    def typed(self):
        return self._get_arg_str(True)

    def __str__(self):
        return self._get_arg_str(False)

    def get_doc(self):
        return self._get_arg_str(True, "\n")


def build_validation(name, instance_type, instance_sub_type, ident=None):
    indent = ident or "    "
    source = f"""{indent}if {name} is not None and not isinstance({name}, {instance_sub_type}):
{indent}    raise Exception("Expected {name} to be a {instance_type}, received: {{}}".format(type({name})))
"""
    return source


def build_types(schema, capture):
    indent = "    "
    for kind in sorted(
        (k for k in schema.types if not isinstance(k, str)), key=lambda x: str(x)
    ):
        name = schema.types[kind]
        if not name:
            # when running on juju 3.1.0 client-only schemas, we get a seemingly empty entry with no name
            # this breaks codegen when generating a class with no name so we explicitly skip it here
            # note that this is not a problem with the original 3.1.0 full schema (client + others)
            # nor is it a problem with client-only schemas for latter juju versions (e.g. 3.3.0)
            continue
        if name in capture and name not in NAUGHTY_CLASSES:
            continue
        args = Args(schema, kind)
        # Write Factory class for _client.py
        make_factory(name)
        # Write actual class
        source = [
            """
class {}(Type):
    _toSchema = {}
    _toPy = {}
    def __init__(self{}{}, **unknown_fields):
        '''
{}
        '''""".format(
                name,
                # pprint these to get stable ordering across regens
                pprint.pformat(args.py_to_schema_mapping(), width=999),
                pprint.pformat(args.schema_to_py_mapping(), width=999),
                ", " if args else "",
                args.as_kwargs(),
                textwrap.indent(args.get_doc(), indent * 2),
            )
        ]

        if not args:
            source.append(f"{indent * 2}self.unknown_fields = unknown_fields")
        else:
            # do the validation first, before setting the variables
            for arg in args:
                arg_name = name_to_py(arg[0])
                arg_type = arg[1]
                arg_type_name = strcast(arg_type)
                if arg_type in basic_types or arg_type is typing.Any:
                    source.append(f"{indent * 2}{arg_name}_ = {arg_name}")
                elif type(arg_type) is typing.TypeVar:
                    source.append(
                        f"{indent * 2}{arg_name}_ = {arg_type_name}.from_json({arg_name}) if {arg_name} else None"
                    )
                elif typing_inspect.is_generic_type(arg_type) and issubclass(
                    typing_inspect.get_origin(arg_type), Sequence
                ):
                    parameters = typing_inspect.get_parameters(arg_type)
                    value_type = parameters[0] if len(parameters) else None
                    if type(value_type) is typing.TypeVar:
                        source.append(
                            f"{indent * 2}{arg_name}_ = [{strcast(value_type)}.from_json(o) for o in {arg_name} or []]"
                        )
                    else:
                        source.append(f"{indent * 2}{arg_name}_ = {arg_name}")
                elif typing_inspect.is_generic_type(arg_type) and issubclass(
                    typing_inspect.get_origin(arg_type), Mapping
                ):
                    parameters = typing_inspect.get_parameters(arg_type)
                    value_type = parameters[0] if len(parameters) else None
                    if type(value_type) is typing.TypeVar:
                        source.append(
                            f"{indent * 2}{arg_name}_ = {{k: {strcast(value_type)}.from_json(v) "
                            f"for k, v in ({arg_name} or dict()).items()}}"
                        )
                    else:
                        source.append(f"{indent * 2}{arg_name}_ = {arg_name}")
                else:
                    source.append(f"{indent * 2}{arg_name}_ = {arg_name}")
            if len(args) > 0:
                source.append(
                    f"\n{indent * 2}# Validate arguments against known Juju API types."
                )
            for arg in args:
                arg_name = f"{name_to_py(arg[0])}_"
                arg_type, arg_sub_type, ok = kind_to_py(arg[1])
                if ok:
                    source.append(
                        "{}".format(
                            build_validation(
                                arg_name, arg_type, arg_sub_type, ident=indent * 2
                            )
                        )
                    )

            for arg in args:
                arg_name = name_to_py(arg[0])
                source.append(f"{indent * 2}self.{arg_name} = {arg_name}_")
            # Ensure that we take the kwargs (unknown_fields) and put it on the
            # Results/Params so we can inspect it.
            source.append(f"{indent * 2}self.unknown_fields = unknown_fields")

        source = "\n".join(source)
        capture.clear(name)
        capture[name].write(source)
        capture[name].write("\n\n")
        if name is None:
            print(source)
        co = compile(source, __name__, "exec")
        ns = _getns(schema)
        exec(co, ns)  # noqa: S102
        cls = ns[name]
        CLASSES[name] = cls


def retspec(schema, defs):
    # return specs
    # only return 1, so if there is more than one type
    # we need to include a union
    # In truth there is only 1 return
    # Error or the expected Type
    if not defs:
        return None
    if defs in basic_types:
        return strcast(defs, False)
    return strcast(defs, False)


def ReturnMapping(cls):  # noqa: N802
    # Annotate the method with a return Type
    # so the value can be cast
    def decorator(f):
        @functools.wraps(f)
        async def wrapper(*args, **kwargs):
            nonlocal cls
            reply = await f(*args, **kwargs)
            if cls is None:
                return reply
            if "error" in reply:
                cls = CLASSES["Error"]
            if typing_inspect.is_generic_type(cls) and issubclass(
                typing_inspect.get_origin(cls), Sequence
            ):
                parameters = typing_inspect.get_parameters(cls)
                result = []
                item_cls = parameters[0]
                for item in reply:
                    result.append(item_cls.from_json(item))
                    """
                    if 'error' in item:
                        cls = CLASSES['Error']
                    else:
                        cls = item_cls
                    result.append(cls.from_json(item))
                    """
            else:
                result = cls.from_json(reply["response"])

            return result

        return wrapper

    return decorator


def make_func(cls, name, description, params, result, _async=True):
    indent = "    "
    args = Args(cls.schema, params)
    toschema = args.py_to_schema_mapping()
    assignments = [
        f"{indent}_params['{toschema[arg]}'] = {arg}"
        for arg in args._get_arg_str(False, False)
    ]
    assignments = "\n".join(assignments)
    res = retspec(cls.schema, result)
    source = """

@ReturnMapping({rettype})
{_async}def {name}(self{argsep}{args}):
    '''
{docstring}
    Returns -> {res}
    '''
{validation}
    # map input types to rpc msg
    _params = dict()
    msg = dict(type='{cls.name}',
               request='{name}',
               version={cls.version},
               params=_params)
{assignments}
    reply = {_await}self.rpc(msg)
    return reply

"""

    if description != "":
        description = f"{description}\n"
    if args_doc := args.get_doc():
        args_doc = f"\n{args_doc}"
    doc_string = f"{description}{args_doc}"
    fsource = source.format(
        _async="async " if _async else "",
        name=name,
        argsep=", " if args else "",
        args=args.as_kwargs(),
        res=res,
        validation=args.as_validation(),
        rettype=result.__name__ if result else None,
        docstring=textwrap.indent(doc_string, indent),
        cls=cls,
        assignments=assignments,
        _await="await " if _async else "",
    )
    ns = _getns(cls.schema)
    exec(fsource, ns)  # noqa: S102
    func = ns[name]
    return func, fsource


def make_rpc_func(cls):
    source = """

async def rpc(self, msg):
    '''
    Patch rpc method to add Id.
    '''
    if not hasattr(self, 'Id'):
        raise RuntimeError('Missing "Id" field')
    msg['Id'] = id

    from .facade import TypeEncoder
    reply = await self.connection.rpc(msg, encoder=TypeEncoder)
    return reply

"""
    ns = _getns(cls.schema)
    exec(source, ns)  # noqa: S102
    func = ns["rpc"]
    return func, source


def build_methods(cls, capture):
    properties = cls.schema["properties"]
    for methodname in sorted(properties):
        method, source = _build_method(cls, methodname)
        setattr(cls, methodname, method)
        capture[f"{cls.__name__}Facade"].write(source, depth=1)


def _build_method(cls, name):
    params = None
    result = None
    method = cls.schema["properties"][name]
    description = ""
    if "description" in method:
        description = method["description"]
    if "properties" in method:
        prop = method["properties"]
        spec = prop.get("Params")
        if spec:
            params = cls.schema.types.get(spec["$ref"])
        spec = prop.get("Result")
        if spec:
            if "$ref" in spec:
                result = cls.schema.types.get(spec["$ref"])
            else:
                result = SCHEMA_TO_PYTHON[spec["type"]]
    return make_func(cls, name, description, params, result)


def build_watcher_methods(cls, capture):
    properties = cls.schema["properties"]
    if "Next" in properties and "Stop" in properties:
        method, source = make_rpc_func(cls)
        cls.rpc = method
        capture[f"{cls.__name__}Facade"].write(source, depth=1)


def build_facade(schema):
    cls = type(
        schema.name,
        (Type,),
        dict(name=schema.name, version=schema.version, schema=schema),
    )
    source = f"""
class {schema.name}Facade(Type):
    name = '{schema.name}'
    version = {schema.version}
    """
    return cls, source


class TypeEncoder(json.JSONEncoder):
    def default(self, obj: _RichJson) -> _Json:
        if isinstance(obj, Type):
            return obj.serialize()
        return json.JSONEncoder.default(self, obj)


class Type:
    def connect(self, connection):
        self.connection = connection

    def __repr__(self):
        return f"{self.__class__}({self.__dict__})"

    def __eq__(self, other):
        if not isinstance(other, Type):
            return NotImplemented

        return self.__dict__ == other.__dict__

    async def rpc(self, msg: dict[str, _RichJson]) -> _Json:
        result = await self.connection.rpc(msg, encoder=TypeEncoder)
        return result

    @classmethod
    def from_json(cls, data):
        def _parse_nested_list_entry(expr, result_dict):
            if isinstance(expr, str):
                if ">" in expr or ">=" in expr:
                    # something like juju >= 2.9.31
                    i = expr.index(">")
                    _key = expr[:i].strip()
                    _value = expr[i:].strip()
                    result_dict[_key] = _value
                else:
                    # this is a simple entry
                    result_dict[expr] = ""
            elif isinstance(expr, dict):
                for v in expr.values():
                    _parse_nested_list_entry(v, result_dict)
            elif isinstance(expr, list):
                for v in expr:
                    _parse_nested_list_entry(v, result_dict)
            else:
                raise TypeError(
                    f"Unexpected type of entry in assumes expression: {expr}"
                )

        if isinstance(data, cls):
            return data
        if isinstance(data, str):
            try:
                data = json.loads(data)
            except json.JSONDecodeError:
                raise
        if isinstance(data, dict):
            d = {}
            for k, v in (data or {}).items():
                d[cls._toPy.get(k, k)] = v
            try:
                return cls(**d)
            except TypeError:
                raise
        if isinstance(data, list):
            # check: https://juju.is/docs/sdk/assumes
            # assumes are in the form of a list
            d = {}
            _parse_nested_list_entry(data, d)
            return cls(**d)
        return None

    def serialize(self) -> dict[str, _Json]:
        d = {}
        for attr, tgt in self._toSchema.items():
            d[tgt] = getattr(self, attr)
        return d

    def to_json(self) -> str:
        return json.dumps(self.serialize(), cls=TypeEncoder, sort_keys=True)

    def __contains__(self, key):
        return key in self._toPy

    # treat subscript gets as JSON representation
    def __getitem__(self, key):
        attr = self._toPy[key]
        return getattr(self, attr)

    # treat subscript sets as JSON representation
    def __setitem__(self, key, value):
        attr = self._toPy[key]
        setattr(self, attr, value)

    # legacy: generated definitions used to not correctly
    # create typed objects and would use dict instead (from JSON)
    # so we emulate some dict methods.
    def get(self, key, default=None):
        try:
            attr = self._toPy[key]
        except KeyError:
            return default
        return getattr(self, attr, default)


class Schema(dict):
    def __init__(self, schema):
        self.name = schema["Name"]
        self.version = schema["Version"]
        self.update(schema["Schema"])

        self.registry = KindRegistry()
        self.types = TypeRegistry(self)

    def reference_name(self, ref):
        if ref.startswith("#/definitions/"):
            ref = ref.rsplit("/", 1)[-1]
        return ref

    def build_definitions(self):
        # here we are building the types out
        # anything in definitions is a type
        # but these may contain references themselves
        # so we dfs to the bottom and build upwards
        # when a types is already in the registry
        defs = self.get("definitions")
        if not defs:
            return
        definitions = {}
        for d, data in defs.items():
            if d in self.registry and d not in NAUGHTY_CLASSES:
                continue
            if data.get("type") != "object":
                continue
            definitions[d] = data
        for d, definition in definitions.items():
            node = self.build_object(definition, d)
            self.registry.register(d, self.version, node)
            self.types.get_ref_type(d)

    def build_object(self, node, name=None):
        # we don't need to build types recursively here
        # they are all in definitions already
        # we only want to include the type reference
        # which we can derive from the name
        struct = []
        add = struct.append
        props = node.get("properties")
        pprops = node.get("patternProperties")
        if props:
            # Sort these so the __init__ arg list for each Type remains
            # consistently ordered across regens of client.py
            for p in sorted(props):
                prop = props[p]
                if "$ref" in prop:
                    add((p, self.types.ref_type(prop)))
                else:
                    kind = prop["type"]
                    if kind == "array":
                        add((p, self.build_array(prop)))
                    elif kind == "object":
                        struct.extend(self.build_object(prop, p))
                    else:
                        add((p, self.types.obj_type(prop)))
        if pprops:
            if ".*" not in pprops:
                raise ValueError(
                    "Cannot handle actual pattern in patternProperties %s" % pprops
                )
            pprop = pprops[".*"]
            if "$ref" in pprop:
                add((name, Mapping[str, self.types.ref_type(pprop)]))
                return struct
            ppkind = pprop["type"]
            if ppkind == "array":
                add((name, Mapping[str, self.build_array(pprop)]))
            else:
                add((name, Mapping[str, SCHEMA_TO_PYTHON[ppkind]]))

        if not struct and node.get("additionalProperties", False):
            add((name, SCHEMA_TO_PYTHON.get("object")))

        return struct

    def build_array(self, obj):
        # return a sequence from an array in the schema
        if "$ref" in obj:
            return Sequence[self.types.ref_type(obj)]
        else:
            kind = obj.get("type")
            if kind and kind == "array":
                items = obj["items"]
                return self.build_array(items)
            else:
                return Sequence[self.types.obj_type(obj)]


def _getns(schema):
    ns = {"Type": Type, "typing": typing, "ReturnMapping": ReturnMapping}
    # Copy our types into the globals of the method
    for facade in schema.registry:
        ns[facade] = schema.registry.get_obj(facade)
    return ns


def make_factory(name):
    if name in factories:
        del factories[name]
    factories[name].write(f"class {name}(TypeFactory):\n    pass\n\n")


def write_facades(captures, options):
    """Write the Facades to the appropriate _client<version>.py"""
    for version in sorted(captures.keys()):
        filename = f"{options.output_dir}/_client{version}.py"
        with open(filename, "w") as f:
            f.write(HEADER)
            f.write("from juju.client.facade import Type, ReturnMapping\n")
            f.write("from juju.client._definitions import *\n\n")
            for key in sorted([k for k in captures[version] if "Facade" in k]):
                print(captures[version][key], file=f)

    # Return the last (most recent) version for use in other routines.
    return version


def write_definitions(captures, options):
    """Write auxiliary (non versioned) classes to
    _definitions.py The auxiliary classes currently get
    written redudantly into each capture object, so we can look in
    one of them -- we just use the last one from the loop above.

    """
    with open(f"{options.output_dir}/_definitions.py", "w") as f:
        f.write(HEADER)
        f.write("from juju.client.facade import Type, ReturnMapping\n\n")
        for key in sorted([k for k in captures if "Facade" not in k]):
            print(captures[key], file=f)


def write_client(captures, options):
    """Write the TypeFactory classes to _client.py, along with some
    imports and tables so that we can look up versioned Facades.

    """
    with open(f"{options.output_dir}/_client.py", "w") as f:
        f.write(HEADER)
        f.write("from juju.client._definitions import *\n\n")
        clients = ", ".join(f"_client{v}" for v in captures)

        # from juju.client import _client2, _client1, _client3 ...
        f.write("\nfrom juju.client import " + clients + "\n\n")
        # CLIENTS = { ....
        f.write(
            CLIENT_TABLE.format(
                clients=",\n    ".join([f'"{v}": _client{v}' for v in captures])
            )
        )

        f.write(LOOKUP_FACADE)
        f.write(TYPE_FACTORY)
        for key in sorted([k for k in factories if "Facade" in k]):
            print(factories[key], file=f)


def generate_definitions(schemas):
    # Build all of the auxiliary (unversioned) classes
    # TODO: get rid of some of the excess trips through loops in the
    # called functions.
    definitions = codegen.Capture()

    for juju_version in sorted(schemas.keys()):
        for schema in schemas[juju_version]:
            schema.build_definitions()

    # ensure we write the latest ones first, so that earlier revisions
    # get dropped.
    for juju_version in sorted(schemas.keys(), reverse=True):
        for schema in schemas[juju_version]:
            build_types(schema, definitions)

    return definitions


def generate_facades(
    schemas: dict[str, list[Schema]],
) -> dict[str, dict[int, codegen.Capture]]:
    captures = defaultdict(codegen.Capture)

    # Build the Facade classes
    for juju_version in sorted(schemas.keys(), key=packaging.version.parse):
        for schema in schemas[juju_version]:
            cls, source = build_facade(schema)
            cls_name = f"{schema.name}Facade"

            captures[schema.version].clear(cls_name)
            # Make the factory class for _client.py
            make_factory(cls_name)
            # Make the actual class
            captures[schema.version][cls_name].write(source)
            # Build the methods for each Facade class.
            build_methods(cls, captures[schema.version])
            # Build the override RPC method if the Facade is a watcher.
            build_watcher_methods(cls, captures[schema.version])
            # Mark this Facade class as being done for this version --
            # helps mitigate some excessive looping.
            CLASSES[schema.name] = cls

    return captures


def load_schemas(options):
    schemas = {}
    for p in sorted(glob(options.schema)):
        try:
            juju_version = re.search(JUJU_VERSION, p).group()
        except AttributeError:
            print(f"Cannot extract a juju version from {p}")
            print("Schemas must include a juju version in the filename")
            raise SystemExit(1)
        new_schemas = json.loads(Path(p).read_text("utf-8"))
        schemas[juju_version] = [Schema(s) for s in new_schemas]
    return schemas


def setup():
    parser = argparse.ArgumentParser()
    parser.add_argument("-s", "--schema", default="juju/client/schemas-juju-*.json")
    parser.add_argument("-o", "--output_dir", default="juju/client")
    options = parser.parse_args()
    return options


def main():
    options = setup()

    schemas = load_schemas(options)

    # Generate some text blobs
    definitions = generate_definitions(schemas)
    captures = generate_facades(schemas)

    # ... and write them out
    write_definitions(definitions, options)
    write_facades(captures, options)
    write_client(captures, options)


if __name__ == "__main__":
    main()
