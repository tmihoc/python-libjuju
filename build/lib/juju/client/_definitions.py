# DO NOT CHANGE THIS FILE! This file is auto-generated by facade.py.
# Changes will be overwritten/lost when the file is regenerated.

from juju.client.facade import Type


class AccessInfo(Type):
    _toSchema = {"role": "role", "scope_tag": "scope-tag", "target_tag": "target-tag"}
    _toPy = {"role": "role", "scope-tag": "scope_tag", "target-tag": "target_tag"}

    def __init__(self, role=None, scope_tag=None, target_tag=None, **unknown_fields):
        """Role : str
        scope_tag : str
        target_tag : str
        """
        role_ = role
        scope_tag_ = scope_tag
        target_tag_ = target_tag

        # Validate arguments against known Juju API types.
        if role_ is not None and not isinstance(role_, (bytes, str)):
            raise Exception(f"Expected role_ to be a str, received: {type(role_)}")

        if scope_tag_ is not None and not isinstance(scope_tag_, (bytes, str)):
            raise Exception(
                f"Expected scope_tag_ to be a str, received: {type(scope_tag_)}"
            )

        if target_tag_ is not None and not isinstance(target_tag_, (bytes, str)):
            raise Exception(
                f"Expected target_tag_ to be a str, received: {type(target_tag_)}"
            )

        self.role = role_
        self.scope_tag = scope_tag_
        self.target_tag = target_tag_
        self.unknown_fields = unknown_fields


class Action(Type):
    _toSchema = {
        "execution_group": "execution-group",
        "name": "name",
        "parallel": "parallel",
        "parameters": "parameters",
        "receiver": "receiver",
        "tag": "tag",
    }
    _toPy = {
        "execution-group": "execution_group",
        "name": "name",
        "parallel": "parallel",
        "parameters": "parameters",
        "receiver": "receiver",
        "tag": "tag",
    }

    def __init__(
        self,
        execution_group=None,
        name=None,
        parallel=None,
        parameters=None,
        receiver=None,
        tag=None,
        **unknown_fields,
    ):
        """execution_group : str
        name : str
        parallel : bool
        parameters : typing.Mapping[str, typing.Any]
        receiver : str
        tag : str
        """
        execution_group_ = execution_group
        name_ = name
        parallel_ = parallel
        parameters_ = parameters
        receiver_ = receiver
        tag_ = tag

        # Validate arguments against known Juju API types.
        if execution_group_ is not None and not isinstance(
            execution_group_, (bytes, str)
        ):
            raise Exception(
                f"Expected execution_group_ to be a str, received: {type(execution_group_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if parallel_ is not None and not isinstance(parallel_, bool):
            raise Exception(
                f"Expected parallel_ to be a bool, received: {type(parallel_)}"
            )

        if parameters_ is not None and not isinstance(parameters_, dict):
            raise Exception(
                f"Expected parameters_ to be a Mapping, received: {type(parameters_)}"
            )

        if receiver_ is not None and not isinstance(receiver_, (bytes, str)):
            raise Exception(
                f"Expected receiver_ to be a str, received: {type(receiver_)}"
            )

        if tag_ is not None and not isinstance(tag_, (bytes, str)):
            raise Exception(f"Expected tag_ to be a str, received: {type(tag_)}")

        self.execution_group = execution_group_
        self.name = name_
        self.parallel = parallel_
        self.parameters = parameters_
        self.receiver = receiver_
        self.tag = tag_
        self.unknown_fields = unknown_fields


class ActionMessage(Type):
    _toSchema = {"message": "message", "timestamp": "timestamp"}
    _toPy = {"message": "message", "timestamp": "timestamp"}

    def __init__(self, message=None, timestamp=None, **unknown_fields):
        """Message : str
        timestamp : str
        """
        message_ = message
        timestamp_ = timestamp

        # Validate arguments against known Juju API types.
        if message_ is not None and not isinstance(message_, (bytes, str)):
            raise Exception(
                f"Expected message_ to be a str, received: {type(message_)}"
            )

        if timestamp_ is not None and not isinstance(timestamp_, (bytes, str)):
            raise Exception(
                f"Expected timestamp_ to be a str, received: {type(timestamp_)}"
            )

        self.message = message_
        self.timestamp = timestamp_
        self.unknown_fields = unknown_fields


class ActionResult(Type):
    _toSchema = {
        "action": "action",
        "completed": "completed",
        "enqueued": "enqueued",
        "error": "error",
        "log": "log",
        "message": "message",
        "output": "output",
        "started": "started",
        "status": "status",
    }
    _toPy = {
        "action": "action",
        "completed": "completed",
        "enqueued": "enqueued",
        "error": "error",
        "log": "log",
        "message": "message",
        "output": "output",
        "started": "started",
        "status": "status",
    }

    def __init__(
        self,
        action=None,
        completed=None,
        enqueued=None,
        error=None,
        log=None,
        message=None,
        output=None,
        started=None,
        status=None,
        **unknown_fields,
    ):
        """Action : Action
        completed : str
        enqueued : str
        error : Error
        log : typing.Sequence[~ActionMessage]
        message : str
        output : typing.Mapping[str, typing.Any]
        started : str
        status : str
        """
        action_ = Action.from_json(action) if action else None
        completed_ = completed
        enqueued_ = enqueued
        error_ = Error.from_json(error) if error else None
        log_ = [ActionMessage.from_json(o) for o in log or []]
        message_ = message
        output_ = output
        started_ = started
        status_ = status

        # Validate arguments against known Juju API types.
        if action_ is not None and not isinstance(action_, (dict, Action)):
            raise Exception(
                f"Expected action_ to be a Action, received: {type(action_)}"
            )

        if completed_ is not None and not isinstance(completed_, (bytes, str)):
            raise Exception(
                f"Expected completed_ to be a str, received: {type(completed_)}"
            )

        if enqueued_ is not None and not isinstance(enqueued_, (bytes, str)):
            raise Exception(
                f"Expected enqueued_ to be a str, received: {type(enqueued_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if log_ is not None and not isinstance(log_, (bytes, str, list)):
            raise Exception(f"Expected log_ to be a Sequence, received: {type(log_)}")

        if message_ is not None and not isinstance(message_, (bytes, str)):
            raise Exception(
                f"Expected message_ to be a str, received: {type(message_)}"
            )

        if output_ is not None and not isinstance(output_, dict):
            raise Exception(
                f"Expected output_ to be a Mapping, received: {type(output_)}"
            )

        if started_ is not None and not isinstance(started_, (bytes, str)):
            raise Exception(
                f"Expected started_ to be a str, received: {type(started_)}"
            )

        if status_ is not None and not isinstance(status_, (bytes, str)):
            raise Exception(f"Expected status_ to be a str, received: {type(status_)}")

        self.action = action_
        self.completed = completed_
        self.enqueued = enqueued_
        self.error = error_
        self.log = log_
        self.message = message_
        self.output = output_
        self.started = started_
        self.status = status_
        self.unknown_fields = unknown_fields


class ActionResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ActionResult]"""
        results_ = [ActionResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ActionSpec(Type):
    _toSchema = {"description": "description", "params": "params"}
    _toPy = {"description": "description", "params": "params"}

    def __init__(self, description=None, params=None, **unknown_fields):
        """Description : str
        params : typing.Mapping[str, typing.Any]
        """
        description_ = description
        params_ = params

        # Validate arguments against known Juju API types.
        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if params_ is not None and not isinstance(params_, dict):
            raise Exception(
                f"Expected params_ to be a Mapping, received: {type(params_)}"
            )

        self.description = description_
        self.params = params_
        self.unknown_fields = unknown_fields


class Actions(Type):
    _toSchema = {"actions": "actions"}
    _toPy = {"actions": "actions"}

    def __init__(self, actions=None, **unknown_fields):
        """Actions : typing.Sequence[~Action]"""
        actions_ = [Action.from_json(o) for o in actions or []]

        # Validate arguments against known Juju API types.
        if actions_ is not None and not isinstance(actions_, (bytes, str, list)):
            raise Exception(
                f"Expected actions_ to be a Sequence, received: {type(actions_)}"
            )

        self.actions = actions_
        self.unknown_fields = unknown_fields


class AddApplicationOffer(Type):
    _toSchema = {
        "application_description": "application-description",
        "application_name": "application-name",
        "endpoints": "endpoints",
        "model_tag": "model-tag",
        "offer_name": "offer-name",
        "owner_tag": "owner-tag",
    }
    _toPy = {
        "application-description": "application_description",
        "application-name": "application_name",
        "endpoints": "endpoints",
        "model-tag": "model_tag",
        "offer-name": "offer_name",
        "owner-tag": "owner_tag",
    }

    def __init__(
        self,
        application_description=None,
        application_name=None,
        endpoints=None,
        model_tag=None,
        offer_name=None,
        owner_tag=None,
        **unknown_fields,
    ):
        """application_description : str
        application_name : str
        endpoints : typing.Mapping[str, str]
        model_tag : str
        offer_name : str
        owner_tag : str
        """
        application_description_ = application_description
        application_name_ = application_name
        endpoints_ = endpoints
        model_tag_ = model_tag
        offer_name_ = offer_name
        owner_tag_ = owner_tag

        # Validate arguments against known Juju API types.
        if application_description_ is not None and not isinstance(
            application_description_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_description_ to be a str, received: {type(application_description_)}"
            )

        if application_name_ is not None and not isinstance(
            application_name_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_name_ to be a str, received: {type(application_name_)}"
            )

        if endpoints_ is not None and not isinstance(endpoints_, dict):
            raise Exception(
                f"Expected endpoints_ to be a Mapping, received: {type(endpoints_)}"
            )

        if model_tag_ is not None and not isinstance(model_tag_, (bytes, str)):
            raise Exception(
                f"Expected model_tag_ to be a str, received: {type(model_tag_)}"
            )

        if offer_name_ is not None and not isinstance(offer_name_, (bytes, str)):
            raise Exception(
                f"Expected offer_name_ to be a str, received: {type(offer_name_)}"
            )

        if owner_tag_ is not None and not isinstance(owner_tag_, (bytes, str)):
            raise Exception(
                f"Expected owner_tag_ to be a str, received: {type(owner_tag_)}"
            )

        self.application_description = application_description_
        self.application_name = application_name_
        self.endpoints = endpoints_
        self.model_tag = model_tag_
        self.offer_name = offer_name_
        self.owner_tag = owner_tag_
        self.unknown_fields = unknown_fields


class AddApplicationOffers(Type):
    _toSchema = {"offers": "Offers"}
    _toPy = {"Offers": "offers"}

    def __init__(self, offers=None, **unknown_fields):
        """Offers : typing.Sequence[~AddApplicationOffer]"""
        offers_ = [AddApplicationOffer.from_json(o) for o in offers or []]

        # Validate arguments against known Juju API types.
        if offers_ is not None and not isinstance(offers_, (bytes, str, list)):
            raise Exception(
                f"Expected offers_ to be a Sequence, received: {type(offers_)}"
            )

        self.offers = offers_
        self.unknown_fields = unknown_fields


class AddApplicationUnits(Type):
    _toSchema = {
        "application": "application",
        "attach_storage": "attach-storage",
        "num_units": "num-units",
        "placement": "placement",
        "policy": "policy",
    }
    _toPy = {
        "application": "application",
        "attach-storage": "attach_storage",
        "num-units": "num_units",
        "placement": "placement",
        "policy": "policy",
    }

    def __init__(
        self,
        application=None,
        attach_storage=None,
        num_units=None,
        placement=None,
        policy=None,
        **unknown_fields,
    ):
        """Application : str
        attach_storage : typing.Sequence[str]
        num_units : int
        placement : typing.Sequence[~Placement]
        policy : str
        """
        application_ = application
        attach_storage_ = attach_storage
        num_units_ = num_units
        placement_ = [Placement.from_json(o) for o in placement or []]
        policy_ = policy

        # Validate arguments against known Juju API types.
        if application_ is not None and not isinstance(application_, (bytes, str)):
            raise Exception(
                f"Expected application_ to be a str, received: {type(application_)}"
            )

        if attach_storage_ is not None and not isinstance(
            attach_storage_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected attach_storage_ to be a Sequence, received: {type(attach_storage_)}"
            )

        if num_units_ is not None and not isinstance(num_units_, int):
            raise Exception(
                f"Expected num_units_ to be a int, received: {type(num_units_)}"
            )

        if placement_ is not None and not isinstance(placement_, (bytes, str, list)):
            raise Exception(
                f"Expected placement_ to be a Sequence, received: {type(placement_)}"
            )

        if policy_ is not None and not isinstance(policy_, (bytes, str)):
            raise Exception(f"Expected policy_ to be a str, received: {type(policy_)}")

        self.application = application_
        self.attach_storage = attach_storage_
        self.num_units = num_units_
        self.placement = placement_
        self.policy = policy_
        self.unknown_fields = unknown_fields


class AddApplicationUnitsResults(Type):
    _toSchema = {"units": "units"}
    _toPy = {"units": "units"}

    def __init__(self, units=None, **unknown_fields):
        """Units : typing.Sequence[str]"""
        units_ = units

        # Validate arguments against known Juju API types.
        if units_ is not None and not isinstance(units_, (bytes, str, list)):
            raise Exception(
                f"Expected units_ to be a Sequence, received: {type(units_)}"
            )

        self.units = units_
        self.unknown_fields = unknown_fields


class AddCharmWithOrigin(Type):
    _toSchema = {"charm_origin": "charm-origin", "force": "force", "url": "url"}
    _toPy = {"charm-origin": "charm_origin", "force": "force", "url": "url"}

    def __init__(self, charm_origin=None, force=None, url=None, **unknown_fields):
        """charm_origin : CharmOrigin
        force : bool
        url : str
        """
        charm_origin_ = CharmOrigin.from_json(charm_origin) if charm_origin else None
        force_ = force
        url_ = url

        # Validate arguments against known Juju API types.
        if charm_origin_ is not None and not isinstance(
            charm_origin_, (dict, CharmOrigin)
        ):
            raise Exception(
                f"Expected charm_origin_ to be a CharmOrigin, received: {type(charm_origin_)}"
            )

        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if url_ is not None and not isinstance(url_, (bytes, str)):
            raise Exception(f"Expected url_ to be a str, received: {type(url_)}")

        self.charm_origin = charm_origin_
        self.force = force_
        self.url = url_
        self.unknown_fields = unknown_fields


class AddCloudArgs(Type):
    _toSchema = {"cloud": "cloud", "force": "force", "name": "name"}
    _toPy = {"cloud": "cloud", "force": "force", "name": "name"}

    def __init__(self, cloud=None, force=None, name=None, **unknown_fields):
        """Cloud : Cloud
        force : bool
        name : str
        """
        cloud_ = Cloud.from_json(cloud) if cloud else None
        force_ = force
        name_ = name

        # Validate arguments against known Juju API types.
        if cloud_ is not None and not isinstance(cloud_, (dict, Cloud)):
            raise Exception(f"Expected cloud_ to be a Cloud, received: {type(cloud_)}")

        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        self.cloud = cloud_
        self.force = force_
        self.name = name_
        self.unknown_fields = unknown_fields


class AddMachineParams(Type):
    _toSchema = {
        "addresses": "addresses",
        "base": "base",
        "constraints": "constraints",
        "container_type": "container-type",
        "disks": "disks",
        "hardware_characteristics": "hardware-characteristics",
        "instance_id": "instance-id",
        "jobs": "jobs",
        "nonce": "nonce",
        "parent_id": "parent-id",
        "placement": "placement",
    }
    _toPy = {
        "addresses": "addresses",
        "base": "base",
        "constraints": "constraints",
        "container-type": "container_type",
        "disks": "disks",
        "hardware-characteristics": "hardware_characteristics",
        "instance-id": "instance_id",
        "jobs": "jobs",
        "nonce": "nonce",
        "parent-id": "parent_id",
        "placement": "placement",
    }

    def __init__(
        self,
        addresses=None,
        base=None,
        constraints=None,
        container_type=None,
        disks=None,
        hardware_characteristics=None,
        instance_id=None,
        jobs=None,
        nonce=None,
        parent_id=None,
        placement=None,
        **unknown_fields,
    ):
        """Addresses : typing.Sequence[~Address]
        base : Base
        constraints : Value
        container_type : str
        disks : typing.Sequence[~Constraints]
        hardware_characteristics : HardwareCharacteristics
        instance_id : str
        jobs : typing.Sequence[str]
        nonce : str
        parent_id : str
        placement : Placement
        """
        addresses_ = [Address.from_json(o) for o in addresses or []]
        base_ = Base.from_json(base) if base else None
        constraints_ = Value.from_json(constraints) if constraints else None
        container_type_ = container_type
        disks_ = [Constraints.from_json(o) for o in disks or []]
        hardware_characteristics_ = (
            HardwareCharacteristics.from_json(hardware_characteristics)
            if hardware_characteristics
            else None
        )
        instance_id_ = instance_id
        jobs_ = jobs
        nonce_ = nonce
        parent_id_ = parent_id
        placement_ = Placement.from_json(placement) if placement else None

        # Validate arguments against known Juju API types.
        if addresses_ is not None and not isinstance(addresses_, (bytes, str, list)):
            raise Exception(
                f"Expected addresses_ to be a Sequence, received: {type(addresses_)}"
            )

        if base_ is not None and not isinstance(base_, (dict, Base)):
            raise Exception(f"Expected base_ to be a Base, received: {type(base_)}")

        if constraints_ is not None and not isinstance(constraints_, (dict, Value)):
            raise Exception(
                f"Expected constraints_ to be a Value, received: {type(constraints_)}"
            )

        if container_type_ is not None and not isinstance(
            container_type_, (bytes, str)
        ):
            raise Exception(
                f"Expected container_type_ to be a str, received: {type(container_type_)}"
            )

        if disks_ is not None and not isinstance(disks_, (bytes, str, list)):
            raise Exception(
                f"Expected disks_ to be a Sequence, received: {type(disks_)}"
            )

        if hardware_characteristics_ is not None and not isinstance(
            hardware_characteristics_, (dict, HardwareCharacteristics)
        ):
            raise Exception(
                f"Expected hardware_characteristics_ to be a HardwareCharacteristics, received: {type(hardware_characteristics_)}"
            )

        if instance_id_ is not None and not isinstance(instance_id_, (bytes, str)):
            raise Exception(
                f"Expected instance_id_ to be a str, received: {type(instance_id_)}"
            )

        if jobs_ is not None and not isinstance(jobs_, (bytes, str, list)):
            raise Exception(f"Expected jobs_ to be a Sequence, received: {type(jobs_)}")

        if nonce_ is not None and not isinstance(nonce_, (bytes, str)):
            raise Exception(f"Expected nonce_ to be a str, received: {type(nonce_)}")

        if parent_id_ is not None and not isinstance(parent_id_, (bytes, str)):
            raise Exception(
                f"Expected parent_id_ to be a str, received: {type(parent_id_)}"
            )

        if placement_ is not None and not isinstance(placement_, (dict, Placement)):
            raise Exception(
                f"Expected placement_ to be a Placement, received: {type(placement_)}"
            )

        self.addresses = addresses_
        self.base = base_
        self.constraints = constraints_
        self.container_type = container_type_
        self.disks = disks_
        self.hardware_characteristics = hardware_characteristics_
        self.instance_id = instance_id_
        self.jobs = jobs_
        self.nonce = nonce_
        self.parent_id = parent_id_
        self.placement = placement_
        self.unknown_fields = unknown_fields


class AddMachines(Type):
    _toSchema = {"params": "params"}
    _toPy = {"params": "params"}

    def __init__(self, params=None, **unknown_fields):
        """Params : typing.Sequence[~AddMachineParams]"""
        params_ = [AddMachineParams.from_json(o) for o in params or []]

        # Validate arguments against known Juju API types.
        if params_ is not None and not isinstance(params_, (bytes, str, list)):
            raise Exception(
                f"Expected params_ to be a Sequence, received: {type(params_)}"
            )

        self.params = params_
        self.unknown_fields = unknown_fields


class AddMachinesResult(Type):
    _toSchema = {"error": "error", "machine": "machine"}
    _toPy = {"error": "error", "machine": "machine"}

    def __init__(self, error=None, machine=None, **unknown_fields):
        """Error : Error
        machine : str
        """
        error_ = Error.from_json(error) if error else None
        machine_ = machine

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if machine_ is not None and not isinstance(machine_, (bytes, str)):
            raise Exception(
                f"Expected machine_ to be a str, received: {type(machine_)}"
            )

        self.error = error_
        self.machine = machine_
        self.unknown_fields = unknown_fields


class AddMachinesResults(Type):
    _toSchema = {"machines": "machines"}
    _toPy = {"machines": "machines"}

    def __init__(self, machines=None, **unknown_fields):
        """Machines : typing.Sequence[~AddMachinesResult]"""
        machines_ = [AddMachinesResult.from_json(o) for o in machines or []]

        # Validate arguments against known Juju API types.
        if machines_ is not None and not isinstance(machines_, (bytes, str, list)):
            raise Exception(
                f"Expected machines_ to be a Sequence, received: {type(machines_)}"
            )

        self.machines = machines_
        self.unknown_fields = unknown_fields


class AddPendingResourcesArgsV2(Type):
    _toSchema = {
        "charm_origin": "charm-origin",
        "entity": "Entity",
        "macaroon": "macaroon",
        "resources": "resources",
        "tag": "tag",
        "url": "url",
    }
    _toPy = {
        "Entity": "entity",
        "charm-origin": "charm_origin",
        "macaroon": "macaroon",
        "resources": "resources",
        "tag": "tag",
        "url": "url",
    }

    def __init__(
        self,
        entity=None,
        charm_origin=None,
        macaroon=None,
        resources=None,
        tag=None,
        url=None,
        **unknown_fields,
    ):
        """Entity : Entity
        charm_origin : CharmOrigin
        macaroon : Macaroon
        resources : typing.Sequence[~CharmResource]
        tag : str
        url : str
        """
        entity_ = Entity.from_json(entity) if entity else None
        charm_origin_ = CharmOrigin.from_json(charm_origin) if charm_origin else None
        macaroon_ = Macaroon.from_json(macaroon) if macaroon else None
        resources_ = [CharmResource.from_json(o) for o in resources or []]
        tag_ = tag
        url_ = url

        # Validate arguments against known Juju API types.
        if entity_ is not None and not isinstance(entity_, (dict, Entity)):
            raise Exception(
                f"Expected entity_ to be a Entity, received: {type(entity_)}"
            )

        if charm_origin_ is not None and not isinstance(
            charm_origin_, (dict, CharmOrigin)
        ):
            raise Exception(
                f"Expected charm_origin_ to be a CharmOrigin, received: {type(charm_origin_)}"
            )

        if macaroon_ is not None and not isinstance(macaroon_, (dict, Macaroon)):
            raise Exception(
                f"Expected macaroon_ to be a Macaroon, received: {type(macaroon_)}"
            )

        if resources_ is not None and not isinstance(resources_, (bytes, str, list)):
            raise Exception(
                f"Expected resources_ to be a Sequence, received: {type(resources_)}"
            )

        if tag_ is not None and not isinstance(tag_, (bytes, str)):
            raise Exception(f"Expected tag_ to be a str, received: {type(tag_)}")

        if url_ is not None and not isinstance(url_, (bytes, str)):
            raise Exception(f"Expected url_ to be a str, received: {type(url_)}")

        self.entity = entity_
        self.charm_origin = charm_origin_
        self.macaroon = macaroon_
        self.resources = resources_
        self.tag = tag_
        self.url = url_
        self.unknown_fields = unknown_fields


class AddPendingResourcesResult(Type):
    _toSchema = {
        "error": "error",
        "errorresult": "ErrorResult",
        "pending_ids": "pending-ids",
    }
    _toPy = {
        "ErrorResult": "errorresult",
        "error": "error",
        "pending-ids": "pending_ids",
    }

    def __init__(
        self, errorresult=None, error=None, pending_ids=None, **unknown_fields
    ):
        """Errorresult : ErrorResult
        error : Error
        pending_ids : typing.Sequence[str]
        """
        errorresult_ = ErrorResult.from_json(errorresult) if errorresult else None
        error_ = Error.from_json(error) if error else None
        pending_ids_ = pending_ids

        # Validate arguments against known Juju API types.
        if errorresult_ is not None and not isinstance(
            errorresult_, (dict, ErrorResult)
        ):
            raise Exception(
                f"Expected errorresult_ to be a ErrorResult, received: {type(errorresult_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if pending_ids_ is not None and not isinstance(
            pending_ids_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected pending_ids_ to be a Sequence, received: {type(pending_ids_)}"
            )

        self.errorresult = errorresult_
        self.error = error_
        self.pending_ids = pending_ids_
        self.unknown_fields = unknown_fields


class AddRelation(Type):
    _toSchema = {"endpoints": "endpoints", "via_cidrs": "via-cidrs"}
    _toPy = {"endpoints": "endpoints", "via-cidrs": "via_cidrs"}

    def __init__(self, endpoints=None, via_cidrs=None, **unknown_fields):
        """Endpoints : typing.Sequence[str]
        via_cidrs : typing.Sequence[str]
        """
        endpoints_ = endpoints
        via_cidrs_ = via_cidrs

        # Validate arguments against known Juju API types.
        if endpoints_ is not None and not isinstance(endpoints_, (bytes, str, list)):
            raise Exception(
                f"Expected endpoints_ to be a Sequence, received: {type(endpoints_)}"
            )

        if via_cidrs_ is not None and not isinstance(via_cidrs_, (bytes, str, list)):
            raise Exception(
                f"Expected via_cidrs_ to be a Sequence, received: {type(via_cidrs_)}"
            )

        self.endpoints = endpoints_
        self.via_cidrs = via_cidrs_
        self.unknown_fields = unknown_fields


class AddRelationResults(Type):
    _toSchema = {"endpoints": "endpoints"}
    _toPy = {"endpoints": "endpoints"}

    def __init__(self, endpoints=None, **unknown_fields):
        """Endpoints : typing.Mapping[str, ~CharmRelation]"""
        endpoints_ = {
            k: CharmRelation.from_json(v) for k, v in (endpoints or dict()).items()
        }

        # Validate arguments against known Juju API types.
        if endpoints_ is not None and not isinstance(endpoints_, dict):
            raise Exception(
                f"Expected endpoints_ to be a Mapping, received: {type(endpoints_)}"
            )

        self.endpoints = endpoints_
        self.unknown_fields = unknown_fields


class AddSecretBackendArg(Type):
    _toSchema = {
        "backend_type": "backend-type",
        "config": "config",
        "id_": "id",
        "name": "name",
        "secretbackend": "SecretBackend",
        "token_rotate_interval": "token-rotate-interval",
    }
    _toPy = {
        "SecretBackend": "secretbackend",
        "backend-type": "backend_type",
        "config": "config",
        "id": "id_",
        "name": "name",
        "token-rotate-interval": "token_rotate_interval",
    }

    def __init__(
        self,
        secretbackend=None,
        backend_type=None,
        config=None,
        id_=None,
        name=None,
        token_rotate_interval=None,
        **unknown_fields,
    ):
        """Secretbackend : SecretBackend
        backend_type : str
        config : typing.Mapping[str, typing.Any]
        id_ : str
        name : str
        token_rotate_interval : int
        """
        secretbackend_ = (
            SecretBackend.from_json(secretbackend) if secretbackend else None
        )
        backend_type_ = backend_type
        config_ = config
        id__ = id_
        name_ = name
        token_rotate_interval_ = token_rotate_interval

        # Validate arguments against known Juju API types.
        if secretbackend_ is not None and not isinstance(
            secretbackend_, (dict, SecretBackend)
        ):
            raise Exception(
                f"Expected secretbackend_ to be a SecretBackend, received: {type(secretbackend_)}"
            )

        if backend_type_ is not None and not isinstance(backend_type_, (bytes, str)):
            raise Exception(
                f"Expected backend_type_ to be a str, received: {type(backend_type_)}"
            )

        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        if id__ is not None and not isinstance(id__, (bytes, str)):
            raise Exception(f"Expected id__ to be a str, received: {type(id__)}")

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if token_rotate_interval_ is not None and not isinstance(
            token_rotate_interval_, int
        ):
            raise Exception(
                f"Expected token_rotate_interval_ to be a int, received: {type(token_rotate_interval_)}"
            )

        self.secretbackend = secretbackend_
        self.backend_type = backend_type_
        self.config = config_
        self.id_ = id__
        self.name = name_
        self.token_rotate_interval = token_rotate_interval_
        self.unknown_fields = unknown_fields


class AddSecretBackendArgs(Type):
    _toSchema = {"args": "args"}
    _toPy = {"args": "args"}

    def __init__(self, args=None, **unknown_fields):
        """Args : typing.Sequence[~AddSecretBackendArg]"""
        args_ = [AddSecretBackendArg.from_json(o) for o in args or []]

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, (bytes, str, list)):
            raise Exception(f"Expected args_ to be a Sequence, received: {type(args_)}")

        self.args = args_
        self.unknown_fields = unknown_fields


class AddStorageDetails(Type):
    _toSchema = {"storage_tags": "storage-tags"}
    _toPy = {"storage-tags": "storage_tags"}

    def __init__(self, storage_tags=None, **unknown_fields):
        """storage_tags : typing.Sequence[str]"""
        storage_tags_ = storage_tags

        # Validate arguments against known Juju API types.
        if storage_tags_ is not None and not isinstance(
            storage_tags_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected storage_tags_ to be a Sequence, received: {type(storage_tags_)}"
            )

        self.storage_tags = storage_tags_
        self.unknown_fields = unknown_fields


class AddStorageResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : AddStorageDetails
        """
        error_ = Error.from_json(error) if error else None
        result_ = AddStorageDetails.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (dict, AddStorageDetails)):
            raise Exception(
                f"Expected result_ to be a AddStorageDetails, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class AddStorageResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~AddStorageResult]"""
        results_ = [AddStorageResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class AddUser(Type):
    _toSchema = {
        "display_name": "display-name",
        "password": "password",
        "username": "username",
    }
    _toPy = {
        "display-name": "display_name",
        "password": "password",
        "username": "username",
    }

    def __init__(
        self, display_name=None, password=None, username=None, **unknown_fields
    ):
        """display_name : str
        password : str
        username : str
        """
        display_name_ = display_name
        password_ = password
        username_ = username

        # Validate arguments against known Juju API types.
        if display_name_ is not None and not isinstance(display_name_, (bytes, str)):
            raise Exception(
                f"Expected display_name_ to be a str, received: {type(display_name_)}"
            )

        if password_ is not None and not isinstance(password_, (bytes, str)):
            raise Exception(
                f"Expected password_ to be a str, received: {type(password_)}"
            )

        if username_ is not None and not isinstance(username_, (bytes, str)):
            raise Exception(
                f"Expected username_ to be a str, received: {type(username_)}"
            )

        self.display_name = display_name_
        self.password = password_
        self.username = username_
        self.unknown_fields = unknown_fields


class AddUserResult(Type):
    _toSchema = {"error": "error", "secret_key": "secret-key", "tag": "tag"}
    _toPy = {"error": "error", "secret-key": "secret_key", "tag": "tag"}

    def __init__(self, error=None, secret_key=None, tag=None, **unknown_fields):
        """Error : Error
        secret_key : typing.Sequence[int]
        tag : str
        """
        error_ = Error.from_json(error) if error else None
        secret_key_ = secret_key
        tag_ = tag

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if secret_key_ is not None and not isinstance(secret_key_, (bytes, str, list)):
            raise Exception(
                f"Expected secret_key_ to be a Sequence, received: {type(secret_key_)}"
            )

        if tag_ is not None and not isinstance(tag_, (bytes, str)):
            raise Exception(f"Expected tag_ to be a str, received: {type(tag_)}")

        self.error = error_
        self.secret_key = secret_key_
        self.tag = tag_
        self.unknown_fields = unknown_fields


class AddUserResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~AddUserResult]"""
        results_ = [AddUserResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class AddUsers(Type):
    _toSchema = {"users": "users"}
    _toPy = {"users": "users"}

    def __init__(self, users=None, **unknown_fields):
        """Users : typing.Sequence[~AddUser]"""
        users_ = [AddUser.from_json(o) for o in users or []]

        # Validate arguments against known Juju API types.
        if users_ is not None and not isinstance(users_, (bytes, str, list)):
            raise Exception(
                f"Expected users_ to be a Sequence, received: {type(users_)}"
            )

        self.users = users_
        self.unknown_fields = unknown_fields


class Address(Type):
    _toSchema = {
        "cidr": "cidr",
        "config_type": "config-type",
        "is_secondary": "is-secondary",
        "scope": "scope",
        "space_id": "space-id",
        "space_name": "space-name",
        "type_": "type",
        "value": "value",
    }
    _toPy = {
        "cidr": "cidr",
        "config-type": "config_type",
        "is-secondary": "is_secondary",
        "scope": "scope",
        "space-id": "space_id",
        "space-name": "space_name",
        "type": "type_",
        "value": "value",
    }

    def __init__(
        self,
        cidr=None,
        config_type=None,
        is_secondary=None,
        scope=None,
        space_id=None,
        space_name=None,
        type_=None,
        value=None,
        **unknown_fields,
    ):
        """Cidr : str
        config_type : str
        is_secondary : bool
        scope : str
        space_id : str
        space_name : str
        type_ : str
        value : str
        """
        cidr_ = cidr
        config_type_ = config_type
        is_secondary_ = is_secondary
        scope_ = scope
        space_id_ = space_id
        space_name_ = space_name
        type__ = type_
        value_ = value

        # Validate arguments against known Juju API types.
        if cidr_ is not None and not isinstance(cidr_, (bytes, str)):
            raise Exception(f"Expected cidr_ to be a str, received: {type(cidr_)}")

        if config_type_ is not None and not isinstance(config_type_, (bytes, str)):
            raise Exception(
                f"Expected config_type_ to be a str, received: {type(config_type_)}"
            )

        if is_secondary_ is not None and not isinstance(is_secondary_, bool):
            raise Exception(
                f"Expected is_secondary_ to be a bool, received: {type(is_secondary_)}"
            )

        if scope_ is not None and not isinstance(scope_, (bytes, str)):
            raise Exception(f"Expected scope_ to be a str, received: {type(scope_)}")

        if space_id_ is not None and not isinstance(space_id_, (bytes, str)):
            raise Exception(
                f"Expected space_id_ to be a str, received: {type(space_id_)}"
            )

        if space_name_ is not None and not isinstance(space_name_, (bytes, str)):
            raise Exception(
                f"Expected space_name_ to be a str, received: {type(space_name_)}"
            )

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        if value_ is not None and not isinstance(value_, (bytes, str)):
            raise Exception(f"Expected value_ to be a str, received: {type(value_)}")

        self.cidr = cidr_
        self.config_type = config_type_
        self.is_secondary = is_secondary_
        self.scope = scope_
        self.space_id = space_id_
        self.space_name = space_name_
        self.type_ = type__
        self.value = value_
        self.unknown_fields = unknown_fields


class AllWatcherId(Type):
    _toSchema = {"watcher_id": "watcher-id"}
    _toPy = {"watcher-id": "watcher_id"}

    def __init__(self, watcher_id=None, **unknown_fields):
        """watcher_id : str"""
        watcher_id_ = watcher_id

        # Validate arguments against known Juju API types.
        if watcher_id_ is not None and not isinstance(watcher_id_, (bytes, str)):
            raise Exception(
                f"Expected watcher_id_ to be a str, received: {type(watcher_id_)}"
            )

        self.watcher_id = watcher_id_
        self.unknown_fields = unknown_fields


class AllWatcherNextResults(Type):
    _toSchema = {"deltas": "deltas"}
    _toPy = {"deltas": "deltas"}

    def __init__(self, deltas=None, **unknown_fields):
        """Deltas : typing.Sequence[~Delta]"""
        deltas_ = [Delta.from_json(o) for o in deltas or []]

        # Validate arguments against known Juju API types.
        if deltas_ is not None and not isinstance(deltas_, (bytes, str, list)):
            raise Exception(
                f"Expected deltas_ to be a Sequence, received: {type(deltas_)}"
            )

        self.deltas = deltas_
        self.unknown_fields = unknown_fields


class AnnotationsGetResult(Type):
    _toSchema = {"annotations": "annotations", "entity": "entity", "error": "error"}
    _toPy = {"annotations": "annotations", "entity": "entity", "error": "error"}

    def __init__(self, annotations=None, entity=None, error=None, **unknown_fields):
        """Annotations : typing.Mapping[str, str]
        entity : str
        error : ErrorResult
        """
        annotations_ = annotations
        entity_ = entity
        error_ = ErrorResult.from_json(error) if error else None

        # Validate arguments against known Juju API types.
        if annotations_ is not None and not isinstance(annotations_, dict):
            raise Exception(
                f"Expected annotations_ to be a Mapping, received: {type(annotations_)}"
            )

        if entity_ is not None and not isinstance(entity_, (bytes, str)):
            raise Exception(f"Expected entity_ to be a str, received: {type(entity_)}")

        if error_ is not None and not isinstance(error_, (dict, ErrorResult)):
            raise Exception(
                f"Expected error_ to be a ErrorResult, received: {type(error_)}"
            )

        self.annotations = annotations_
        self.entity = entity_
        self.error = error_
        self.unknown_fields = unknown_fields


class AnnotationsGetResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~AnnotationsGetResult]"""
        results_ = [AnnotationsGetResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class AnnotationsSet(Type):
    _toSchema = {"annotations": "annotations"}
    _toPy = {"annotations": "annotations"}

    def __init__(self, annotations=None, **unknown_fields):
        """Annotations : typing.Sequence[~EntityAnnotations]"""
        annotations_ = [EntityAnnotations.from_json(o) for o in annotations or []]

        # Validate arguments against known Juju API types.
        if annotations_ is not None and not isinstance(
            annotations_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected annotations_ to be a Sequence, received: {type(annotations_)}"
            )

        self.annotations = annotations_
        self.unknown_fields = unknown_fields


class ApplicationCharmActionsResult(Type):
    _toSchema = {
        "actions": "actions",
        "application_tag": "application-tag",
        "error": "error",
    }
    _toPy = {
        "actions": "actions",
        "application-tag": "application_tag",
        "error": "error",
    }

    def __init__(
        self, actions=None, application_tag=None, error=None, **unknown_fields
    ):
        """Actions : typing.Mapping[str, ~ActionSpec]
        application_tag : str
        error : Error
        """
        actions_ = {k: ActionSpec.from_json(v) for k, v in (actions or dict()).items()}
        application_tag_ = application_tag
        error_ = Error.from_json(error) if error else None

        # Validate arguments against known Juju API types.
        if actions_ is not None and not isinstance(actions_, dict):
            raise Exception(
                f"Expected actions_ to be a Mapping, received: {type(actions_)}"
            )

        if application_tag_ is not None and not isinstance(
            application_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_tag_ to be a str, received: {type(application_tag_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        self.actions = actions_
        self.application_tag = application_tag_
        self.error = error_
        self.unknown_fields = unknown_fields


class ApplicationCharmPlacement(Type):
    _toSchema = {"application": "application", "charm_url": "charm-url"}
    _toPy = {"application": "application", "charm-url": "charm_url"}

    def __init__(self, application=None, charm_url=None, **unknown_fields):
        """Application : str
        charm_url : str
        """
        application_ = application
        charm_url_ = charm_url

        # Validate arguments against known Juju API types.
        if application_ is not None and not isinstance(application_, (bytes, str)):
            raise Exception(
                f"Expected application_ to be a str, received: {type(application_)}"
            )

        if charm_url_ is not None and not isinstance(charm_url_, (bytes, str)):
            raise Exception(
                f"Expected charm_url_ to be a str, received: {type(charm_url_)}"
            )

        self.application = application_
        self.charm_url = charm_url_
        self.unknown_fields = unknown_fields


class ApplicationCharmPlacements(Type):
    _toSchema = {"placements": "placements"}
    _toPy = {"placements": "placements"}

    def __init__(self, placements=None, **unknown_fields):
        """Placements : typing.Sequence[~ApplicationCharmPlacement]"""
        placements_ = [ApplicationCharmPlacement.from_json(o) for o in placements or []]

        # Validate arguments against known Juju API types.
        if placements_ is not None and not isinstance(placements_, (bytes, str, list)):
            raise Exception(
                f"Expected placements_ to be a Sequence, received: {type(placements_)}"
            )

        self.placements = placements_
        self.unknown_fields = unknown_fields


class ApplicationCharmRelations(Type):
    _toSchema = {"application": "application"}
    _toPy = {"application": "application"}

    def __init__(self, application=None, **unknown_fields):
        """Application : str"""
        application_ = application

        # Validate arguments against known Juju API types.
        if application_ is not None and not isinstance(application_, (bytes, str)):
            raise Exception(
                f"Expected application_ to be a str, received: {type(application_)}"
            )

        self.application = application_
        self.unknown_fields = unknown_fields


class ApplicationCharmRelationsResults(Type):
    _toSchema = {"charm_relations": "charm-relations"}
    _toPy = {"charm-relations": "charm_relations"}

    def __init__(self, charm_relations=None, **unknown_fields):
        """charm_relations : typing.Sequence[str]"""
        charm_relations_ = charm_relations

        # Validate arguments against known Juju API types.
        if charm_relations_ is not None and not isinstance(
            charm_relations_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected charm_relations_ to be a Sequence, received: {type(charm_relations_)}"
            )

        self.charm_relations = charm_relations_
        self.unknown_fields = unknown_fields


class ApplicationConfigUnsetArgs(Type):
    _toSchema = {"args": "Args"}
    _toPy = {"Args": "args"}

    def __init__(self, args=None, **unknown_fields):
        """Args : typing.Sequence[~ApplicationUnset]"""
        args_ = [ApplicationUnset.from_json(o) for o in args or []]

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, (bytes, str, list)):
            raise Exception(f"Expected args_ to be a Sequence, received: {type(args_)}")

        self.args = args_
        self.unknown_fields = unknown_fields


class ApplicationConstraint(Type):
    _toSchema = {"constraints": "constraints", "error": "error"}
    _toPy = {"constraints": "constraints", "error": "error"}

    def __init__(self, constraints=None, error=None, **unknown_fields):
        """Constraints : Value
        error : Error
        """
        constraints_ = Value.from_json(constraints) if constraints else None
        error_ = Error.from_json(error) if error else None

        # Validate arguments against known Juju API types.
        if constraints_ is not None and not isinstance(constraints_, (dict, Value)):
            raise Exception(
                f"Expected constraints_ to be a Value, received: {type(constraints_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        self.constraints = constraints_
        self.error = error_
        self.unknown_fields = unknown_fields


class ApplicationDeploy(Type):
    _toSchema = {
        "application": "application",
        "attach_storage": "attach-storage",
        "channel": "channel",
        "charm_origin": "charm-origin",
        "charm_url": "charm-url",
        "config": "config",
        "config_yaml": "config-yaml",
        "constraints": "constraints",
        "devices": "devices",
        "endpoint_bindings": "endpoint-bindings",
        "force": "Force",
        "num_units": "num-units",
        "placement": "placement",
        "policy": "policy",
        "resources": "resources",
        "storage": "storage",
    }
    _toPy = {
        "Force": "force",
        "application": "application",
        "attach-storage": "attach_storage",
        "channel": "channel",
        "charm-origin": "charm_origin",
        "charm-url": "charm_url",
        "config": "config",
        "config-yaml": "config_yaml",
        "constraints": "constraints",
        "devices": "devices",
        "endpoint-bindings": "endpoint_bindings",
        "num-units": "num_units",
        "placement": "placement",
        "policy": "policy",
        "resources": "resources",
        "storage": "storage",
    }

    def __init__(
        self,
        force=None,
        application=None,
        attach_storage=None,
        channel=None,
        charm_origin=None,
        charm_url=None,
        config=None,
        config_yaml=None,
        constraints=None,
        devices=None,
        endpoint_bindings=None,
        num_units=None,
        placement=None,
        policy=None,
        resources=None,
        storage=None,
        **unknown_fields,
    ):
        """Force : bool
        application : str
        attach_storage : typing.Sequence[str]
        channel : str
        charm_origin : CharmOrigin
        charm_url : str
        config : typing.Mapping[str, str]
        config_yaml : str
        constraints : Value
        devices : typing.Mapping[str, ~Constraints]
        endpoint_bindings : typing.Mapping[str, str]
        num_units : int
        placement : typing.Sequence[~Placement]
        policy : str
        resources : typing.Mapping[str, str]
        storage : typing.Mapping[str, ~Constraints]
        """
        force_ = force
        application_ = application
        attach_storage_ = attach_storage
        channel_ = channel
        charm_origin_ = CharmOrigin.from_json(charm_origin) if charm_origin else None
        charm_url_ = charm_url
        config_ = config
        config_yaml_ = config_yaml
        constraints_ = Value.from_json(constraints) if constraints else None
        devices_ = {k: Constraints.from_json(v) for k, v in (devices or dict()).items()}
        endpoint_bindings_ = endpoint_bindings
        num_units_ = num_units
        placement_ = [Placement.from_json(o) for o in placement or []]
        policy_ = policy
        resources_ = resources
        storage_ = {k: Constraints.from_json(v) for k, v in (storage or dict()).items()}

        # Validate arguments against known Juju API types.
        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if application_ is not None and not isinstance(application_, (bytes, str)):
            raise Exception(
                f"Expected application_ to be a str, received: {type(application_)}"
            )

        if attach_storage_ is not None and not isinstance(
            attach_storage_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected attach_storage_ to be a Sequence, received: {type(attach_storage_)}"
            )

        if channel_ is not None and not isinstance(channel_, (bytes, str)):
            raise Exception(
                f"Expected channel_ to be a str, received: {type(channel_)}"
            )

        if charm_origin_ is not None and not isinstance(
            charm_origin_, (dict, CharmOrigin)
        ):
            raise Exception(
                f"Expected charm_origin_ to be a CharmOrigin, received: {type(charm_origin_)}"
            )

        if charm_url_ is not None and not isinstance(charm_url_, (bytes, str)):
            raise Exception(
                f"Expected charm_url_ to be a str, received: {type(charm_url_)}"
            )

        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        if config_yaml_ is not None and not isinstance(config_yaml_, (bytes, str)):
            raise Exception(
                f"Expected config_yaml_ to be a str, received: {type(config_yaml_)}"
            )

        if constraints_ is not None and not isinstance(constraints_, (dict, Value)):
            raise Exception(
                f"Expected constraints_ to be a Value, received: {type(constraints_)}"
            )

        if devices_ is not None and not isinstance(devices_, dict):
            raise Exception(
                f"Expected devices_ to be a Mapping, received: {type(devices_)}"
            )

        if endpoint_bindings_ is not None and not isinstance(endpoint_bindings_, dict):
            raise Exception(
                f"Expected endpoint_bindings_ to be a Mapping, received: {type(endpoint_bindings_)}"
            )

        if num_units_ is not None and not isinstance(num_units_, int):
            raise Exception(
                f"Expected num_units_ to be a int, received: {type(num_units_)}"
            )

        if placement_ is not None and not isinstance(placement_, (bytes, str, list)):
            raise Exception(
                f"Expected placement_ to be a Sequence, received: {type(placement_)}"
            )

        if policy_ is not None and not isinstance(policy_, (bytes, str)):
            raise Exception(f"Expected policy_ to be a str, received: {type(policy_)}")

        if resources_ is not None and not isinstance(resources_, dict):
            raise Exception(
                f"Expected resources_ to be a Mapping, received: {type(resources_)}"
            )

        if storage_ is not None and not isinstance(storage_, dict):
            raise Exception(
                f"Expected storage_ to be a Mapping, received: {type(storage_)}"
            )

        self.force = force_
        self.application = application_
        self.attach_storage = attach_storage_
        self.channel = channel_
        self.charm_origin = charm_origin_
        self.charm_url = charm_url_
        self.config = config_
        self.config_yaml = config_yaml_
        self.constraints = constraints_
        self.devices = devices_
        self.endpoint_bindings = endpoint_bindings_
        self.num_units = num_units_
        self.placement = placement_
        self.policy = policy_
        self.resources = resources_
        self.storage = storage_
        self.unknown_fields = unknown_fields


class ApplicationExpose(Type):
    _toSchema = {"application": "application", "exposed_endpoints": "exposed-endpoints"}
    _toPy = {"application": "application", "exposed-endpoints": "exposed_endpoints"}

    def __init__(self, application=None, exposed_endpoints=None, **unknown_fields):
        """Application : str
        exposed_endpoints : typing.Mapping[str, ~ExposedEndpoint]
        """
        application_ = application
        exposed_endpoints_ = {
            k: ExposedEndpoint.from_json(v)
            for k, v in (exposed_endpoints or dict()).items()
        }

        # Validate arguments against known Juju API types.
        if application_ is not None and not isinstance(application_, (bytes, str)):
            raise Exception(
                f"Expected application_ to be a str, received: {type(application_)}"
            )

        if exposed_endpoints_ is not None and not isinstance(exposed_endpoints_, dict):
            raise Exception(
                f"Expected exposed_endpoints_ to be a Mapping, received: {type(exposed_endpoints_)}"
            )

        self.application = application_
        self.exposed_endpoints = exposed_endpoints_
        self.unknown_fields = unknown_fields


class ApplicationGet(Type):
    _toSchema = {"application": "application", "branch": "branch"}
    _toPy = {"application": "application", "branch": "branch"}

    def __init__(self, application=None, branch=None, **unknown_fields):
        """Application : str
        branch : str
        """
        application_ = application
        branch_ = branch

        # Validate arguments against known Juju API types.
        if application_ is not None and not isinstance(application_, (bytes, str)):
            raise Exception(
                f"Expected application_ to be a str, received: {type(application_)}"
            )

        if branch_ is not None and not isinstance(branch_, (bytes, str)):
            raise Exception(f"Expected branch_ to be a str, received: {type(branch_)}")

        self.application = application_
        self.branch = branch_
        self.unknown_fields = unknown_fields


class ApplicationGetArgs(Type):
    _toSchema = {"args": "args"}
    _toPy = {"args": "args"}

    def __init__(self, args=None, **unknown_fields):
        """Args : typing.Sequence[~ApplicationGet]"""
        args_ = [ApplicationGet.from_json(o) for o in args or []]

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, (bytes, str, list)):
            raise Exception(f"Expected args_ to be a Sequence, received: {type(args_)}")

        self.args = args_
        self.unknown_fields = unknown_fields


class ApplicationGetConfigResults(Type):
    _toSchema = {"results": "Results"}
    _toPy = {"Results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ConfigResult]"""
        results_ = [ConfigResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ApplicationGetConstraintsResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ApplicationConstraint]"""
        results_ = [ApplicationConstraint.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ApplicationGetResults(Type):
    _toSchema = {
        "application": "application",
        "application_config": "application-config",
        "base": "base",
        "channel": "channel",
        "charm": "charm",
        "config": "config",
        "constraints": "constraints",
        "endpoint_bindings": "endpoint-bindings",
    }
    _toPy = {
        "application": "application",
        "application-config": "application_config",
        "base": "base",
        "channel": "channel",
        "charm": "charm",
        "config": "config",
        "constraints": "constraints",
        "endpoint-bindings": "endpoint_bindings",
    }

    def __init__(
        self,
        application=None,
        application_config=None,
        base=None,
        channel=None,
        charm=None,
        config=None,
        constraints=None,
        endpoint_bindings=None,
        **unknown_fields,
    ):
        """Application : str
        application_config : typing.Mapping[str, typing.Any]
        base : Base
        channel : str
        charm : str
        config : typing.Mapping[str, typing.Any]
        constraints : Value
        endpoint_bindings : typing.Mapping[str, str]
        """
        application_ = application
        application_config_ = application_config
        base_ = Base.from_json(base) if base else None
        channel_ = channel
        charm_ = charm
        config_ = config
        constraints_ = Value.from_json(constraints) if constraints else None
        endpoint_bindings_ = endpoint_bindings

        # Validate arguments against known Juju API types.
        if application_ is not None and not isinstance(application_, (bytes, str)):
            raise Exception(
                f"Expected application_ to be a str, received: {type(application_)}"
            )

        if application_config_ is not None and not isinstance(
            application_config_, dict
        ):
            raise Exception(
                f"Expected application_config_ to be a Mapping, received: {type(application_config_)}"
            )

        if base_ is not None and not isinstance(base_, (dict, Base)):
            raise Exception(f"Expected base_ to be a Base, received: {type(base_)}")

        if channel_ is not None and not isinstance(channel_, (bytes, str)):
            raise Exception(
                f"Expected channel_ to be a str, received: {type(channel_)}"
            )

        if charm_ is not None and not isinstance(charm_, (bytes, str)):
            raise Exception(f"Expected charm_ to be a str, received: {type(charm_)}")

        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        if constraints_ is not None and not isinstance(constraints_, (dict, Value)):
            raise Exception(
                f"Expected constraints_ to be a Value, received: {type(constraints_)}"
            )

        if endpoint_bindings_ is not None and not isinstance(endpoint_bindings_, dict):
            raise Exception(
                f"Expected endpoint_bindings_ to be a Mapping, received: {type(endpoint_bindings_)}"
            )

        self.application = application_
        self.application_config = application_config_
        self.base = base_
        self.channel = channel_
        self.charm = charm_
        self.config = config_
        self.constraints = constraints_
        self.endpoint_bindings = endpoint_bindings_
        self.unknown_fields = unknown_fields


class ApplicationInfoResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : ApplicationResult
        """
        error_ = Error.from_json(error) if error else None
        result_ = ApplicationResult.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (dict, ApplicationResult)):
            raise Exception(
                f"Expected result_ to be a ApplicationResult, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class ApplicationInfoResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ApplicationInfoResult]"""
        results_ = [ApplicationInfoResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ApplicationMergeBindings(Type):
    _toSchema = {
        "application_tag": "application-tag",
        "bindings": "bindings",
        "force": "force",
    }
    _toPy = {
        "application-tag": "application_tag",
        "bindings": "bindings",
        "force": "force",
    }

    def __init__(
        self, application_tag=None, bindings=None, force=None, **unknown_fields
    ):
        """application_tag : str
        bindings : typing.Mapping[str, str]
        force : bool
        """
        application_tag_ = application_tag
        bindings_ = bindings
        force_ = force

        # Validate arguments against known Juju API types.
        if application_tag_ is not None and not isinstance(
            application_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_tag_ to be a str, received: {type(application_tag_)}"
            )

        if bindings_ is not None and not isinstance(bindings_, dict):
            raise Exception(
                f"Expected bindings_ to be a Mapping, received: {type(bindings_)}"
            )

        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        self.application_tag = application_tag_
        self.bindings = bindings_
        self.force = force_
        self.unknown_fields = unknown_fields


class ApplicationMergeBindingsArgs(Type):
    _toSchema = {"args": "args"}
    _toPy = {"args": "args"}

    def __init__(self, args=None, **unknown_fields):
        """Args : typing.Sequence[~ApplicationMergeBindings]"""
        args_ = [ApplicationMergeBindings.from_json(o) for o in args or []]

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, (bytes, str, list)):
            raise Exception(f"Expected args_ to be a Sequence, received: {type(args_)}")

        self.args = args_
        self.unknown_fields = unknown_fields


class ApplicationMetricCredential(Type):
    _toSchema = {
        "application": "application",
        "metrics_credentials": "metrics-credentials",
    }
    _toPy = {"application": "application", "metrics-credentials": "metrics_credentials"}

    def __init__(self, application=None, metrics_credentials=None, **unknown_fields):
        """Application : str
        metrics_credentials : typing.Sequence[int]
        """
        application_ = application
        metrics_credentials_ = metrics_credentials

        # Validate arguments against known Juju API types.
        if application_ is not None and not isinstance(application_, (bytes, str)):
            raise Exception(
                f"Expected application_ to be a str, received: {type(application_)}"
            )

        if metrics_credentials_ is not None and not isinstance(
            metrics_credentials_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected metrics_credentials_ to be a Sequence, received: {type(metrics_credentials_)}"
            )

        self.application = application_
        self.metrics_credentials = metrics_credentials_
        self.unknown_fields = unknown_fields


class ApplicationMetricCredentials(Type):
    _toSchema = {"creds": "creds"}
    _toPy = {"creds": "creds"}

    def __init__(self, creds=None, **unknown_fields):
        """Creds : typing.Sequence[~ApplicationMetricCredential]"""
        creds_ = [ApplicationMetricCredential.from_json(o) for o in creds or []]

        # Validate arguments against known Juju API types.
        if creds_ is not None and not isinstance(creds_, (bytes, str, list)):
            raise Exception(
                f"Expected creds_ to be a Sequence, received: {type(creds_)}"
            )

        self.creds = creds_
        self.unknown_fields = unknown_fields


class ApplicationOfferAdminDetails(Type):
    _toSchema = {
        "application_description": "application-description",
        "application_name": "application-name",
        "applicationofferdetails": "ApplicationOfferDetails",
        "bindings": "bindings",
        "charm_url": "charm-url",
        "connections": "connections",
        "endpoints": "endpoints",
        "offer_name": "offer-name",
        "offer_url": "offer-url",
        "offer_uuid": "offer-uuid",
        "source_model_tag": "source-model-tag",
        "spaces": "spaces",
        "users": "users",
    }
    _toPy = {
        "ApplicationOfferDetails": "applicationofferdetails",
        "application-description": "application_description",
        "application-name": "application_name",
        "bindings": "bindings",
        "charm-url": "charm_url",
        "connections": "connections",
        "endpoints": "endpoints",
        "offer-name": "offer_name",
        "offer-url": "offer_url",
        "offer-uuid": "offer_uuid",
        "source-model-tag": "source_model_tag",
        "spaces": "spaces",
        "users": "users",
    }

    def __init__(
        self,
        applicationofferdetails=None,
        application_description=None,
        application_name=None,
        bindings=None,
        charm_url=None,
        connections=None,
        endpoints=None,
        offer_name=None,
        offer_url=None,
        offer_uuid=None,
        source_model_tag=None,
        spaces=None,
        users=None,
        **unknown_fields,
    ):
        """Applicationofferdetails : ApplicationOfferDetails
        application_description : str
        application_name : str
        bindings : typing.Mapping[str, str]
        charm_url : str
        connections : typing.Sequence[~OfferConnection]
        endpoints : typing.Sequence[~RemoteEndpoint]
        offer_name : str
        offer_url : str
        offer_uuid : str
        source_model_tag : str
        spaces : typing.Sequence[~RemoteSpace]
        users : typing.Sequence[~OfferUserDetails]
        """
        applicationofferdetails_ = (
            ApplicationOfferDetails.from_json(applicationofferdetails)
            if applicationofferdetails
            else None
        )
        application_description_ = application_description
        application_name_ = application_name
        bindings_ = bindings
        charm_url_ = charm_url
        connections_ = [OfferConnection.from_json(o) for o in connections or []]
        endpoints_ = [RemoteEndpoint.from_json(o) for o in endpoints or []]
        offer_name_ = offer_name
        offer_url_ = offer_url
        offer_uuid_ = offer_uuid
        source_model_tag_ = source_model_tag
        spaces_ = [RemoteSpace.from_json(o) for o in spaces or []]
        users_ = [OfferUserDetails.from_json(o) for o in users or []]

        # Validate arguments against known Juju API types.
        if applicationofferdetails_ is not None and not isinstance(
            applicationofferdetails_, (dict, ApplicationOfferDetails)
        ):
            raise Exception(
                f"Expected applicationofferdetails_ to be a ApplicationOfferDetails, received: {type(applicationofferdetails_)}"
            )

        if application_description_ is not None and not isinstance(
            application_description_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_description_ to be a str, received: {type(application_description_)}"
            )

        if application_name_ is not None and not isinstance(
            application_name_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_name_ to be a str, received: {type(application_name_)}"
            )

        if bindings_ is not None and not isinstance(bindings_, dict):
            raise Exception(
                f"Expected bindings_ to be a Mapping, received: {type(bindings_)}"
            )

        if charm_url_ is not None and not isinstance(charm_url_, (bytes, str)):
            raise Exception(
                f"Expected charm_url_ to be a str, received: {type(charm_url_)}"
            )

        if connections_ is not None and not isinstance(
            connections_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected connections_ to be a Sequence, received: {type(connections_)}"
            )

        if endpoints_ is not None and not isinstance(endpoints_, (bytes, str, list)):
            raise Exception(
                f"Expected endpoints_ to be a Sequence, received: {type(endpoints_)}"
            )

        if offer_name_ is not None and not isinstance(offer_name_, (bytes, str)):
            raise Exception(
                f"Expected offer_name_ to be a str, received: {type(offer_name_)}"
            )

        if offer_url_ is not None and not isinstance(offer_url_, (bytes, str)):
            raise Exception(
                f"Expected offer_url_ to be a str, received: {type(offer_url_)}"
            )

        if offer_uuid_ is not None and not isinstance(offer_uuid_, (bytes, str)):
            raise Exception(
                f"Expected offer_uuid_ to be a str, received: {type(offer_uuid_)}"
            )

        if source_model_tag_ is not None and not isinstance(
            source_model_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected source_model_tag_ to be a str, received: {type(source_model_tag_)}"
            )

        if spaces_ is not None and not isinstance(spaces_, (bytes, str, list)):
            raise Exception(
                f"Expected spaces_ to be a Sequence, received: {type(spaces_)}"
            )

        if users_ is not None and not isinstance(users_, (bytes, str, list)):
            raise Exception(
                f"Expected users_ to be a Sequence, received: {type(users_)}"
            )

        self.applicationofferdetails = applicationofferdetails_
        self.application_description = application_description_
        self.application_name = application_name_
        self.bindings = bindings_
        self.charm_url = charm_url_
        self.connections = connections_
        self.endpoints = endpoints_
        self.offer_name = offer_name_
        self.offer_url = offer_url_
        self.offer_uuid = offer_uuid_
        self.source_model_tag = source_model_tag_
        self.spaces = spaces_
        self.users = users_
        self.unknown_fields = unknown_fields


class ApplicationOfferAdminDetailsV5(Type):
    _toSchema = {
        "application_description": "application-description",
        "application_name": "application-name",
        "applicationofferdetailsv5": "ApplicationOfferDetailsV5",
        "charm_url": "charm-url",
        "connections": "connections",
        "endpoints": "endpoints",
        "offer_name": "offer-name",
        "offer_url": "offer-url",
        "offer_uuid": "offer-uuid",
        "source_model_tag": "source-model-tag",
        "users": "users",
    }
    _toPy = {
        "ApplicationOfferDetailsV5": "applicationofferdetailsv5",
        "application-description": "application_description",
        "application-name": "application_name",
        "charm-url": "charm_url",
        "connections": "connections",
        "endpoints": "endpoints",
        "offer-name": "offer_name",
        "offer-url": "offer_url",
        "offer-uuid": "offer_uuid",
        "source-model-tag": "source_model_tag",
        "users": "users",
    }

    def __init__(
        self,
        applicationofferdetailsv5=None,
        application_description=None,
        application_name=None,
        charm_url=None,
        connections=None,
        endpoints=None,
        offer_name=None,
        offer_url=None,
        offer_uuid=None,
        source_model_tag=None,
        users=None,
        **unknown_fields,
    ):
        """applicationofferdetailsv5 : ApplicationOfferDetailsV5
        application_description : str
        application_name : str
        charm_url : str
        connections : typing.Sequence[~OfferConnection]
        endpoints : typing.Sequence[~RemoteEndpoint]
        offer_name : str
        offer_url : str
        offer_uuid : str
        source_model_tag : str
        users : typing.Sequence[~OfferUserDetails]
        """
        applicationofferdetailsv5_ = (
            ApplicationOfferDetailsV5.from_json(applicationofferdetailsv5)
            if applicationofferdetailsv5
            else None
        )
        application_description_ = application_description
        application_name_ = application_name
        charm_url_ = charm_url
        connections_ = [OfferConnection.from_json(o) for o in connections or []]
        endpoints_ = [RemoteEndpoint.from_json(o) for o in endpoints or []]
        offer_name_ = offer_name
        offer_url_ = offer_url
        offer_uuid_ = offer_uuid
        source_model_tag_ = source_model_tag
        users_ = [OfferUserDetails.from_json(o) for o in users or []]

        # Validate arguments against known Juju API types.
        if applicationofferdetailsv5_ is not None and not isinstance(
            applicationofferdetailsv5_, (dict, ApplicationOfferDetailsV5)
        ):
            raise Exception(
                f"Expected applicationofferdetailsv5_ to be a ApplicationOfferDetailsV5, received: {type(applicationofferdetailsv5_)}"
            )

        if application_description_ is not None and not isinstance(
            application_description_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_description_ to be a str, received: {type(application_description_)}"
            )

        if application_name_ is not None and not isinstance(
            application_name_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_name_ to be a str, received: {type(application_name_)}"
            )

        if charm_url_ is not None and not isinstance(charm_url_, (bytes, str)):
            raise Exception(
                f"Expected charm_url_ to be a str, received: {type(charm_url_)}"
            )

        if connections_ is not None and not isinstance(
            connections_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected connections_ to be a Sequence, received: {type(connections_)}"
            )

        if endpoints_ is not None and not isinstance(endpoints_, (bytes, str, list)):
            raise Exception(
                f"Expected endpoints_ to be a Sequence, received: {type(endpoints_)}"
            )

        if offer_name_ is not None and not isinstance(offer_name_, (bytes, str)):
            raise Exception(
                f"Expected offer_name_ to be a str, received: {type(offer_name_)}"
            )

        if offer_url_ is not None and not isinstance(offer_url_, (bytes, str)):
            raise Exception(
                f"Expected offer_url_ to be a str, received: {type(offer_url_)}"
            )

        if offer_uuid_ is not None and not isinstance(offer_uuid_, (bytes, str)):
            raise Exception(
                f"Expected offer_uuid_ to be a str, received: {type(offer_uuid_)}"
            )

        if source_model_tag_ is not None and not isinstance(
            source_model_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected source_model_tag_ to be a str, received: {type(source_model_tag_)}"
            )

        if users_ is not None and not isinstance(users_, (bytes, str, list)):
            raise Exception(
                f"Expected users_ to be a Sequence, received: {type(users_)}"
            )

        self.applicationofferdetailsv5 = applicationofferdetailsv5_
        self.application_description = application_description_
        self.application_name = application_name_
        self.charm_url = charm_url_
        self.connections = connections_
        self.endpoints = endpoints_
        self.offer_name = offer_name_
        self.offer_url = offer_url_
        self.offer_uuid = offer_uuid_
        self.source_model_tag = source_model_tag_
        self.users = users_
        self.unknown_fields = unknown_fields


class ApplicationOfferDetails(Type):
    _toSchema = {
        "application_description": "application-description",
        "bindings": "bindings",
        "endpoints": "endpoints",
        "offer_name": "offer-name",
        "offer_url": "offer-url",
        "offer_uuid": "offer-uuid",
        "source_model_tag": "source-model-tag",
        "spaces": "spaces",
        "users": "users",
    }
    _toPy = {
        "application-description": "application_description",
        "bindings": "bindings",
        "endpoints": "endpoints",
        "offer-name": "offer_name",
        "offer-url": "offer_url",
        "offer-uuid": "offer_uuid",
        "source-model-tag": "source_model_tag",
        "spaces": "spaces",
        "users": "users",
    }

    def __init__(
        self,
        application_description=None,
        bindings=None,
        endpoints=None,
        offer_name=None,
        offer_url=None,
        offer_uuid=None,
        source_model_tag=None,
        spaces=None,
        users=None,
        **unknown_fields,
    ):
        """application_description : str
        bindings : typing.Mapping[str, str]
        endpoints : typing.Sequence[~RemoteEndpoint]
        offer_name : str
        offer_url : str
        offer_uuid : str
        source_model_tag : str
        spaces : typing.Sequence[~RemoteSpace]
        users : typing.Sequence[~OfferUserDetails]
        """
        application_description_ = application_description
        bindings_ = bindings
        endpoints_ = [RemoteEndpoint.from_json(o) for o in endpoints or []]
        offer_name_ = offer_name
        offer_url_ = offer_url
        offer_uuid_ = offer_uuid
        source_model_tag_ = source_model_tag
        spaces_ = [RemoteSpace.from_json(o) for o in spaces or []]
        users_ = [OfferUserDetails.from_json(o) for o in users or []]

        # Validate arguments against known Juju API types.
        if application_description_ is not None and not isinstance(
            application_description_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_description_ to be a str, received: {type(application_description_)}"
            )

        if bindings_ is not None and not isinstance(bindings_, dict):
            raise Exception(
                f"Expected bindings_ to be a Mapping, received: {type(bindings_)}"
            )

        if endpoints_ is not None and not isinstance(endpoints_, (bytes, str, list)):
            raise Exception(
                f"Expected endpoints_ to be a Sequence, received: {type(endpoints_)}"
            )

        if offer_name_ is not None and not isinstance(offer_name_, (bytes, str)):
            raise Exception(
                f"Expected offer_name_ to be a str, received: {type(offer_name_)}"
            )

        if offer_url_ is not None and not isinstance(offer_url_, (bytes, str)):
            raise Exception(
                f"Expected offer_url_ to be a str, received: {type(offer_url_)}"
            )

        if offer_uuid_ is not None and not isinstance(offer_uuid_, (bytes, str)):
            raise Exception(
                f"Expected offer_uuid_ to be a str, received: {type(offer_uuid_)}"
            )

        if source_model_tag_ is not None and not isinstance(
            source_model_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected source_model_tag_ to be a str, received: {type(source_model_tag_)}"
            )

        if spaces_ is not None and not isinstance(spaces_, (bytes, str, list)):
            raise Exception(
                f"Expected spaces_ to be a Sequence, received: {type(spaces_)}"
            )

        if users_ is not None and not isinstance(users_, (bytes, str, list)):
            raise Exception(
                f"Expected users_ to be a Sequence, received: {type(users_)}"
            )

        self.application_description = application_description_
        self.bindings = bindings_
        self.endpoints = endpoints_
        self.offer_name = offer_name_
        self.offer_url = offer_url_
        self.offer_uuid = offer_uuid_
        self.source_model_tag = source_model_tag_
        self.spaces = spaces_
        self.users = users_
        self.unknown_fields = unknown_fields


class ApplicationOfferDetailsV5(Type):
    _toSchema = {
        "application_description": "application-description",
        "endpoints": "endpoints",
        "offer_name": "offer-name",
        "offer_url": "offer-url",
        "offer_uuid": "offer-uuid",
        "source_model_tag": "source-model-tag",
        "users": "users",
    }
    _toPy = {
        "application-description": "application_description",
        "endpoints": "endpoints",
        "offer-name": "offer_name",
        "offer-url": "offer_url",
        "offer-uuid": "offer_uuid",
        "source-model-tag": "source_model_tag",
        "users": "users",
    }

    def __init__(
        self,
        application_description=None,
        endpoints=None,
        offer_name=None,
        offer_url=None,
        offer_uuid=None,
        source_model_tag=None,
        users=None,
        **unknown_fields,
    ):
        """application_description : str
        endpoints : typing.Sequence[~RemoteEndpoint]
        offer_name : str
        offer_url : str
        offer_uuid : str
        source_model_tag : str
        users : typing.Sequence[~OfferUserDetails]
        """
        application_description_ = application_description
        endpoints_ = [RemoteEndpoint.from_json(o) for o in endpoints or []]
        offer_name_ = offer_name
        offer_url_ = offer_url
        offer_uuid_ = offer_uuid
        source_model_tag_ = source_model_tag
        users_ = [OfferUserDetails.from_json(o) for o in users or []]

        # Validate arguments against known Juju API types.
        if application_description_ is not None and not isinstance(
            application_description_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_description_ to be a str, received: {type(application_description_)}"
            )

        if endpoints_ is not None and not isinstance(endpoints_, (bytes, str, list)):
            raise Exception(
                f"Expected endpoints_ to be a Sequence, received: {type(endpoints_)}"
            )

        if offer_name_ is not None and not isinstance(offer_name_, (bytes, str)):
            raise Exception(
                f"Expected offer_name_ to be a str, received: {type(offer_name_)}"
            )

        if offer_url_ is not None and not isinstance(offer_url_, (bytes, str)):
            raise Exception(
                f"Expected offer_url_ to be a str, received: {type(offer_url_)}"
            )

        if offer_uuid_ is not None and not isinstance(offer_uuid_, (bytes, str)):
            raise Exception(
                f"Expected offer_uuid_ to be a str, received: {type(offer_uuid_)}"
            )

        if source_model_tag_ is not None and not isinstance(
            source_model_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected source_model_tag_ to be a str, received: {type(source_model_tag_)}"
            )

        if users_ is not None and not isinstance(users_, (bytes, str, list)):
            raise Exception(
                f"Expected users_ to be a Sequence, received: {type(users_)}"
            )

        self.application_description = application_description_
        self.endpoints = endpoints_
        self.offer_name = offer_name_
        self.offer_url = offer_url_
        self.offer_uuid = offer_uuid_
        self.source_model_tag = source_model_tag_
        self.users = users_
        self.unknown_fields = unknown_fields


class ApplicationOfferResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : ApplicationOfferAdminDetailsV5
        """
        error_ = Error.from_json(error) if error else None
        result_ = ApplicationOfferAdminDetailsV5.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(
            result_, (dict, ApplicationOfferAdminDetailsV5)
        ):
            raise Exception(
                f"Expected result_ to be a ApplicationOfferAdminDetailsV5, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class ApplicationOfferStatus(Type):
    _toSchema = {
        "active_connected_count": "active-connected-count",
        "application_name": "application-name",
        "charm": "charm",
        "endpoints": "endpoints",
        "err": "err",
        "offer_name": "offer-name",
        "total_connected_count": "total-connected-count",
    }
    _toPy = {
        "active-connected-count": "active_connected_count",
        "application-name": "application_name",
        "charm": "charm",
        "endpoints": "endpoints",
        "err": "err",
        "offer-name": "offer_name",
        "total-connected-count": "total_connected_count",
    }

    def __init__(
        self,
        active_connected_count=None,
        application_name=None,
        charm=None,
        endpoints=None,
        err=None,
        offer_name=None,
        total_connected_count=None,
        **unknown_fields,
    ):
        """active_connected_count : int
        application_name : str
        charm : str
        endpoints : typing.Mapping[str, ~RemoteEndpoint]
        err : Error
        offer_name : str
        total_connected_count : int
        """
        active_connected_count_ = active_connected_count
        application_name_ = application_name
        charm_ = charm
        endpoints_ = {
            k: RemoteEndpoint.from_json(v) for k, v in (endpoints or dict()).items()
        }
        err_ = Error.from_json(err) if err else None
        offer_name_ = offer_name
        total_connected_count_ = total_connected_count

        # Validate arguments against known Juju API types.
        if active_connected_count_ is not None and not isinstance(
            active_connected_count_, int
        ):
            raise Exception(
                f"Expected active_connected_count_ to be a int, received: {type(active_connected_count_)}"
            )

        if application_name_ is not None and not isinstance(
            application_name_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_name_ to be a str, received: {type(application_name_)}"
            )

        if charm_ is not None and not isinstance(charm_, (bytes, str)):
            raise Exception(f"Expected charm_ to be a str, received: {type(charm_)}")

        if endpoints_ is not None and not isinstance(endpoints_, dict):
            raise Exception(
                f"Expected endpoints_ to be a Mapping, received: {type(endpoints_)}"
            )

        if err_ is not None and not isinstance(err_, (dict, Error)):
            raise Exception(f"Expected err_ to be a Error, received: {type(err_)}")

        if offer_name_ is not None and not isinstance(offer_name_, (bytes, str)):
            raise Exception(
                f"Expected offer_name_ to be a str, received: {type(offer_name_)}"
            )

        if total_connected_count_ is not None and not isinstance(
            total_connected_count_, int
        ):
            raise Exception(
                f"Expected total_connected_count_ to be a int, received: {type(total_connected_count_)}"
            )

        self.active_connected_count = active_connected_count_
        self.application_name = application_name_
        self.charm = charm_
        self.endpoints = endpoints_
        self.err = err_
        self.offer_name = offer_name_
        self.total_connected_count = total_connected_count_
        self.unknown_fields = unknown_fields


class ApplicationOffersResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ApplicationOfferResult]"""
        results_ = [ApplicationOfferResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ApplicationResult(Type):
    _toSchema = {
        "base": "base",
        "channel": "channel",
        "charm": "charm",
        "constraints": "constraints",
        "endpoint_bindings": "endpoint-bindings",
        "exposed": "exposed",
        "exposed_endpoints": "exposed-endpoints",
        "life": "life",
        "principal": "principal",
        "remote": "remote",
        "tag": "tag",
    }
    _toPy = {
        "base": "base",
        "channel": "channel",
        "charm": "charm",
        "constraints": "constraints",
        "endpoint-bindings": "endpoint_bindings",
        "exposed": "exposed",
        "exposed-endpoints": "exposed_endpoints",
        "life": "life",
        "principal": "principal",
        "remote": "remote",
        "tag": "tag",
    }

    def __init__(
        self,
        base=None,
        channel=None,
        charm=None,
        constraints=None,
        endpoint_bindings=None,
        exposed=None,
        exposed_endpoints=None,
        life=None,
        principal=None,
        remote=None,
        tag=None,
        **unknown_fields,
    ):
        """Base : Base
        channel : str
        charm : str
        constraints : Value
        endpoint_bindings : typing.Mapping[str, str]
        exposed : bool
        exposed_endpoints : typing.Mapping[str, ~ExposedEndpoint]
        life : str
        principal : bool
        remote : bool
        tag : str
        """
        base_ = Base.from_json(base) if base else None
        channel_ = channel
        charm_ = charm
        constraints_ = Value.from_json(constraints) if constraints else None
        endpoint_bindings_ = endpoint_bindings
        exposed_ = exposed
        exposed_endpoints_ = {
            k: ExposedEndpoint.from_json(v)
            for k, v in (exposed_endpoints or dict()).items()
        }
        life_ = life
        principal_ = principal
        remote_ = remote
        tag_ = tag

        # Validate arguments against known Juju API types.
        if base_ is not None and not isinstance(base_, (dict, Base)):
            raise Exception(f"Expected base_ to be a Base, received: {type(base_)}")

        if channel_ is not None and not isinstance(channel_, (bytes, str)):
            raise Exception(
                f"Expected channel_ to be a str, received: {type(channel_)}"
            )

        if charm_ is not None and not isinstance(charm_, (bytes, str)):
            raise Exception(f"Expected charm_ to be a str, received: {type(charm_)}")

        if constraints_ is not None and not isinstance(constraints_, (dict, Value)):
            raise Exception(
                f"Expected constraints_ to be a Value, received: {type(constraints_)}"
            )

        if endpoint_bindings_ is not None and not isinstance(endpoint_bindings_, dict):
            raise Exception(
                f"Expected endpoint_bindings_ to be a Mapping, received: {type(endpoint_bindings_)}"
            )

        if exposed_ is not None and not isinstance(exposed_, bool):
            raise Exception(
                f"Expected exposed_ to be a bool, received: {type(exposed_)}"
            )

        if exposed_endpoints_ is not None and not isinstance(exposed_endpoints_, dict):
            raise Exception(
                f"Expected exposed_endpoints_ to be a Mapping, received: {type(exposed_endpoints_)}"
            )

        if life_ is not None and not isinstance(life_, (bytes, str)):
            raise Exception(f"Expected life_ to be a str, received: {type(life_)}")

        if principal_ is not None and not isinstance(principal_, bool):
            raise Exception(
                f"Expected principal_ to be a bool, received: {type(principal_)}"
            )

        if remote_ is not None and not isinstance(remote_, bool):
            raise Exception(f"Expected remote_ to be a bool, received: {type(remote_)}")

        if tag_ is not None and not isinstance(tag_, (bytes, str)):
            raise Exception(f"Expected tag_ to be a str, received: {type(tag_)}")

        self.base = base_
        self.channel = channel_
        self.charm = charm_
        self.constraints = constraints_
        self.endpoint_bindings = endpoint_bindings_
        self.exposed = exposed_
        self.exposed_endpoints = exposed_endpoints_
        self.life = life_
        self.principal = principal_
        self.remote = remote_
        self.tag = tag_
        self.unknown_fields = unknown_fields


class ApplicationSetCharm(Type):
    _toSchema = {
        "application": "application",
        "channel": "channel",
        "charm_origin": "charm-origin",
        "charm_url": "charm-url",
        "config_settings": "config-settings",
        "config_settings_yaml": "config-settings-yaml",
        "endpoint_bindings": "endpoint-bindings",
        "force": "force",
        "force_base": "force-base",
        "force_units": "force-units",
        "generation": "generation",
        "resource_ids": "resource-ids",
        "storage_constraints": "storage-constraints",
    }
    _toPy = {
        "application": "application",
        "channel": "channel",
        "charm-origin": "charm_origin",
        "charm-url": "charm_url",
        "config-settings": "config_settings",
        "config-settings-yaml": "config_settings_yaml",
        "endpoint-bindings": "endpoint_bindings",
        "force": "force",
        "force-base": "force_base",
        "force-units": "force_units",
        "generation": "generation",
        "resource-ids": "resource_ids",
        "storage-constraints": "storage_constraints",
    }

    def __init__(
        self,
        application=None,
        channel=None,
        charm_origin=None,
        charm_url=None,
        config_settings=None,
        config_settings_yaml=None,
        endpoint_bindings=None,
        force=None,
        force_base=None,
        force_units=None,
        generation=None,
        resource_ids=None,
        storage_constraints=None,
        **unknown_fields,
    ):
        """Application : str
        channel : str
        charm_origin : CharmOrigin
        charm_url : str
        config_settings : typing.Mapping[str, str]
        config_settings_yaml : str
        endpoint_bindings : typing.Mapping[str, str]
        force : bool
        force_base : bool
        force_units : bool
        generation : str
        resource_ids : typing.Mapping[str, str]
        storage_constraints : typing.Mapping[str, ~StorageConstraints]
        """
        application_ = application
        channel_ = channel
        charm_origin_ = CharmOrigin.from_json(charm_origin) if charm_origin else None
        charm_url_ = charm_url
        config_settings_ = config_settings
        config_settings_yaml_ = config_settings_yaml
        endpoint_bindings_ = endpoint_bindings
        force_ = force
        force_base_ = force_base
        force_units_ = force_units
        generation_ = generation
        resource_ids_ = resource_ids
        storage_constraints_ = {
            k: StorageConstraints.from_json(v)
            for k, v in (storage_constraints or dict()).items()
        }

        # Validate arguments against known Juju API types.
        if application_ is not None and not isinstance(application_, (bytes, str)):
            raise Exception(
                f"Expected application_ to be a str, received: {type(application_)}"
            )

        if channel_ is not None and not isinstance(channel_, (bytes, str)):
            raise Exception(
                f"Expected channel_ to be a str, received: {type(channel_)}"
            )

        if charm_origin_ is not None and not isinstance(
            charm_origin_, (dict, CharmOrigin)
        ):
            raise Exception(
                f"Expected charm_origin_ to be a CharmOrigin, received: {type(charm_origin_)}"
            )

        if charm_url_ is not None and not isinstance(charm_url_, (bytes, str)):
            raise Exception(
                f"Expected charm_url_ to be a str, received: {type(charm_url_)}"
            )

        if config_settings_ is not None and not isinstance(config_settings_, dict):
            raise Exception(
                f"Expected config_settings_ to be a Mapping, received: {type(config_settings_)}"
            )

        if config_settings_yaml_ is not None and not isinstance(
            config_settings_yaml_, (bytes, str)
        ):
            raise Exception(
                f"Expected config_settings_yaml_ to be a str, received: {type(config_settings_yaml_)}"
            )

        if endpoint_bindings_ is not None and not isinstance(endpoint_bindings_, dict):
            raise Exception(
                f"Expected endpoint_bindings_ to be a Mapping, received: {type(endpoint_bindings_)}"
            )

        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if force_base_ is not None and not isinstance(force_base_, bool):
            raise Exception(
                f"Expected force_base_ to be a bool, received: {type(force_base_)}"
            )

        if force_units_ is not None and not isinstance(force_units_, bool):
            raise Exception(
                f"Expected force_units_ to be a bool, received: {type(force_units_)}"
            )

        if generation_ is not None and not isinstance(generation_, (bytes, str)):
            raise Exception(
                f"Expected generation_ to be a str, received: {type(generation_)}"
            )

        if resource_ids_ is not None and not isinstance(resource_ids_, dict):
            raise Exception(
                f"Expected resource_ids_ to be a Mapping, received: {type(resource_ids_)}"
            )

        if storage_constraints_ is not None and not isinstance(
            storage_constraints_, dict
        ):
            raise Exception(
                f"Expected storage_constraints_ to be a Mapping, received: {type(storage_constraints_)}"
            )

        self.application = application_
        self.channel = channel_
        self.charm_origin = charm_origin_
        self.charm_url = charm_url_
        self.config_settings = config_settings_
        self.config_settings_yaml = config_settings_yaml_
        self.endpoint_bindings = endpoint_bindings_
        self.force = force_
        self.force_base = force_base_
        self.force_units = force_units_
        self.generation = generation_
        self.resource_ids = resource_ids_
        self.storage_constraints = storage_constraints_
        self.unknown_fields = unknown_fields


class ApplicationStatus(Type):
    _toSchema = {
        "base": "base",
        "can_upgrade_to": "can-upgrade-to",
        "charm": "charm",
        "charm_channel": "charm-channel",
        "charm_profile": "charm-profile",
        "charm_rev": "charm-rev",
        "charm_version": "charm-version",
        "endpoint_bindings": "endpoint-bindings",
        "err": "err",
        "exposed": "exposed",
        "exposed_endpoints": "exposed-endpoints",
        "int_": "int",
        "life": "life",
        "meter_statuses": "meter-statuses",
        "provider_id": "provider-id",
        "public_address": "public-address",
        "relations": "relations",
        "status": "status",
        "subordinate_to": "subordinate-to",
        "units": "units",
        "workload_version": "workload-version",
    }
    _toPy = {
        "base": "base",
        "can-upgrade-to": "can_upgrade_to",
        "charm": "charm",
        "charm-channel": "charm_channel",
        "charm-profile": "charm_profile",
        "charm-rev": "charm_rev",
        "charm-version": "charm_version",
        "endpoint-bindings": "endpoint_bindings",
        "err": "err",
        "exposed": "exposed",
        "exposed-endpoints": "exposed_endpoints",
        "int": "int_",
        "life": "life",
        "meter-statuses": "meter_statuses",
        "provider-id": "provider_id",
        "public-address": "public_address",
        "relations": "relations",
        "status": "status",
        "subordinate-to": "subordinate_to",
        "units": "units",
        "workload-version": "workload_version",
    }

    def __init__(
        self,
        base=None,
        can_upgrade_to=None,
        charm=None,
        charm_channel=None,
        charm_profile=None,
        charm_rev=None,
        charm_version=None,
        endpoint_bindings=None,
        err=None,
        exposed=None,
        exposed_endpoints=None,
        int_=None,
        life=None,
        meter_statuses=None,
        provider_id=None,
        public_address=None,
        relations=None,
        status=None,
        subordinate_to=None,
        units=None,
        workload_version=None,
        **unknown_fields,
    ):
        """Base : Base
        can_upgrade_to : str
        charm : str
        charm_channel : str
        charm_profile : str
        charm_rev : int
        charm_version : str
        endpoint_bindings : typing.Mapping[str, str]
        err : Error
        exposed : bool
        exposed_endpoints : typing.Mapping[str, ~ExposedEndpoint]
        int_ : int
        life : str
        meter_statuses : typing.Mapping[str, ~MeterStatus]
        provider_id : str
        public_address : str
        relations : typing.Mapping[str, typing.Sequence[str]]
        status : DetailedStatus
        subordinate_to : typing.Sequence[str]
        units : typing.Mapping[str, ~UnitStatus]
        workload_version : str
        """
        base_ = Base.from_json(base) if base else None
        can_upgrade_to_ = can_upgrade_to
        charm_ = charm
        charm_channel_ = charm_channel
        charm_profile_ = charm_profile
        charm_rev_ = charm_rev
        charm_version_ = charm_version
        endpoint_bindings_ = endpoint_bindings
        err_ = Error.from_json(err) if err else None
        exposed_ = exposed
        exposed_endpoints_ = {
            k: ExposedEndpoint.from_json(v)
            for k, v in (exposed_endpoints or dict()).items()
        }
        int__ = int_
        life_ = life
        meter_statuses_ = {
            k: MeterStatus.from_json(v) for k, v in (meter_statuses or dict()).items()
        }
        provider_id_ = provider_id
        public_address_ = public_address
        relations_ = relations
        status_ = DetailedStatus.from_json(status) if status else None
        subordinate_to_ = subordinate_to
        units_ = {k: UnitStatus.from_json(v) for k, v in (units or dict()).items()}
        workload_version_ = workload_version

        # Validate arguments against known Juju API types.
        if base_ is not None and not isinstance(base_, (dict, Base)):
            raise Exception(f"Expected base_ to be a Base, received: {type(base_)}")

        if can_upgrade_to_ is not None and not isinstance(
            can_upgrade_to_, (bytes, str)
        ):
            raise Exception(
                f"Expected can_upgrade_to_ to be a str, received: {type(can_upgrade_to_)}"
            )

        if charm_ is not None and not isinstance(charm_, (bytes, str)):
            raise Exception(f"Expected charm_ to be a str, received: {type(charm_)}")

        if charm_channel_ is not None and not isinstance(charm_channel_, (bytes, str)):
            raise Exception(
                f"Expected charm_channel_ to be a str, received: {type(charm_channel_)}"
            )

        if charm_profile_ is not None and not isinstance(charm_profile_, (bytes, str)):
            raise Exception(
                f"Expected charm_profile_ to be a str, received: {type(charm_profile_)}"
            )

        if charm_rev_ is not None and not isinstance(charm_rev_, int):
            raise Exception(
                f"Expected charm_rev_ to be a int, received: {type(charm_rev_)}"
            )

        if charm_version_ is not None and not isinstance(charm_version_, (bytes, str)):
            raise Exception(
                f"Expected charm_version_ to be a str, received: {type(charm_version_)}"
            )

        if endpoint_bindings_ is not None and not isinstance(endpoint_bindings_, dict):
            raise Exception(
                f"Expected endpoint_bindings_ to be a Mapping, received: {type(endpoint_bindings_)}"
            )

        if err_ is not None and not isinstance(err_, (dict, Error)):
            raise Exception(f"Expected err_ to be a Error, received: {type(err_)}")

        if exposed_ is not None and not isinstance(exposed_, bool):
            raise Exception(
                f"Expected exposed_ to be a bool, received: {type(exposed_)}"
            )

        if exposed_endpoints_ is not None and not isinstance(exposed_endpoints_, dict):
            raise Exception(
                f"Expected exposed_endpoints_ to be a Mapping, received: {type(exposed_endpoints_)}"
            )

        if int__ is not None and not isinstance(int__, int):
            raise Exception(f"Expected int__ to be a int, received: {type(int__)}")

        if life_ is not None and not isinstance(life_, (bytes, str)):
            raise Exception(f"Expected life_ to be a str, received: {type(life_)}")

        if meter_statuses_ is not None and not isinstance(meter_statuses_, dict):
            raise Exception(
                f"Expected meter_statuses_ to be a Mapping, received: {type(meter_statuses_)}"
            )

        if provider_id_ is not None and not isinstance(provider_id_, (bytes, str)):
            raise Exception(
                f"Expected provider_id_ to be a str, received: {type(provider_id_)}"
            )

        if public_address_ is not None and not isinstance(
            public_address_, (bytes, str)
        ):
            raise Exception(
                f"Expected public_address_ to be a str, received: {type(public_address_)}"
            )

        if relations_ is not None and not isinstance(relations_, dict):
            raise Exception(
                f"Expected relations_ to be a Mapping, received: {type(relations_)}"
            )

        if status_ is not None and not isinstance(status_, (dict, DetailedStatus)):
            raise Exception(
                f"Expected status_ to be a DetailedStatus, received: {type(status_)}"
            )

        if subordinate_to_ is not None and not isinstance(
            subordinate_to_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected subordinate_to_ to be a Sequence, received: {type(subordinate_to_)}"
            )

        if units_ is not None and not isinstance(units_, dict):
            raise Exception(
                f"Expected units_ to be a Mapping, received: {type(units_)}"
            )

        if workload_version_ is not None and not isinstance(
            workload_version_, (bytes, str)
        ):
            raise Exception(
                f"Expected workload_version_ to be a str, received: {type(workload_version_)}"
            )

        self.base = base_
        self.can_upgrade_to = can_upgrade_to_
        self.charm = charm_
        self.charm_channel = charm_channel_
        self.charm_profile = charm_profile_
        self.charm_rev = charm_rev_
        self.charm_version = charm_version_
        self.endpoint_bindings = endpoint_bindings_
        self.err = err_
        self.exposed = exposed_
        self.exposed_endpoints = exposed_endpoints_
        self.int_ = int__
        self.life = life_
        self.meter_statuses = meter_statuses_
        self.provider_id = provider_id_
        self.public_address = public_address_
        self.relations = relations_
        self.status = status_
        self.subordinate_to = subordinate_to_
        self.units = units_
        self.workload_version = workload_version_
        self.unknown_fields = unknown_fields


class ApplicationUnexpose(Type):
    _toSchema = {"application": "application", "exposed_endpoints": "exposed-endpoints"}
    _toPy = {"application": "application", "exposed-endpoints": "exposed_endpoints"}

    def __init__(self, application=None, exposed_endpoints=None, **unknown_fields):
        """Application : str
        exposed_endpoints : typing.Sequence[str]
        """
        application_ = application
        exposed_endpoints_ = exposed_endpoints

        # Validate arguments against known Juju API types.
        if application_ is not None and not isinstance(application_, (bytes, str)):
            raise Exception(
                f"Expected application_ to be a str, received: {type(application_)}"
            )

        if exposed_endpoints_ is not None and not isinstance(
            exposed_endpoints_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected exposed_endpoints_ to be a Sequence, received: {type(exposed_endpoints_)}"
            )

        self.application = application_
        self.exposed_endpoints = exposed_endpoints_
        self.unknown_fields = unknown_fields


class ApplicationUnset(Type):
    _toSchema = {"application": "application", "branch": "branch", "options": "options"}
    _toPy = {"application": "application", "branch": "branch", "options": "options"}

    def __init__(self, application=None, branch=None, options=None, **unknown_fields):
        """Application : str
        branch : str
        options : typing.Sequence[str]
        """
        application_ = application
        branch_ = branch
        options_ = options

        # Validate arguments against known Juju API types.
        if application_ is not None and not isinstance(application_, (bytes, str)):
            raise Exception(
                f"Expected application_ to be a str, received: {type(application_)}"
            )

        if branch_ is not None and not isinstance(branch_, (bytes, str)):
            raise Exception(f"Expected branch_ to be a str, received: {type(branch_)}")

        if options_ is not None and not isinstance(options_, (bytes, str, list)):
            raise Exception(
                f"Expected options_ to be a Sequence, received: {type(options_)}"
            )

        self.application = application_
        self.branch = branch_
        self.options = options_
        self.unknown_fields = unknown_fields


class ApplicationsCharmActionsResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ApplicationCharmActionsResult]"""
        results_ = [ApplicationCharmActionsResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ApplicationsDeploy(Type):
    _toSchema = {"applications": "applications"}
    _toPy = {"applications": "applications"}

    def __init__(self, applications=None, **unknown_fields):
        """Applications : typing.Sequence[~ApplicationDeploy]"""
        applications_ = [ApplicationDeploy.from_json(o) for o in applications or []]

        # Validate arguments against known Juju API types.
        if applications_ is not None and not isinstance(
            applications_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected applications_ to be a Sequence, received: {type(applications_)}"
            )

        self.applications = applications_
        self.unknown_fields = unknown_fields


class AuthUserInfo(Type):
    _toSchema = {
        "controller_access": "controller-access",
        "credentials": "credentials",
        "display_name": "display-name",
        "identity": "identity",
        "last_connection": "last-connection",
        "model_access": "model-access",
    }
    _toPy = {
        "controller-access": "controller_access",
        "credentials": "credentials",
        "display-name": "display_name",
        "identity": "identity",
        "last-connection": "last_connection",
        "model-access": "model_access",
    }

    def __init__(
        self,
        controller_access=None,
        credentials=None,
        display_name=None,
        identity=None,
        last_connection=None,
        model_access=None,
        **unknown_fields,
    ):
        """controller_access : str
        credentials : str
        display_name : str
        identity : str
        last_connection : str
        model_access : str
        """
        controller_access_ = controller_access
        credentials_ = credentials
        display_name_ = display_name
        identity_ = identity
        last_connection_ = last_connection
        model_access_ = model_access

        # Validate arguments against known Juju API types.
        if controller_access_ is not None and not isinstance(
            controller_access_, (bytes, str)
        ):
            raise Exception(
                f"Expected controller_access_ to be a str, received: {type(controller_access_)}"
            )

        if credentials_ is not None and not isinstance(credentials_, (bytes, str)):
            raise Exception(
                f"Expected credentials_ to be a str, received: {type(credentials_)}"
            )

        if display_name_ is not None and not isinstance(display_name_, (bytes, str)):
            raise Exception(
                f"Expected display_name_ to be a str, received: {type(display_name_)}"
            )

        if identity_ is not None and not isinstance(identity_, (bytes, str)):
            raise Exception(
                f"Expected identity_ to be a str, received: {type(identity_)}"
            )

        if last_connection_ is not None and not isinstance(
            last_connection_, (bytes, str)
        ):
            raise Exception(
                f"Expected last_connection_ to be a str, received: {type(last_connection_)}"
            )

        if model_access_ is not None and not isinstance(model_access_, (bytes, str)):
            raise Exception(
                f"Expected model_access_ to be a str, received: {type(model_access_)}"
            )

        self.controller_access = controller_access_
        self.credentials = credentials_
        self.display_name = display_name_
        self.identity = identity_
        self.last_connection = last_connection_
        self.model_access = model_access_
        self.unknown_fields = unknown_fields


class BackupsCreateArgs(Type):
    _toSchema = {"no_download": "no-download", "notes": "notes"}
    _toPy = {"no-download": "no_download", "notes": "notes"}

    def __init__(self, no_download=None, notes=None, **unknown_fields):
        """no_download : bool
        notes : str
        """
        no_download_ = no_download
        notes_ = notes

        # Validate arguments against known Juju API types.
        if no_download_ is not None and not isinstance(no_download_, bool):
            raise Exception(
                f"Expected no_download_ to be a bool, received: {type(no_download_)}"
            )

        if notes_ is not None and not isinstance(notes_, (bytes, str)):
            raise Exception(f"Expected notes_ to be a str, received: {type(notes_)}")

        self.no_download = no_download_
        self.notes = notes_
        self.unknown_fields = unknown_fields


class BackupsMetadataResult(Type):
    _toSchema = {
        "base": "base",
        "checksum": "checksum",
        "checksum_format": "checksum-format",
        "controller_machine_id": "controller-machine-id",
        "controller_machine_inst_id": "controller-machine-inst-id",
        "controller_uuid": "controller-uuid",
        "filename": "filename",
        "finished": "finished",
        "format_version": "format-version",
        "ha_nodes": "ha-nodes",
        "hostname": "hostname",
        "id_": "id",
        "machine": "machine",
        "model": "model",
        "notes": "notes",
        "size": "size",
        "started": "started",
        "stored": "stored",
        "version": "version",
    }
    _toPy = {
        "base": "base",
        "checksum": "checksum",
        "checksum-format": "checksum_format",
        "controller-machine-id": "controller_machine_id",
        "controller-machine-inst-id": "controller_machine_inst_id",
        "controller-uuid": "controller_uuid",
        "filename": "filename",
        "finished": "finished",
        "format-version": "format_version",
        "ha-nodes": "ha_nodes",
        "hostname": "hostname",
        "id": "id_",
        "machine": "machine",
        "model": "model",
        "notes": "notes",
        "size": "size",
        "started": "started",
        "stored": "stored",
        "version": "version",
    }

    def __init__(
        self,
        base=None,
        checksum=None,
        checksum_format=None,
        controller_machine_id=None,
        controller_machine_inst_id=None,
        controller_uuid=None,
        filename=None,
        finished=None,
        format_version=None,
        ha_nodes=None,
        hostname=None,
        id_=None,
        machine=None,
        model=None,
        notes=None,
        size=None,
        started=None,
        stored=None,
        version=None,
        **unknown_fields,
    ):
        """Base : str
        checksum : str
        checksum_format : str
        controller_machine_id : str
        controller_machine_inst_id : str
        controller_uuid : str
        filename : str
        finished : str
        format_version : int
        ha_nodes : int
        hostname : str
        id_ : str
        machine : str
        model : str
        notes : str
        size : int
        started : str
        stored : str
        version : Number
        """
        base_ = base
        checksum_ = checksum
        checksum_format_ = checksum_format
        controller_machine_id_ = controller_machine_id
        controller_machine_inst_id_ = controller_machine_inst_id
        controller_uuid_ = controller_uuid
        filename_ = filename
        finished_ = finished
        format_version_ = format_version
        ha_nodes_ = ha_nodes
        hostname_ = hostname
        id__ = id_
        machine_ = machine
        model_ = model
        notes_ = notes
        size_ = size
        started_ = started
        stored_ = stored
        version_ = Number.from_json(version) if version else None

        # Validate arguments against known Juju API types.
        if base_ is not None and not isinstance(base_, (bytes, str)):
            raise Exception(f"Expected base_ to be a str, received: {type(base_)}")

        if checksum_ is not None and not isinstance(checksum_, (bytes, str)):
            raise Exception(
                f"Expected checksum_ to be a str, received: {type(checksum_)}"
            )

        if checksum_format_ is not None and not isinstance(
            checksum_format_, (bytes, str)
        ):
            raise Exception(
                f"Expected checksum_format_ to be a str, received: {type(checksum_format_)}"
            )

        if controller_machine_id_ is not None and not isinstance(
            controller_machine_id_, (bytes, str)
        ):
            raise Exception(
                f"Expected controller_machine_id_ to be a str, received: {type(controller_machine_id_)}"
            )

        if controller_machine_inst_id_ is not None and not isinstance(
            controller_machine_inst_id_, (bytes, str)
        ):
            raise Exception(
                f"Expected controller_machine_inst_id_ to be a str, received: {type(controller_machine_inst_id_)}"
            )

        if controller_uuid_ is not None and not isinstance(
            controller_uuid_, (bytes, str)
        ):
            raise Exception(
                f"Expected controller_uuid_ to be a str, received: {type(controller_uuid_)}"
            )

        if filename_ is not None and not isinstance(filename_, (bytes, str)):
            raise Exception(
                f"Expected filename_ to be a str, received: {type(filename_)}"
            )

        if finished_ is not None and not isinstance(finished_, (bytes, str)):
            raise Exception(
                f"Expected finished_ to be a str, received: {type(finished_)}"
            )

        if format_version_ is not None and not isinstance(format_version_, int):
            raise Exception(
                f"Expected format_version_ to be a int, received: {type(format_version_)}"
            )

        if ha_nodes_ is not None and not isinstance(ha_nodes_, int):
            raise Exception(
                f"Expected ha_nodes_ to be a int, received: {type(ha_nodes_)}"
            )

        if hostname_ is not None and not isinstance(hostname_, (bytes, str)):
            raise Exception(
                f"Expected hostname_ to be a str, received: {type(hostname_)}"
            )

        if id__ is not None and not isinstance(id__, (bytes, str)):
            raise Exception(f"Expected id__ to be a str, received: {type(id__)}")

        if machine_ is not None and not isinstance(machine_, (bytes, str)):
            raise Exception(
                f"Expected machine_ to be a str, received: {type(machine_)}"
            )

        if model_ is not None and not isinstance(model_, (bytes, str)):
            raise Exception(f"Expected model_ to be a str, received: {type(model_)}")

        if notes_ is not None and not isinstance(notes_, (bytes, str)):
            raise Exception(f"Expected notes_ to be a str, received: {type(notes_)}")

        if size_ is not None and not isinstance(size_, int):
            raise Exception(f"Expected size_ to be a int, received: {type(size_)}")

        if started_ is not None and not isinstance(started_, (bytes, str)):
            raise Exception(
                f"Expected started_ to be a str, received: {type(started_)}"
            )

        if stored_ is not None and not isinstance(stored_, (bytes, str)):
            raise Exception(f"Expected stored_ to be a str, received: {type(stored_)}")

        if version_ is not None and not isinstance(version_, (dict, Number)):
            raise Exception(
                f"Expected version_ to be a Number, received: {type(version_)}"
            )

        self.base = base_
        self.checksum = checksum_
        self.checksum_format = checksum_format_
        self.controller_machine_id = controller_machine_id_
        self.controller_machine_inst_id = controller_machine_inst_id_
        self.controller_uuid = controller_uuid_
        self.filename = filename_
        self.finished = finished_
        self.format_version = format_version_
        self.ha_nodes = ha_nodes_
        self.hostname = hostname_
        self.id_ = id__
        self.machine = machine_
        self.model = model_
        self.notes = notes_
        self.size = size_
        self.started = started_
        self.stored = stored_
        self.version = version_
        self.unknown_fields = unknown_fields


class Base(Type):
    _toSchema = {"channel": "channel", "name": "name"}
    _toPy = {"channel": "channel", "name": "name"}

    def __init__(self, channel=None, name=None, **unknown_fields):
        """Channel : str
        name : str
        """
        channel_ = channel
        name_ = name

        # Validate arguments against known Juju API types.
        if channel_ is not None and not isinstance(channel_, (bytes, str)):
            raise Exception(
                f"Expected channel_ to be a str, received: {type(channel_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        self.channel = channel_
        self.name = name_
        self.unknown_fields = unknown_fields


class Binary(Type):
    _toSchema = {
        "arch": "Arch",
        "build": "Build",
        "major": "Major",
        "minor": "Minor",
        "number": "Number",
        "patch": "Patch",
        "release": "Release",
        "tag": "Tag",
    }
    _toPy = {
        "Arch": "arch",
        "Build": "build",
        "Major": "major",
        "Minor": "minor",
        "Number": "number",
        "Patch": "patch",
        "Release": "release",
        "Tag": "tag",
    }

    def __init__(
        self,
        arch=None,
        build=None,
        major=None,
        minor=None,
        number=None,
        patch=None,
        release=None,
        tag=None,
        **unknown_fields,
    ):
        """Arch : str
        build : int
        major : int
        minor : int
        number : Number
        patch : int
        release : str
        tag : str
        """
        arch_ = arch
        build_ = build
        major_ = major
        minor_ = minor
        number_ = Number.from_json(number) if number else None
        patch_ = patch
        release_ = release
        tag_ = tag

        # Validate arguments against known Juju API types.
        if arch_ is not None and not isinstance(arch_, (bytes, str)):
            raise Exception(f"Expected arch_ to be a str, received: {type(arch_)}")

        if build_ is not None and not isinstance(build_, int):
            raise Exception(f"Expected build_ to be a int, received: {type(build_)}")

        if major_ is not None and not isinstance(major_, int):
            raise Exception(f"Expected major_ to be a int, received: {type(major_)}")

        if minor_ is not None and not isinstance(minor_, int):
            raise Exception(f"Expected minor_ to be a int, received: {type(minor_)}")

        if number_ is not None and not isinstance(number_, (dict, Number)):
            raise Exception(
                f"Expected number_ to be a Number, received: {type(number_)}"
            )

        if patch_ is not None and not isinstance(patch_, int):
            raise Exception(f"Expected patch_ to be a int, received: {type(patch_)}")

        if release_ is not None and not isinstance(release_, (bytes, str)):
            raise Exception(
                f"Expected release_ to be a str, received: {type(release_)}"
            )

        if tag_ is not None and not isinstance(tag_, (bytes, str)):
            raise Exception(f"Expected tag_ to be a str, received: {type(tag_)}")

        self.arch = arch_
        self.build = build_
        self.major = major_
        self.minor = minor_
        self.number = number_
        self.patch = patch_
        self.release = release_
        self.tag = tag_
        self.unknown_fields = unknown_fields


class Block(Type):
    _toSchema = {"id_": "id", "message": "message", "tag": "tag", "type_": "type"}
    _toPy = {"id": "id_", "message": "message", "tag": "tag", "type": "type_"}

    def __init__(self, id_=None, message=None, tag=None, type_=None, **unknown_fields):
        """id_ : str
        message : str
        tag : str
        type_ : str
        """
        id__ = id_
        message_ = message
        tag_ = tag
        type__ = type_

        # Validate arguments against known Juju API types.
        if id__ is not None and not isinstance(id__, (bytes, str)):
            raise Exception(f"Expected id__ to be a str, received: {type(id__)}")

        if message_ is not None and not isinstance(message_, (bytes, str)):
            raise Exception(
                f"Expected message_ to be a str, received: {type(message_)}"
            )

        if tag_ is not None and not isinstance(tag_, (bytes, str)):
            raise Exception(f"Expected tag_ to be a str, received: {type(tag_)}")

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        self.id_ = id__
        self.message = message_
        self.tag = tag_
        self.type_ = type__
        self.unknown_fields = unknown_fields


class BlockResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : Block
        """
        error_ = Error.from_json(error) if error else None
        result_ = Block.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (dict, Block)):
            raise Exception(
                f"Expected result_ to be a Block, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class BlockResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~BlockResult]"""
        results_ = [BlockResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class BlockSwitchParams(Type):
    _toSchema = {"message": "message", "type_": "type"}
    _toPy = {"message": "message", "type": "type_"}

    def __init__(self, message=None, type_=None, **unknown_fields):
        """Message : str
        type_ : str
        """
        message_ = message
        type__ = type_

        # Validate arguments against known Juju API types.
        if message_ is not None and not isinstance(message_, (bytes, str)):
            raise Exception(
                f"Expected message_ to be a str, received: {type(message_)}"
            )

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        self.message = message_
        self.type_ = type__
        self.unknown_fields = unknown_fields


class BoolResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : bool
        """
        error_ = Error.from_json(error) if error else None
        result_ = result

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, bool):
            raise Exception(f"Expected result_ to be a bool, received: {type(result_)}")

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class BranchArg(Type):
    _toSchema = {"branch": "branch"}
    _toPy = {"branch": "branch"}

    def __init__(self, branch=None, **unknown_fields):
        """Branch : str"""
        branch_ = branch

        # Validate arguments against known Juju API types.
        if branch_ is not None and not isinstance(branch_, (bytes, str)):
            raise Exception(f"Expected branch_ to be a str, received: {type(branch_)}")

        self.branch = branch_
        self.unknown_fields = unknown_fields


class BranchInfoArgs(Type):
    _toSchema = {"branches": "branches", "detailed": "detailed"}
    _toPy = {"branches": "branches", "detailed": "detailed"}

    def __init__(self, branches=None, detailed=None, **unknown_fields):
        """Branches : typing.Sequence[str]
        detailed : bool
        """
        branches_ = branches
        detailed_ = detailed

        # Validate arguments against known Juju API types.
        if branches_ is not None and not isinstance(branches_, (bytes, str, list)):
            raise Exception(
                f"Expected branches_ to be a Sequence, received: {type(branches_)}"
            )

        if detailed_ is not None and not isinstance(detailed_, bool):
            raise Exception(
                f"Expected detailed_ to be a bool, received: {type(detailed_)}"
            )

        self.branches = branches_
        self.detailed = detailed_
        self.unknown_fields = unknown_fields


class BranchResults(Type):
    _toSchema = {"error": "error", "generations": "generations"}
    _toPy = {"error": "error", "generations": "generations"}

    def __init__(self, error=None, generations=None, **unknown_fields):
        """Error : Error
        generations : typing.Sequence[~Generation]
        """
        error_ = Error.from_json(error) if error else None
        generations_ = [Generation.from_json(o) for o in generations or []]

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if generations_ is not None and not isinstance(
            generations_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected generations_ to be a Sequence, received: {type(generations_)}"
            )

        self.error = error_
        self.generations = generations_
        self.unknown_fields = unknown_fields


class BranchStatus(Type):
    _toSchema = {
        "assigned_units": "assigned-units",
        "created": "created",
        "created_by": "created-by",
    }
    _toPy = {
        "assigned-units": "assigned_units",
        "created": "created",
        "created-by": "created_by",
    }

    def __init__(
        self, assigned_units=None, created=None, created_by=None, **unknown_fields
    ):
        """assigned_units : typing.Mapping[str, typing.Sequence[str]]
        created : int
        created_by : str
        """
        assigned_units_ = assigned_units
        created_ = created
        created_by_ = created_by

        # Validate arguments against known Juju API types.
        if assigned_units_ is not None and not isinstance(assigned_units_, dict):
            raise Exception(
                f"Expected assigned_units_ to be a Mapping, received: {type(assigned_units_)}"
            )

        if created_ is not None and not isinstance(created_, int):
            raise Exception(
                f"Expected created_ to be a int, received: {type(created_)}"
            )

        if created_by_ is not None and not isinstance(created_by_, (bytes, str)):
            raise Exception(
                f"Expected created_by_ to be a str, received: {type(created_by_)}"
            )

        self.assigned_units = assigned_units_
        self.created = created_
        self.created_by = created_by_
        self.unknown_fields = unknown_fields


class BranchTrackArg(Type):
    _toSchema = {"branch": "branch", "entities": "entities", "num_units": "num-units"}
    _toPy = {"branch": "branch", "entities": "entities", "num-units": "num_units"}

    def __init__(self, branch=None, entities=None, num_units=None, **unknown_fields):
        """Branch : str
        entities : typing.Sequence[~Entity]
        num_units : int
        """
        branch_ = branch
        entities_ = [Entity.from_json(o) for o in entities or []]
        num_units_ = num_units

        # Validate arguments against known Juju API types.
        if branch_ is not None and not isinstance(branch_, (bytes, str)):
            raise Exception(f"Expected branch_ to be a str, received: {type(branch_)}")

        if entities_ is not None and not isinstance(entities_, (bytes, str, list)):
            raise Exception(
                f"Expected entities_ to be a Sequence, received: {type(entities_)}"
            )

        if num_units_ is not None and not isinstance(num_units_, int):
            raise Exception(
                f"Expected num_units_ to be a int, received: {type(num_units_)}"
            )

        self.branch = branch_
        self.entities = entities_
        self.num_units = num_units_
        self.unknown_fields = unknown_fields


class BulkImportStorageParams(Type):
    _toSchema = {"storage": "storage"}
    _toPy = {"storage": "storage"}

    def __init__(self, storage=None, **unknown_fields):
        """Storage : typing.Sequence[~ImportStorageParams]"""
        storage_ = [ImportStorageParams.from_json(o) for o in storage or []]

        # Validate arguments against known Juju API types.
        if storage_ is not None and not isinstance(storage_, (bytes, str, list)):
            raise Exception(
                f"Expected storage_ to be a Sequence, received: {type(storage_)}"
            )

        self.storage = storage_
        self.unknown_fields = unknown_fields


class BundleChange(Type):
    _toSchema = {
        "args": "args",
        "id_": "id",
        "method": "method",
        "requires": "requires",
    }
    _toPy = {"args": "args", "id": "id_", "method": "method", "requires": "requires"}

    def __init__(
        self, args=None, id_=None, method=None, requires=None, **unknown_fields
    ):
        """Args : typing.Sequence[typing.Any]
        id_ : str
        method : str
        requires : typing.Sequence[str]
        """
        args_ = args
        id__ = id_
        method_ = method
        requires_ = requires

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, (bytes, str, list)):
            raise Exception(f"Expected args_ to be a Sequence, received: {type(args_)}")

        if id__ is not None and not isinstance(id__, (bytes, str)):
            raise Exception(f"Expected id__ to be a str, received: {type(id__)}")

        if method_ is not None and not isinstance(method_, (bytes, str)):
            raise Exception(f"Expected method_ to be a str, received: {type(method_)}")

        if requires_ is not None and not isinstance(requires_, (bytes, str, list)):
            raise Exception(
                f"Expected requires_ to be a Sequence, received: {type(requires_)}"
            )

        self.args = args_
        self.id_ = id__
        self.method = method_
        self.requires = requires_
        self.unknown_fields = unknown_fields


class BundleChangesMapArgs(Type):
    _toSchema = {
        "args": "args",
        "id_": "id",
        "method": "method",
        "requires": "requires",
    }
    _toPy = {"args": "args", "id": "id_", "method": "method", "requires": "requires"}

    def __init__(
        self, args=None, id_=None, method=None, requires=None, **unknown_fields
    ):
        """Args : typing.Mapping[str, typing.Any]
        id_ : str
        method : str
        requires : typing.Sequence[str]
        """
        args_ = args
        id__ = id_
        method_ = method
        requires_ = requires

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, dict):
            raise Exception(f"Expected args_ to be a Mapping, received: {type(args_)}")

        if id__ is not None and not isinstance(id__, (bytes, str)):
            raise Exception(f"Expected id__ to be a str, received: {type(id__)}")

        if method_ is not None and not isinstance(method_, (bytes, str)):
            raise Exception(f"Expected method_ to be a str, received: {type(method_)}")

        if requires_ is not None and not isinstance(requires_, (bytes, str, list)):
            raise Exception(
                f"Expected requires_ to be a Sequence, received: {type(requires_)}"
            )

        self.args = args_
        self.id_ = id__
        self.method = method_
        self.requires = requires_
        self.unknown_fields = unknown_fields


class BundleChangesMapArgsResults(Type):
    _toSchema = {"changes": "changes", "errors": "errors"}
    _toPy = {"changes": "changes", "errors": "errors"}

    def __init__(self, changes=None, errors=None, **unknown_fields):
        """Changes : typing.Sequence[~BundleChangesMapArgs]
        errors : typing.Sequence[str]
        """
        changes_ = [BundleChangesMapArgs.from_json(o) for o in changes or []]
        errors_ = errors

        # Validate arguments against known Juju API types.
        if changes_ is not None and not isinstance(changes_, (bytes, str, list)):
            raise Exception(
                f"Expected changes_ to be a Sequence, received: {type(changes_)}"
            )

        if errors_ is not None and not isinstance(errors_, (bytes, str, list)):
            raise Exception(
                f"Expected errors_ to be a Sequence, received: {type(errors_)}"
            )

        self.changes = changes_
        self.errors = errors_
        self.unknown_fields = unknown_fields


class BundleChangesParams(Type):
    _toSchema = {"bundleurl": "bundleURL", "yaml": "yaml"}
    _toPy = {"bundleURL": "bundleurl", "yaml": "yaml"}

    def __init__(self, bundleurl=None, yaml=None, **unknown_fields):
        """Bundleurl : str
        yaml : str
        """
        bundleurl_ = bundleurl
        yaml_ = yaml

        # Validate arguments against known Juju API types.
        if bundleurl_ is not None and not isinstance(bundleurl_, (bytes, str)):
            raise Exception(
                f"Expected bundleurl_ to be a str, received: {type(bundleurl_)}"
            )

        if yaml_ is not None and not isinstance(yaml_, (bytes, str)):
            raise Exception(f"Expected yaml_ to be a str, received: {type(yaml_)}")

        self.bundleurl = bundleurl_
        self.yaml = yaml_
        self.unknown_fields = unknown_fields


class BundleChangesResults(Type):
    _toSchema = {"changes": "changes", "errors": "errors"}
    _toPy = {"changes": "changes", "errors": "errors"}

    def __init__(self, changes=None, errors=None, **unknown_fields):
        """Changes : typing.Sequence[~BundleChange]
        errors : typing.Sequence[str]
        """
        changes_ = [BundleChange.from_json(o) for o in changes or []]
        errors_ = errors

        # Validate arguments against known Juju API types.
        if changes_ is not None and not isinstance(changes_, (bytes, str, list)):
            raise Exception(
                f"Expected changes_ to be a Sequence, received: {type(changes_)}"
            )

        if errors_ is not None and not isinstance(errors_, (bytes, str, list)):
            raise Exception(
                f"Expected errors_ to be a Sequence, received: {type(errors_)}"
            )

        self.changes = changes_
        self.errors = errors_
        self.unknown_fields = unknown_fields


class CIDRParams(Type):
    _toSchema = {"cidrs": "cidrs"}
    _toPy = {"cidrs": "cidrs"}

    def __init__(self, cidrs=None, **unknown_fields):
        """Cidrs : typing.Sequence[str]"""
        cidrs_ = cidrs

        # Validate arguments against known Juju API types.
        if cidrs_ is not None and not isinstance(cidrs_, (bytes, str, list)):
            raise Exception(
                f"Expected cidrs_ to be a Sequence, received: {type(cidrs_)}"
            )

        self.cidrs = cidrs_
        self.unknown_fields = unknown_fields


class ChangeModelCredentialParams(Type):
    _toSchema = {"credential_tag": "credential-tag", "model_tag": "model-tag"}
    _toPy = {"credential-tag": "credential_tag", "model-tag": "model_tag"}

    def __init__(self, credential_tag=None, model_tag=None, **unknown_fields):
        """credential_tag : str
        model_tag : str
        """
        credential_tag_ = credential_tag
        model_tag_ = model_tag

        # Validate arguments against known Juju API types.
        if credential_tag_ is not None and not isinstance(
            credential_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected credential_tag_ to be a str, received: {type(credential_tag_)}"
            )

        if model_tag_ is not None and not isinstance(model_tag_, (bytes, str)):
            raise Exception(
                f"Expected model_tag_ to be a str, received: {type(model_tag_)}"
            )

        self.credential_tag = credential_tag_
        self.model_tag = model_tag_
        self.unknown_fields = unknown_fields


class ChangeModelCredentialsParams(Type):
    _toSchema = {"model_credentials": "model-credentials"}
    _toPy = {"model-credentials": "model_credentials"}

    def __init__(self, model_credentials=None, **unknown_fields):
        """model_credentials : typing.Sequence[~ChangeModelCredentialParams]"""
        model_credentials_ = [
            ChangeModelCredentialParams.from_json(o) for o in model_credentials or []
        ]

        # Validate arguments against known Juju API types.
        if model_credentials_ is not None and not isinstance(
            model_credentials_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected model_credentials_ to be a Sequence, received: {type(model_credentials_)}"
            )

        self.model_credentials = model_credentials_
        self.unknown_fields = unknown_fields


class Charm(Type):
    _toSchema = {
        "actions": "actions",
        "config": "config",
        "lxd_profile": "lxd-profile",
        "manifest": "manifest",
        "meta": "meta",
        "metrics": "metrics",
        "revision": "revision",
        "url": "url",
    }
    _toPy = {
        "actions": "actions",
        "config": "config",
        "lxd-profile": "lxd_profile",
        "manifest": "manifest",
        "meta": "meta",
        "metrics": "metrics",
        "revision": "revision",
        "url": "url",
    }

    def __init__(
        self,
        actions=None,
        config=None,
        lxd_profile=None,
        manifest=None,
        meta=None,
        metrics=None,
        revision=None,
        url=None,
        **unknown_fields,
    ):
        """Actions : CharmActions
        config : typing.Mapping[str, ~CharmOption]
        lxd_profile : CharmLXDProfile
        manifest : CharmManifest
        meta : CharmMeta
        metrics : CharmMetrics
        revision : int
        url : str
        """
        actions_ = CharmActions.from_json(actions) if actions else None
        config_ = {k: CharmOption.from_json(v) for k, v in (config or dict()).items()}
        lxd_profile_ = CharmLXDProfile.from_json(lxd_profile) if lxd_profile else None
        manifest_ = CharmManifest.from_json(manifest) if manifest else None
        meta_ = CharmMeta.from_json(meta) if meta else None
        metrics_ = CharmMetrics.from_json(metrics) if metrics else None
        revision_ = revision
        url_ = url

        # Validate arguments against known Juju API types.
        if actions_ is not None and not isinstance(actions_, (dict, CharmActions)):
            raise Exception(
                f"Expected actions_ to be a CharmActions, received: {type(actions_)}"
            )

        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        if lxd_profile_ is not None and not isinstance(
            lxd_profile_, (dict, CharmLXDProfile)
        ):
            raise Exception(
                f"Expected lxd_profile_ to be a CharmLXDProfile, received: {type(lxd_profile_)}"
            )

        if manifest_ is not None and not isinstance(manifest_, (dict, CharmManifest)):
            raise Exception(
                f"Expected manifest_ to be a CharmManifest, received: {type(manifest_)}"
            )

        if meta_ is not None and not isinstance(meta_, (dict, CharmMeta)):
            raise Exception(
                f"Expected meta_ to be a CharmMeta, received: {type(meta_)}"
            )

        if metrics_ is not None and not isinstance(metrics_, (dict, CharmMetrics)):
            raise Exception(
                f"Expected metrics_ to be a CharmMetrics, received: {type(metrics_)}"
            )

        if revision_ is not None and not isinstance(revision_, int):
            raise Exception(
                f"Expected revision_ to be a int, received: {type(revision_)}"
            )

        if url_ is not None and not isinstance(url_, (bytes, str)):
            raise Exception(f"Expected url_ to be a str, received: {type(url_)}")

        self.actions = actions_
        self.config = config_
        self.lxd_profile = lxd_profile_
        self.manifest = manifest_
        self.meta = meta_
        self.metrics = metrics_
        self.revision = revision_
        self.url = url_
        self.unknown_fields = unknown_fields


class CharmActionSpec(Type):
    _toSchema = {"description": "description", "params": "params"}
    _toPy = {"description": "description", "params": "params"}

    def __init__(self, description=None, params=None, **unknown_fields):
        """Description : str
        params : typing.Mapping[str, typing.Any]
        """
        description_ = description
        params_ = params

        # Validate arguments against known Juju API types.
        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if params_ is not None and not isinstance(params_, dict):
            raise Exception(
                f"Expected params_ to be a Mapping, received: {type(params_)}"
            )

        self.description = description_
        self.params = params_
        self.unknown_fields = unknown_fields


class CharmActions(Type):
    _toSchema = {"specs": "specs"}
    _toPy = {"specs": "specs"}

    def __init__(self, specs=None, **unknown_fields):
        """Specs : typing.Mapping[str, ~CharmActionSpec]"""
        specs_ = {k: CharmActionSpec.from_json(v) for k, v in (specs or dict()).items()}

        # Validate arguments against known Juju API types.
        if specs_ is not None and not isinstance(specs_, dict):
            raise Exception(
                f"Expected specs_ to be a Mapping, received: {type(specs_)}"
            )

        self.specs = specs_
        self.unknown_fields = unknown_fields


class CharmBase(Type):
    _toSchema = {"architectures": "architectures", "channel": "channel", "name": "name"}
    _toPy = {"architectures": "architectures", "channel": "channel", "name": "name"}

    def __init__(self, architectures=None, channel=None, name=None, **unknown_fields):
        """Architectures : typing.Sequence[str]
        channel : str
        name : str
        """
        architectures_ = architectures
        channel_ = channel
        name_ = name

        # Validate arguments against known Juju API types.
        if architectures_ is not None and not isinstance(
            architectures_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected architectures_ to be a Sequence, received: {type(architectures_)}"
            )

        if channel_ is not None and not isinstance(channel_, (bytes, str)):
            raise Exception(
                f"Expected channel_ to be a str, received: {type(channel_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        self.architectures = architectures_
        self.channel = channel_
        self.name = name_
        self.unknown_fields = unknown_fields


class CharmContainer(Type):
    _toSchema = {"gid": "gid", "mounts": "mounts", "resource": "resource", "uid": "uid"}
    _toPy = {"gid": "gid", "mounts": "mounts", "resource": "resource", "uid": "uid"}

    def __init__(
        self, gid=None, mounts=None, resource=None, uid=None, **unknown_fields
    ):
        """Gid : int
        mounts : typing.Sequence[~CharmMount]
        resource : str
        uid : int
        """
        gid_ = gid
        mounts_ = [CharmMount.from_json(o) for o in mounts or []]
        resource_ = resource
        uid_ = uid

        # Validate arguments against known Juju API types.
        if gid_ is not None and not isinstance(gid_, int):
            raise Exception(f"Expected gid_ to be a int, received: {type(gid_)}")

        if mounts_ is not None and not isinstance(mounts_, (bytes, str, list)):
            raise Exception(
                f"Expected mounts_ to be a Sequence, received: {type(mounts_)}"
            )

        if resource_ is not None and not isinstance(resource_, (bytes, str)):
            raise Exception(
                f"Expected resource_ to be a str, received: {type(resource_)}"
            )

        if uid_ is not None and not isinstance(uid_, int):
            raise Exception(f"Expected uid_ to be a int, received: {type(uid_)}")

        self.gid = gid_
        self.mounts = mounts_
        self.resource = resource_
        self.uid = uid_
        self.unknown_fields = unknown_fields


class CharmDeployment(Type):
    _toSchema = {
        "min_version": "min-version",
        "mode": "mode",
        "service": "service",
        "type_": "type",
    }
    _toPy = {
        "min-version": "min_version",
        "mode": "mode",
        "service": "service",
        "type": "type_",
    }

    def __init__(
        self, min_version=None, mode=None, service=None, type_=None, **unknown_fields
    ):
        """min_version : str
        mode : str
        service : str
        type_ : str
        """
        min_version_ = min_version
        mode_ = mode
        service_ = service
        type__ = type_

        # Validate arguments against known Juju API types.
        if min_version_ is not None and not isinstance(min_version_, (bytes, str)):
            raise Exception(
                f"Expected min_version_ to be a str, received: {type(min_version_)}"
            )

        if mode_ is not None and not isinstance(mode_, (bytes, str)):
            raise Exception(f"Expected mode_ to be a str, received: {type(mode_)}")

        if service_ is not None and not isinstance(service_, (bytes, str)):
            raise Exception(
                f"Expected service_ to be a str, received: {type(service_)}"
            )

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        self.min_version = min_version_
        self.mode = mode_
        self.service = service_
        self.type_ = type__
        self.unknown_fields = unknown_fields


class CharmDevice(Type):
    _toSchema = {
        "countmax": "CountMax",
        "countmin": "CountMin",
        "description": "Description",
        "name": "Name",
        "type_": "Type",
    }
    _toPy = {
        "CountMax": "countmax",
        "CountMin": "countmin",
        "Description": "description",
        "Name": "name",
        "Type": "type_",
    }

    def __init__(
        self,
        countmax=None,
        countmin=None,
        description=None,
        name=None,
        type_=None,
        **unknown_fields,
    ):
        """Countmax : int
        countmin : int
        description : str
        name : str
        type_ : str
        """
        countmax_ = countmax
        countmin_ = countmin
        description_ = description
        name_ = name
        type__ = type_

        # Validate arguments against known Juju API types.
        if countmax_ is not None and not isinstance(countmax_, int):
            raise Exception(
                f"Expected countmax_ to be a int, received: {type(countmax_)}"
            )

        if countmin_ is not None and not isinstance(countmin_, int):
            raise Exception(
                f"Expected countmin_ to be a int, received: {type(countmin_)}"
            )

        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        self.countmax = countmax_
        self.countmin = countmin_
        self.description = description_
        self.name = name_
        self.type_ = type__
        self.unknown_fields = unknown_fields


class CharmLXDProfile(Type):
    _toSchema = {"config": "config", "description": "description", "devices": "devices"}
    _toPy = {"config": "config", "description": "description", "devices": "devices"}

    def __init__(self, config=None, description=None, devices=None, **unknown_fields):
        """Config : typing.Mapping[str, str]
        description : str
        devices : typing.Mapping[str, typing.Any]
        """
        config_ = config
        description_ = description
        devices_ = devices

        # Validate arguments against known Juju API types.
        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if devices_ is not None and not isinstance(devices_, dict):
            raise Exception(
                f"Expected devices_ to be a Mapping, received: {type(devices_)}"
            )

        self.config = config_
        self.description = description_
        self.devices = devices_
        self.unknown_fields = unknown_fields


class CharmManifest(Type):
    _toSchema = {"bases": "bases"}
    _toPy = {"bases": "bases"}

    def __init__(self, bases=None, **unknown_fields):
        """Bases : typing.Sequence[~CharmBase]"""
        bases_ = [CharmBase.from_json(o) for o in bases or []]

        # Validate arguments against known Juju API types.
        if bases_ is not None and not isinstance(bases_, (bytes, str, list)):
            raise Exception(
                f"Expected bases_ to be a Sequence, received: {type(bases_)}"
            )

        self.bases = bases_
        self.unknown_fields = unknown_fields


class CharmMeta(Type):
    _toSchema = {
        "assumes_expr": "assumes-expr",
        "categories": "categories",
        "charm_user": "charm-user",
        "containers": "containers",
        "deployment": "deployment",
        "description": "description",
        "devices": "devices",
        "extra_bindings": "extra-bindings",
        "min_juju_version": "min-juju-version",
        "name": "name",
        "payload_classes": "payload-classes",
        "peers": "peers",
        "provides": "provides",
        "requires": "requires",
        "resources": "resources",
        "series": "series",
        "storage": "storage",
        "subordinate": "subordinate",
        "summary": "summary",
        "tags": "tags",
        "terms": "terms",
    }
    _toPy = {
        "assumes-expr": "assumes_expr",
        "categories": "categories",
        "charm-user": "charm_user",
        "containers": "containers",
        "deployment": "deployment",
        "description": "description",
        "devices": "devices",
        "extra-bindings": "extra_bindings",
        "min-juju-version": "min_juju_version",
        "name": "name",
        "payload-classes": "payload_classes",
        "peers": "peers",
        "provides": "provides",
        "requires": "requires",
        "resources": "resources",
        "series": "series",
        "storage": "storage",
        "subordinate": "subordinate",
        "summary": "summary",
        "tags": "tags",
        "terms": "terms",
    }

    def __init__(
        self,
        assumes_expr=None,
        categories=None,
        charm_user=None,
        containers=None,
        deployment=None,
        description=None,
        devices=None,
        extra_bindings=None,
        min_juju_version=None,
        name=None,
        payload_classes=None,
        peers=None,
        provides=None,
        requires=None,
        resources=None,
        series=None,
        storage=None,
        subordinate=None,
        summary=None,
        tags=None,
        terms=None,
        **unknown_fields,
    ):
        """assumes_expr : ExpressionTree
        categories : typing.Sequence[str]
        charm_user : str
        containers : typing.Mapping[str, ~CharmContainer]
        deployment : CharmDeployment
        description : str
        devices : typing.Mapping[str, ~CharmDevice]
        extra_bindings : typing.Mapping[str, str]
        min_juju_version : str
        name : str
        payload_classes : typing.Mapping[str, ~CharmPayloadClass]
        peers : typing.Mapping[str, ~CharmRelation]
        provides : typing.Mapping[str, ~CharmRelation]
        requires : typing.Mapping[str, ~CharmRelation]
        resources : typing.Mapping[str, ~CharmResourceMeta]
        series : typing.Sequence[str]
        storage : typing.Mapping[str, ~CharmStorage]
        subordinate : bool
        summary : str
        tags : typing.Sequence[str]
        terms : typing.Sequence[str]
        """
        assumes_expr_ = ExpressionTree.from_json(assumes_expr) if assumes_expr else None
        categories_ = categories
        charm_user_ = charm_user
        containers_ = {
            k: CharmContainer.from_json(v) for k, v in (containers or dict()).items()
        }
        deployment_ = CharmDeployment.from_json(deployment) if deployment else None
        description_ = description
        devices_ = {k: CharmDevice.from_json(v) for k, v in (devices or dict()).items()}
        extra_bindings_ = extra_bindings
        min_juju_version_ = min_juju_version
        name_ = name
        payload_classes_ = {
            k: CharmPayloadClass.from_json(v)
            for k, v in (payload_classes or dict()).items()
        }
        peers_ = {k: CharmRelation.from_json(v) for k, v in (peers or dict()).items()}
        provides_ = {
            k: CharmRelation.from_json(v) for k, v in (provides or dict()).items()
        }
        requires_ = {
            k: CharmRelation.from_json(v) for k, v in (requires or dict()).items()
        }
        resources_ = {
            k: CharmResourceMeta.from_json(v) for k, v in (resources or dict()).items()
        }
        series_ = series
        storage_ = {
            k: CharmStorage.from_json(v) for k, v in (storage or dict()).items()
        }
        subordinate_ = subordinate
        summary_ = summary
        tags_ = tags
        terms_ = terms

        # Validate arguments against known Juju API types.
        if assumes_expr_ is not None and not isinstance(
            assumes_expr_, (dict, ExpressionTree)
        ):
            raise Exception(
                f"Expected assumes_expr_ to be a ExpressionTree, received: {type(assumes_expr_)}"
            )

        if categories_ is not None and not isinstance(categories_, (bytes, str, list)):
            raise Exception(
                f"Expected categories_ to be a Sequence, received: {type(categories_)}"
            )

        if charm_user_ is not None and not isinstance(charm_user_, (bytes, str)):
            raise Exception(
                f"Expected charm_user_ to be a str, received: {type(charm_user_)}"
            )

        if containers_ is not None and not isinstance(containers_, dict):
            raise Exception(
                f"Expected containers_ to be a Mapping, received: {type(containers_)}"
            )

        if deployment_ is not None and not isinstance(
            deployment_, (dict, CharmDeployment)
        ):
            raise Exception(
                f"Expected deployment_ to be a CharmDeployment, received: {type(deployment_)}"
            )

        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if devices_ is not None and not isinstance(devices_, dict):
            raise Exception(
                f"Expected devices_ to be a Mapping, received: {type(devices_)}"
            )

        if extra_bindings_ is not None and not isinstance(extra_bindings_, dict):
            raise Exception(
                f"Expected extra_bindings_ to be a Mapping, received: {type(extra_bindings_)}"
            )

        if min_juju_version_ is not None and not isinstance(
            min_juju_version_, (bytes, str)
        ):
            raise Exception(
                f"Expected min_juju_version_ to be a str, received: {type(min_juju_version_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if payload_classes_ is not None and not isinstance(payload_classes_, dict):
            raise Exception(
                f"Expected payload_classes_ to be a Mapping, received: {type(payload_classes_)}"
            )

        if peers_ is not None and not isinstance(peers_, dict):
            raise Exception(
                f"Expected peers_ to be a Mapping, received: {type(peers_)}"
            )

        if provides_ is not None and not isinstance(provides_, dict):
            raise Exception(
                f"Expected provides_ to be a Mapping, received: {type(provides_)}"
            )

        if requires_ is not None and not isinstance(requires_, dict):
            raise Exception(
                f"Expected requires_ to be a Mapping, received: {type(requires_)}"
            )

        if resources_ is not None and not isinstance(resources_, dict):
            raise Exception(
                f"Expected resources_ to be a Mapping, received: {type(resources_)}"
            )

        if series_ is not None and not isinstance(series_, (bytes, str, list)):
            raise Exception(
                f"Expected series_ to be a Sequence, received: {type(series_)}"
            )

        if storage_ is not None and not isinstance(storage_, dict):
            raise Exception(
                f"Expected storage_ to be a Mapping, received: {type(storage_)}"
            )

        if subordinate_ is not None and not isinstance(subordinate_, bool):
            raise Exception(
                f"Expected subordinate_ to be a bool, received: {type(subordinate_)}"
            )

        if summary_ is not None and not isinstance(summary_, (bytes, str)):
            raise Exception(
                f"Expected summary_ to be a str, received: {type(summary_)}"
            )

        if tags_ is not None and not isinstance(tags_, (bytes, str, list)):
            raise Exception(f"Expected tags_ to be a Sequence, received: {type(tags_)}")

        if terms_ is not None and not isinstance(terms_, (bytes, str, list)):
            raise Exception(
                f"Expected terms_ to be a Sequence, received: {type(terms_)}"
            )

        self.assumes_expr = assumes_expr_
        self.categories = categories_
        self.charm_user = charm_user_
        self.containers = containers_
        self.deployment = deployment_
        self.description = description_
        self.devices = devices_
        self.extra_bindings = extra_bindings_
        self.min_juju_version = min_juju_version_
        self.name = name_
        self.payload_classes = payload_classes_
        self.peers = peers_
        self.provides = provides_
        self.requires = requires_
        self.resources = resources_
        self.series = series_
        self.storage = storage_
        self.subordinate = subordinate_
        self.summary = summary_
        self.tags = tags_
        self.terms = terms_
        self.unknown_fields = unknown_fields


class CharmMetric(Type):
    _toSchema = {"description": "description", "type_": "type"}
    _toPy = {"description": "description", "type": "type_"}

    def __init__(self, description=None, type_=None, **unknown_fields):
        """Description : str
        type_ : str
        """
        description_ = description
        type__ = type_

        # Validate arguments against known Juju API types.
        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        self.description = description_
        self.type_ = type__
        self.unknown_fields = unknown_fields


class CharmMetrics(Type):
    _toSchema = {"metrics": "metrics", "plan": "plan"}
    _toPy = {"metrics": "metrics", "plan": "plan"}

    def __init__(self, metrics=None, plan=None, **unknown_fields):
        """Metrics : typing.Mapping[str, ~CharmMetric]
        plan : CharmPlan
        """
        metrics_ = {k: CharmMetric.from_json(v) for k, v in (metrics or dict()).items()}
        plan_ = CharmPlan.from_json(plan) if plan else None

        # Validate arguments against known Juju API types.
        if metrics_ is not None and not isinstance(metrics_, dict):
            raise Exception(
                f"Expected metrics_ to be a Mapping, received: {type(metrics_)}"
            )

        if plan_ is not None and not isinstance(plan_, (dict, CharmPlan)):
            raise Exception(
                f"Expected plan_ to be a CharmPlan, received: {type(plan_)}"
            )

        self.metrics = metrics_
        self.plan = plan_
        self.unknown_fields = unknown_fields


class CharmMount(Type):
    _toSchema = {"location": "location", "storage": "storage"}
    _toPy = {"location": "location", "storage": "storage"}

    def __init__(self, location=None, storage=None, **unknown_fields):
        """Location : str
        storage : str
        """
        location_ = location
        storage_ = storage

        # Validate arguments against known Juju API types.
        if location_ is not None and not isinstance(location_, (bytes, str)):
            raise Exception(
                f"Expected location_ to be a str, received: {type(location_)}"
            )

        if storage_ is not None and not isinstance(storage_, (bytes, str)):
            raise Exception(
                f"Expected storage_ to be a str, received: {type(storage_)}"
            )

        self.location = location_
        self.storage = storage_
        self.unknown_fields = unknown_fields


class CharmOption(Type):
    _toSchema = {"default": "default", "description": "description", "type_": "type"}
    _toPy = {"default": "default", "description": "description", "type": "type_"}

    def __init__(self, default=None, description=None, type_=None, **unknown_fields):
        """Default : Any
        description : str
        type_ : str
        """
        default_ = default
        description_ = description
        type__ = type_

        # Validate arguments against known Juju API types.
        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        self.default = default_
        self.description = description_
        self.type_ = type__
        self.unknown_fields = unknown_fields


class CharmOrigin(Type):
    _toSchema = {
        "architecture": "architecture",
        "base": "base",
        "branch": "branch",
        "hash_": "hash",
        "id_": "id",
        "instance_key": "instance-key",
        "revision": "revision",
        "risk": "risk",
        "source": "source",
        "track": "track",
        "type_": "type",
    }
    _toPy = {
        "architecture": "architecture",
        "base": "base",
        "branch": "branch",
        "hash": "hash_",
        "id": "id_",
        "instance-key": "instance_key",
        "revision": "revision",
        "risk": "risk",
        "source": "source",
        "track": "track",
        "type": "type_",
    }

    def __init__(
        self,
        architecture=None,
        base=None,
        branch=None,
        hash_=None,
        id_=None,
        instance_key=None,
        revision=None,
        risk=None,
        source=None,
        track=None,
        type_=None,
        **unknown_fields,
    ):
        """Architecture : str
        base : Base
        branch : str
        hash_ : str
        id_ : str
        instance_key : str
        revision : int
        risk : str
        source : str
        track : str
        type_ : str
        """
        architecture_ = architecture
        base_ = Base.from_json(base) if base else None
        branch_ = branch
        hash__ = hash_
        id__ = id_
        instance_key_ = instance_key
        revision_ = revision
        risk_ = risk
        source_ = source
        track_ = track
        type__ = type_

        # Validate arguments against known Juju API types.
        if architecture_ is not None and not isinstance(architecture_, (bytes, str)):
            raise Exception(
                f"Expected architecture_ to be a str, received: {type(architecture_)}"
            )

        if base_ is not None and not isinstance(base_, (dict, Base)):
            raise Exception(f"Expected base_ to be a Base, received: {type(base_)}")

        if branch_ is not None and not isinstance(branch_, (bytes, str)):
            raise Exception(f"Expected branch_ to be a str, received: {type(branch_)}")

        if hash__ is not None and not isinstance(hash__, (bytes, str)):
            raise Exception(f"Expected hash__ to be a str, received: {type(hash__)}")

        if id__ is not None and not isinstance(id__, (bytes, str)):
            raise Exception(f"Expected id__ to be a str, received: {type(id__)}")

        if instance_key_ is not None and not isinstance(instance_key_, (bytes, str)):
            raise Exception(
                f"Expected instance_key_ to be a str, received: {type(instance_key_)}"
            )

        if revision_ is not None and not isinstance(revision_, int):
            raise Exception(
                f"Expected revision_ to be a int, received: {type(revision_)}"
            )

        if risk_ is not None and not isinstance(risk_, (bytes, str)):
            raise Exception(f"Expected risk_ to be a str, received: {type(risk_)}")

        if source_ is not None and not isinstance(source_, (bytes, str)):
            raise Exception(f"Expected source_ to be a str, received: {type(source_)}")

        if track_ is not None and not isinstance(track_, (bytes, str)):
            raise Exception(f"Expected track_ to be a str, received: {type(track_)}")

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        self.architecture = architecture_
        self.base = base_
        self.branch = branch_
        self.hash_ = hash__
        self.id_ = id__
        self.instance_key = instance_key_
        self.revision = revision_
        self.risk = risk_
        self.source = source_
        self.track = track_
        self.type_ = type__
        self.unknown_fields = unknown_fields


class CharmOriginResult(Type):
    _toSchema = {"charm_origin": "charm-origin", "error": "error"}
    _toPy = {"charm-origin": "charm_origin", "error": "error"}

    def __init__(self, charm_origin=None, error=None, **unknown_fields):
        """charm_origin : CharmOrigin
        error : Error
        """
        charm_origin_ = CharmOrigin.from_json(charm_origin) if charm_origin else None
        error_ = Error.from_json(error) if error else None

        # Validate arguments against known Juju API types.
        if charm_origin_ is not None and not isinstance(
            charm_origin_, (dict, CharmOrigin)
        ):
            raise Exception(
                f"Expected charm_origin_ to be a CharmOrigin, received: {type(charm_origin_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        self.charm_origin = charm_origin_
        self.error = error_
        self.unknown_fields = unknown_fields


class CharmPayloadClass(Type):
    _toSchema = {"name": "name", "type_": "type"}
    _toPy = {"name": "name", "type": "type_"}

    def __init__(self, name=None, type_=None, **unknown_fields):
        """Name : str
        type_ : str
        """
        name_ = name
        type__ = type_

        # Validate arguments against known Juju API types.
        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        self.name = name_
        self.type_ = type__
        self.unknown_fields = unknown_fields


class CharmPlan(Type):
    _toSchema = {"required": "required"}
    _toPy = {"required": "required"}

    def __init__(self, required=None, **unknown_fields):
        """Required : bool"""
        required_ = required

        # Validate arguments against known Juju API types.
        if required_ is not None and not isinstance(required_, bool):
            raise Exception(
                f"Expected required_ to be a bool, received: {type(required_)}"
            )

        self.required = required_
        self.unknown_fields = unknown_fields


class CharmRelation(Type):
    _toSchema = {
        "interface": "interface",
        "limit": "limit",
        "name": "name",
        "optional": "optional",
        "role": "role",
        "scope": "scope",
    }
    _toPy = {
        "interface": "interface",
        "limit": "limit",
        "name": "name",
        "optional": "optional",
        "role": "role",
        "scope": "scope",
    }

    def __init__(
        self,
        interface=None,
        limit=None,
        name=None,
        optional=None,
        role=None,
        scope=None,
        **unknown_fields,
    ):
        """Interface : str
        limit : int
        name : str
        optional : bool
        role : str
        scope : str
        """
        interface_ = interface
        limit_ = limit
        name_ = name
        optional_ = optional
        role_ = role
        scope_ = scope

        # Validate arguments against known Juju API types.
        if interface_ is not None and not isinstance(interface_, (bytes, str)):
            raise Exception(
                f"Expected interface_ to be a str, received: {type(interface_)}"
            )

        if limit_ is not None and not isinstance(limit_, int):
            raise Exception(f"Expected limit_ to be a int, received: {type(limit_)}")

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if optional_ is not None and not isinstance(optional_, bool):
            raise Exception(
                f"Expected optional_ to be a bool, received: {type(optional_)}"
            )

        if role_ is not None and not isinstance(role_, (bytes, str)):
            raise Exception(f"Expected role_ to be a str, received: {type(role_)}")

        if scope_ is not None and not isinstance(scope_, (bytes, str)):
            raise Exception(f"Expected scope_ to be a str, received: {type(scope_)}")

        self.interface = interface_
        self.limit = limit_
        self.name = name_
        self.optional = optional_
        self.role = role_
        self.scope = scope_
        self.unknown_fields = unknown_fields


class CharmResource(Type):
    _toSchema = {
        "description": "description",
        "fingerprint": "fingerprint",
        "name": "name",
        "origin": "origin",
        "path": "path",
        "revision": "revision",
        "size": "size",
        "type_": "type",
    }
    _toPy = {
        "description": "description",
        "fingerprint": "fingerprint",
        "name": "name",
        "origin": "origin",
        "path": "path",
        "revision": "revision",
        "size": "size",
        "type": "type_",
    }

    def __init__(
        self,
        description=None,
        fingerprint=None,
        name=None,
        origin=None,
        path=None,
        revision=None,
        size=None,
        type_=None,
        **unknown_fields,
    ):
        """Description : str
        fingerprint : typing.Sequence[int]
        name : str
        origin : str
        path : str
        revision : int
        size : int
        type_ : str
        """
        description_ = description
        fingerprint_ = fingerprint
        name_ = name
        origin_ = origin
        path_ = path
        revision_ = revision
        size_ = size
        type__ = type_

        # Validate arguments against known Juju API types.
        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if fingerprint_ is not None and not isinstance(
            fingerprint_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected fingerprint_ to be a Sequence, received: {type(fingerprint_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if origin_ is not None and not isinstance(origin_, (bytes, str)):
            raise Exception(f"Expected origin_ to be a str, received: {type(origin_)}")

        if path_ is not None and not isinstance(path_, (bytes, str)):
            raise Exception(f"Expected path_ to be a str, received: {type(path_)}")

        if revision_ is not None and not isinstance(revision_, int):
            raise Exception(
                f"Expected revision_ to be a int, received: {type(revision_)}"
            )

        if size_ is not None and not isinstance(size_, int):
            raise Exception(f"Expected size_ to be a int, received: {type(size_)}")

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        self.description = description_
        self.fingerprint = fingerprint_
        self.name = name_
        self.origin = origin_
        self.path = path_
        self.revision = revision_
        self.size = size_
        self.type_ = type__
        self.unknown_fields = unknown_fields


class CharmResourceMeta(Type):
    _toSchema = {
        "description": "description",
        "name": "name",
        "path": "path",
        "type_": "type",
    }
    _toPy = {
        "description": "description",
        "name": "name",
        "path": "path",
        "type": "type_",
    }

    def __init__(
        self, description=None, name=None, path=None, type_=None, **unknown_fields
    ):
        """Description : str
        name : str
        path : str
        type_ : str
        """
        description_ = description
        name_ = name
        path_ = path
        type__ = type_

        # Validate arguments against known Juju API types.
        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if path_ is not None and not isinstance(path_, (bytes, str)):
            raise Exception(f"Expected path_ to be a str, received: {type(path_)}")

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        self.description = description_
        self.name = name_
        self.path = path_
        self.type_ = type__
        self.unknown_fields = unknown_fields


class CharmResourceResult(Type):
    _toSchema = {
        "charmresource": "CharmResource",
        "description": "description",
        "error": "error",
        "errorresult": "ErrorResult",
        "fingerprint": "fingerprint",
        "name": "name",
        "origin": "origin",
        "path": "path",
        "revision": "revision",
        "size": "size",
        "type_": "type",
    }
    _toPy = {
        "CharmResource": "charmresource",
        "ErrorResult": "errorresult",
        "description": "description",
        "error": "error",
        "fingerprint": "fingerprint",
        "name": "name",
        "origin": "origin",
        "path": "path",
        "revision": "revision",
        "size": "size",
        "type": "type_",
    }

    def __init__(
        self,
        charmresource=None,
        errorresult=None,
        description=None,
        error=None,
        fingerprint=None,
        name=None,
        origin=None,
        path=None,
        revision=None,
        size=None,
        type_=None,
        **unknown_fields,
    ):
        """Charmresource : CharmResource
        errorresult : ErrorResult
        description : str
        error : Error
        fingerprint : typing.Sequence[int]
        name : str
        origin : str
        path : str
        revision : int
        size : int
        type_ : str
        """
        charmresource_ = (
            CharmResource.from_json(charmresource) if charmresource else None
        )
        errorresult_ = ErrorResult.from_json(errorresult) if errorresult else None
        description_ = description
        error_ = Error.from_json(error) if error else None
        fingerprint_ = fingerprint
        name_ = name
        origin_ = origin
        path_ = path
        revision_ = revision
        size_ = size
        type__ = type_

        # Validate arguments against known Juju API types.
        if charmresource_ is not None and not isinstance(
            charmresource_, (dict, CharmResource)
        ):
            raise Exception(
                f"Expected charmresource_ to be a CharmResource, received: {type(charmresource_)}"
            )

        if errorresult_ is not None and not isinstance(
            errorresult_, (dict, ErrorResult)
        ):
            raise Exception(
                f"Expected errorresult_ to be a ErrorResult, received: {type(errorresult_)}"
            )

        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if fingerprint_ is not None and not isinstance(
            fingerprint_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected fingerprint_ to be a Sequence, received: {type(fingerprint_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if origin_ is not None and not isinstance(origin_, (bytes, str)):
            raise Exception(f"Expected origin_ to be a str, received: {type(origin_)}")

        if path_ is not None and not isinstance(path_, (bytes, str)):
            raise Exception(f"Expected path_ to be a str, received: {type(path_)}")

        if revision_ is not None and not isinstance(revision_, int):
            raise Exception(
                f"Expected revision_ to be a int, received: {type(revision_)}"
            )

        if size_ is not None and not isinstance(size_, int):
            raise Exception(f"Expected size_ to be a int, received: {type(size_)}")

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        self.charmresource = charmresource_
        self.errorresult = errorresult_
        self.description = description_
        self.error = error_
        self.fingerprint = fingerprint_
        self.name = name_
        self.origin = origin_
        self.path = path_
        self.revision = revision_
        self.size = size_
        self.type_ = type__
        self.unknown_fields = unknown_fields


class CharmResourcesResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~CharmResourceResult]"""
        results_ = [CharmResourceResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class CharmStorage(Type):
    _toSchema = {
        "count_max": "count-max",
        "count_min": "count-min",
        "description": "description",
        "location": "location",
        "minimum_size": "minimum-size",
        "name": "name",
        "properties": "properties",
        "read_only": "read-only",
        "shared": "shared",
        "type_": "type",
    }
    _toPy = {
        "count-max": "count_max",
        "count-min": "count_min",
        "description": "description",
        "location": "location",
        "minimum-size": "minimum_size",
        "name": "name",
        "properties": "properties",
        "read-only": "read_only",
        "shared": "shared",
        "type": "type_",
    }

    def __init__(
        self,
        count_max=None,
        count_min=None,
        description=None,
        location=None,
        minimum_size=None,
        name=None,
        properties=None,
        read_only=None,
        shared=None,
        type_=None,
        **unknown_fields,
    ):
        """count_max : int
        count_min : int
        description : str
        location : str
        minimum_size : int
        name : str
        properties : typing.Sequence[str]
        read_only : bool
        shared : bool
        type_ : str
        """
        count_max_ = count_max
        count_min_ = count_min
        description_ = description
        location_ = location
        minimum_size_ = minimum_size
        name_ = name
        properties_ = properties
        read_only_ = read_only
        shared_ = shared
        type__ = type_

        # Validate arguments against known Juju API types.
        if count_max_ is not None and not isinstance(count_max_, int):
            raise Exception(
                f"Expected count_max_ to be a int, received: {type(count_max_)}"
            )

        if count_min_ is not None and not isinstance(count_min_, int):
            raise Exception(
                f"Expected count_min_ to be a int, received: {type(count_min_)}"
            )

        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if location_ is not None and not isinstance(location_, (bytes, str)):
            raise Exception(
                f"Expected location_ to be a str, received: {type(location_)}"
            )

        if minimum_size_ is not None and not isinstance(minimum_size_, int):
            raise Exception(
                f"Expected minimum_size_ to be a int, received: {type(minimum_size_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if properties_ is not None and not isinstance(properties_, (bytes, str, list)):
            raise Exception(
                f"Expected properties_ to be a Sequence, received: {type(properties_)}"
            )

        if read_only_ is not None and not isinstance(read_only_, bool):
            raise Exception(
                f"Expected read_only_ to be a bool, received: {type(read_only_)}"
            )

        if shared_ is not None and not isinstance(shared_, bool):
            raise Exception(f"Expected shared_ to be a bool, received: {type(shared_)}")

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        self.count_max = count_max_
        self.count_min = count_min_
        self.description = description_
        self.location = location_
        self.minimum_size = minimum_size_
        self.name = name_
        self.properties = properties_
        self.read_only = read_only_
        self.shared = shared_
        self.type_ = type__
        self.unknown_fields = unknown_fields


class CharmURL(Type):
    _toSchema = {"url": "url"}
    _toPy = {"url": "url"}

    def __init__(self, url=None, **unknown_fields):
        """Url : str"""
        url_ = url

        # Validate arguments against known Juju API types.
        if url_ is not None and not isinstance(url_, (bytes, str)):
            raise Exception(f"Expected url_ to be a str, received: {type(url_)}")

        self.url = url_
        self.unknown_fields = unknown_fields


class CharmURLAndOrigin(Type):
    _toSchema = {
        "charm_origin": "charm-origin",
        "charm_url": "charm-url",
        "macaroon": "macaroon",
    }
    _toPy = {
        "charm-origin": "charm_origin",
        "charm-url": "charm_url",
        "macaroon": "macaroon",
    }

    def __init__(
        self, charm_origin=None, charm_url=None, macaroon=None, **unknown_fields
    ):
        """charm_origin : CharmOrigin
        charm_url : str
        macaroon : Macaroon
        """
        charm_origin_ = CharmOrigin.from_json(charm_origin) if charm_origin else None
        charm_url_ = charm_url
        macaroon_ = Macaroon.from_json(macaroon) if macaroon else None

        # Validate arguments against known Juju API types.
        if charm_origin_ is not None and not isinstance(
            charm_origin_, (dict, CharmOrigin)
        ):
            raise Exception(
                f"Expected charm_origin_ to be a CharmOrigin, received: {type(charm_origin_)}"
            )

        if charm_url_ is not None and not isinstance(charm_url_, (bytes, str)):
            raise Exception(
                f"Expected charm_url_ to be a str, received: {type(charm_url_)}"
            )

        if macaroon_ is not None and not isinstance(macaroon_, (dict, Macaroon)):
            raise Exception(
                f"Expected macaroon_ to be a Macaroon, received: {type(macaroon_)}"
            )

        self.charm_origin = charm_origin_
        self.charm_url = charm_url_
        self.macaroon = macaroon_
        self.unknown_fields = unknown_fields


class CharmURLAndOrigins(Type):
    _toSchema = {"entities": "entities"}
    _toPy = {"entities": "entities"}

    def __init__(self, entities=None, **unknown_fields):
        """Entities : typing.Sequence[~CharmURLAndOrigin]"""
        entities_ = [CharmURLAndOrigin.from_json(o) for o in entities or []]

        # Validate arguments against known Juju API types.
        if entities_ is not None and not isinstance(entities_, (bytes, str, list)):
            raise Exception(
                f"Expected entities_ to be a Sequence, received: {type(entities_)}"
            )

        self.entities = entities_
        self.unknown_fields = unknown_fields


class CharmURLOriginResult(Type):
    _toSchema = {"charm_origin": "charm-origin", "error": "error", "url": "url"}
    _toPy = {"charm-origin": "charm_origin", "error": "error", "url": "url"}

    def __init__(self, charm_origin=None, error=None, url=None, **unknown_fields):
        """charm_origin : CharmOrigin
        error : Error
        url : str
        """
        charm_origin_ = CharmOrigin.from_json(charm_origin) if charm_origin else None
        error_ = Error.from_json(error) if error else None
        url_ = url

        # Validate arguments against known Juju API types.
        if charm_origin_ is not None and not isinstance(
            charm_origin_, (dict, CharmOrigin)
        ):
            raise Exception(
                f"Expected charm_origin_ to be a CharmOrigin, received: {type(charm_origin_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if url_ is not None and not isinstance(url_, (bytes, str)):
            raise Exception(f"Expected url_ to be a str, received: {type(url_)}")

        self.charm_origin = charm_origin_
        self.error = error_
        self.url = url_
        self.unknown_fields = unknown_fields


class CharmsList(Type):
    _toSchema = {"names": "names"}
    _toPy = {"names": "names"}

    def __init__(self, names=None, **unknown_fields):
        """Names : typing.Sequence[str]"""
        names_ = names

        # Validate arguments against known Juju API types.
        if names_ is not None and not isinstance(names_, (bytes, str, list)):
            raise Exception(
                f"Expected names_ to be a Sequence, received: {type(names_)}"
            )

        self.names = names_
        self.unknown_fields = unknown_fields


class CharmsListResult(Type):
    _toSchema = {"charm_urls": "charm-urls"}
    _toPy = {"charm-urls": "charm_urls"}

    def __init__(self, charm_urls=None, **unknown_fields):
        """charm_urls : typing.Sequence[str]"""
        charm_urls_ = charm_urls

        # Validate arguments against known Juju API types.
        if charm_urls_ is not None and not isinstance(charm_urls_, (bytes, str, list)):
            raise Exception(
                f"Expected charm_urls_ to be a Sequence, received: {type(charm_urls_)}"
            )

        self.charm_urls = charm_urls_
        self.unknown_fields = unknown_fields


class Cloud(Type):
    _toSchema = {
        "auth_types": "auth-types",
        "ca_certificates": "ca-certificates",
        "config": "config",
        "endpoint": "endpoint",
        "host_cloud_region": "host-cloud-region",
        "identity_endpoint": "identity-endpoint",
        "is_controller_cloud": "is-controller-cloud",
        "region_config": "region-config",
        "regions": "regions",
        "skip_tls_verify": "skip-tls-verify",
        "storage_endpoint": "storage-endpoint",
        "type_": "type",
    }
    _toPy = {
        "auth-types": "auth_types",
        "ca-certificates": "ca_certificates",
        "config": "config",
        "endpoint": "endpoint",
        "host-cloud-region": "host_cloud_region",
        "identity-endpoint": "identity_endpoint",
        "is-controller-cloud": "is_controller_cloud",
        "region-config": "region_config",
        "regions": "regions",
        "skip-tls-verify": "skip_tls_verify",
        "storage-endpoint": "storage_endpoint",
        "type": "type_",
    }

    def __init__(
        self,
        auth_types=None,
        ca_certificates=None,
        config=None,
        endpoint=None,
        host_cloud_region=None,
        identity_endpoint=None,
        is_controller_cloud=None,
        region_config=None,
        regions=None,
        skip_tls_verify=None,
        storage_endpoint=None,
        type_=None,
        **unknown_fields,
    ):
        """auth_types : typing.Sequence[str]
        ca_certificates : typing.Sequence[str]
        config : typing.Mapping[str, typing.Any]
        endpoint : str
        host_cloud_region : str
        identity_endpoint : str
        is_controller_cloud : bool
        region_config : typing.Mapping[str, typing.Any]
        regions : typing.Sequence[~CloudRegion]
        skip_tls_verify : bool
        storage_endpoint : str
        type_ : str
        """
        auth_types_ = auth_types
        ca_certificates_ = ca_certificates
        config_ = config
        endpoint_ = endpoint
        host_cloud_region_ = host_cloud_region
        identity_endpoint_ = identity_endpoint
        is_controller_cloud_ = is_controller_cloud
        region_config_ = region_config
        regions_ = [CloudRegion.from_json(o) for o in regions or []]
        skip_tls_verify_ = skip_tls_verify
        storage_endpoint_ = storage_endpoint
        type__ = type_

        # Validate arguments against known Juju API types.
        if auth_types_ is not None and not isinstance(auth_types_, (bytes, str, list)):
            raise Exception(
                f"Expected auth_types_ to be a Sequence, received: {type(auth_types_)}"
            )

        if ca_certificates_ is not None and not isinstance(
            ca_certificates_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected ca_certificates_ to be a Sequence, received: {type(ca_certificates_)}"
            )

        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        if endpoint_ is not None and not isinstance(endpoint_, (bytes, str)):
            raise Exception(
                f"Expected endpoint_ to be a str, received: {type(endpoint_)}"
            )

        if host_cloud_region_ is not None and not isinstance(
            host_cloud_region_, (bytes, str)
        ):
            raise Exception(
                f"Expected host_cloud_region_ to be a str, received: {type(host_cloud_region_)}"
            )

        if identity_endpoint_ is not None and not isinstance(
            identity_endpoint_, (bytes, str)
        ):
            raise Exception(
                f"Expected identity_endpoint_ to be a str, received: {type(identity_endpoint_)}"
            )

        if is_controller_cloud_ is not None and not isinstance(
            is_controller_cloud_, bool
        ):
            raise Exception(
                f"Expected is_controller_cloud_ to be a bool, received: {type(is_controller_cloud_)}"
            )

        if region_config_ is not None and not isinstance(region_config_, dict):
            raise Exception(
                f"Expected region_config_ to be a Mapping, received: {type(region_config_)}"
            )

        if regions_ is not None and not isinstance(regions_, (bytes, str, list)):
            raise Exception(
                f"Expected regions_ to be a Sequence, received: {type(regions_)}"
            )

        if skip_tls_verify_ is not None and not isinstance(skip_tls_verify_, bool):
            raise Exception(
                f"Expected skip_tls_verify_ to be a bool, received: {type(skip_tls_verify_)}"
            )

        if storage_endpoint_ is not None and not isinstance(
            storage_endpoint_, (bytes, str)
        ):
            raise Exception(
                f"Expected storage_endpoint_ to be a str, received: {type(storage_endpoint_)}"
            )

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        self.auth_types = auth_types_
        self.ca_certificates = ca_certificates_
        self.config = config_
        self.endpoint = endpoint_
        self.host_cloud_region = host_cloud_region_
        self.identity_endpoint = identity_endpoint_
        self.is_controller_cloud = is_controller_cloud_
        self.region_config = region_config_
        self.regions = regions_
        self.skip_tls_verify = skip_tls_verify_
        self.storage_endpoint = storage_endpoint_
        self.type_ = type__
        self.unknown_fields = unknown_fields


class CloudCredential(Type):
    _toSchema = {"attrs": "attrs", "auth_type": "auth-type", "redacted": "redacted"}
    _toPy = {"attrs": "attrs", "auth-type": "auth_type", "redacted": "redacted"}

    def __init__(self, attrs=None, auth_type=None, redacted=None, **unknown_fields):
        """Attrs : typing.Mapping[str, str]
        auth_type : str
        redacted : typing.Sequence[str]
        """
        attrs_ = attrs
        auth_type_ = auth_type
        redacted_ = redacted

        # Validate arguments against known Juju API types.
        if attrs_ is not None and not isinstance(attrs_, dict):
            raise Exception(
                f"Expected attrs_ to be a Mapping, received: {type(attrs_)}"
            )

        if auth_type_ is not None and not isinstance(auth_type_, (bytes, str)):
            raise Exception(
                f"Expected auth_type_ to be a str, received: {type(auth_type_)}"
            )

        if redacted_ is not None and not isinstance(redacted_, (bytes, str, list)):
            raise Exception(
                f"Expected redacted_ to be a Sequence, received: {type(redacted_)}"
            )

        self.attrs = attrs_
        self.auth_type = auth_type_
        self.redacted = redacted_
        self.unknown_fields = unknown_fields


class CloudCredentialArg(Type):
    _toSchema = {"cloud_name": "cloud-name", "credential_name": "credential-name"}
    _toPy = {"cloud-name": "cloud_name", "credential-name": "credential_name"}

    def __init__(self, cloud_name=None, credential_name=None, **unknown_fields):
        """cloud_name : str
        credential_name : str
        """
        cloud_name_ = cloud_name
        credential_name_ = credential_name

        # Validate arguments against known Juju API types.
        if cloud_name_ is not None and not isinstance(cloud_name_, (bytes, str)):
            raise Exception(
                f"Expected cloud_name_ to be a str, received: {type(cloud_name_)}"
            )

        if credential_name_ is not None and not isinstance(
            credential_name_, (bytes, str)
        ):
            raise Exception(
                f"Expected credential_name_ to be a str, received: {type(credential_name_)}"
            )

        self.cloud_name = cloud_name_
        self.credential_name = credential_name_
        self.unknown_fields = unknown_fields


class CloudCredentialArgs(Type):
    _toSchema = {"credentials": "credentials", "include_secrets": "include-secrets"}
    _toPy = {"credentials": "credentials", "include-secrets": "include_secrets"}

    def __init__(self, credentials=None, include_secrets=None, **unknown_fields):
        """Credentials : typing.Sequence[~CloudCredentialArg]
        include_secrets : bool
        """
        credentials_ = [CloudCredentialArg.from_json(o) for o in credentials or []]
        include_secrets_ = include_secrets

        # Validate arguments against known Juju API types.
        if credentials_ is not None and not isinstance(
            credentials_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected credentials_ to be a Sequence, received: {type(credentials_)}"
            )

        if include_secrets_ is not None and not isinstance(include_secrets_, bool):
            raise Exception(
                f"Expected include_secrets_ to be a bool, received: {type(include_secrets_)}"
            )

        self.credentials = credentials_
        self.include_secrets = include_secrets_
        self.unknown_fields = unknown_fields


class CloudCredentialResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : CloudCredential
        """
        error_ = Error.from_json(error) if error else None
        result_ = CloudCredential.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (dict, CloudCredential)):
            raise Exception(
                f"Expected result_ to be a CloudCredential, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class CloudCredentialResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~CloudCredentialResult]"""
        results_ = [CloudCredentialResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class CloudDetails(Type):
    _toSchema = {
        "auth_types": "auth-types",
        "endpoint": "endpoint",
        "identity_endpoint": "identity-endpoint",
        "regions": "regions",
        "storage_endpoint": "storage-endpoint",
        "type_": "type",
    }
    _toPy = {
        "auth-types": "auth_types",
        "endpoint": "endpoint",
        "identity-endpoint": "identity_endpoint",
        "regions": "regions",
        "storage-endpoint": "storage_endpoint",
        "type": "type_",
    }

    def __init__(
        self,
        auth_types=None,
        endpoint=None,
        identity_endpoint=None,
        regions=None,
        storage_endpoint=None,
        type_=None,
        **unknown_fields,
    ):
        """auth_types : typing.Sequence[str]
        endpoint : str
        identity_endpoint : str
        regions : typing.Sequence[~CloudRegion]
        storage_endpoint : str
        type_ : str
        """
        auth_types_ = auth_types
        endpoint_ = endpoint
        identity_endpoint_ = identity_endpoint
        regions_ = [CloudRegion.from_json(o) for o in regions or []]
        storage_endpoint_ = storage_endpoint
        type__ = type_

        # Validate arguments against known Juju API types.
        if auth_types_ is not None and not isinstance(auth_types_, (bytes, str, list)):
            raise Exception(
                f"Expected auth_types_ to be a Sequence, received: {type(auth_types_)}"
            )

        if endpoint_ is not None and not isinstance(endpoint_, (bytes, str)):
            raise Exception(
                f"Expected endpoint_ to be a str, received: {type(endpoint_)}"
            )

        if identity_endpoint_ is not None and not isinstance(
            identity_endpoint_, (bytes, str)
        ):
            raise Exception(
                f"Expected identity_endpoint_ to be a str, received: {type(identity_endpoint_)}"
            )

        if regions_ is not None and not isinstance(regions_, (bytes, str, list)):
            raise Exception(
                f"Expected regions_ to be a Sequence, received: {type(regions_)}"
            )

        if storage_endpoint_ is not None and not isinstance(
            storage_endpoint_, (bytes, str)
        ):
            raise Exception(
                f"Expected storage_endpoint_ to be a str, received: {type(storage_endpoint_)}"
            )

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        self.auth_types = auth_types_
        self.endpoint = endpoint_
        self.identity_endpoint = identity_endpoint_
        self.regions = regions_
        self.storage_endpoint = storage_endpoint_
        self.type_ = type__
        self.unknown_fields = unknown_fields


class CloudImageMetadata(Type):
    _toSchema = {
        "arch": "arch",
        "image_id": "image-id",
        "priority": "priority",
        "region": "region",
        "root_storage_size": "root-storage-size",
        "root_storage_type": "root-storage-type",
        "source": "source",
        "stream": "stream",
        "version": "version",
        "virt_type": "virt-type",
    }
    _toPy = {
        "arch": "arch",
        "image-id": "image_id",
        "priority": "priority",
        "region": "region",
        "root-storage-size": "root_storage_size",
        "root-storage-type": "root_storage_type",
        "source": "source",
        "stream": "stream",
        "version": "version",
        "virt-type": "virt_type",
    }

    def __init__(
        self,
        arch=None,
        image_id=None,
        priority=None,
        region=None,
        root_storage_size=None,
        root_storage_type=None,
        source=None,
        stream=None,
        version=None,
        virt_type=None,
        **unknown_fields,
    ):
        """Arch : str
        image_id : str
        priority : int
        region : str
        root_storage_size : int
        root_storage_type : str
        source : str
        stream : str
        version : str
        virt_type : str
        """
        arch_ = arch
        image_id_ = image_id
        priority_ = priority
        region_ = region
        root_storage_size_ = root_storage_size
        root_storage_type_ = root_storage_type
        source_ = source
        stream_ = stream
        version_ = version
        virt_type_ = virt_type

        # Validate arguments against known Juju API types.
        if arch_ is not None and not isinstance(arch_, (bytes, str)):
            raise Exception(f"Expected arch_ to be a str, received: {type(arch_)}")

        if image_id_ is not None and not isinstance(image_id_, (bytes, str)):
            raise Exception(
                f"Expected image_id_ to be a str, received: {type(image_id_)}"
            )

        if priority_ is not None and not isinstance(priority_, int):
            raise Exception(
                f"Expected priority_ to be a int, received: {type(priority_)}"
            )

        if region_ is not None and not isinstance(region_, (bytes, str)):
            raise Exception(f"Expected region_ to be a str, received: {type(region_)}")

        if root_storage_size_ is not None and not isinstance(root_storage_size_, int):
            raise Exception(
                f"Expected root_storage_size_ to be a int, received: {type(root_storage_size_)}"
            )

        if root_storage_type_ is not None and not isinstance(
            root_storage_type_, (bytes, str)
        ):
            raise Exception(
                f"Expected root_storage_type_ to be a str, received: {type(root_storage_type_)}"
            )

        if source_ is not None and not isinstance(source_, (bytes, str)):
            raise Exception(f"Expected source_ to be a str, received: {type(source_)}")

        if stream_ is not None and not isinstance(stream_, (bytes, str)):
            raise Exception(f"Expected stream_ to be a str, received: {type(stream_)}")

        if version_ is not None and not isinstance(version_, (bytes, str)):
            raise Exception(
                f"Expected version_ to be a str, received: {type(version_)}"
            )

        if virt_type_ is not None and not isinstance(virt_type_, (bytes, str)):
            raise Exception(
                f"Expected virt_type_ to be a str, received: {type(virt_type_)}"
            )

        self.arch = arch_
        self.image_id = image_id_
        self.priority = priority_
        self.region = region_
        self.root_storage_size = root_storage_size_
        self.root_storage_type = root_storage_type_
        self.source = source_
        self.stream = stream_
        self.version = version_
        self.virt_type = virt_type_
        self.unknown_fields = unknown_fields


class CloudImageMetadataList(Type):
    _toSchema = {"metadata": "metadata"}
    _toPy = {"metadata": "metadata"}

    def __init__(self, metadata=None, **unknown_fields):
        """Metadata : typing.Sequence[~CloudImageMetadata]"""
        metadata_ = [CloudImageMetadata.from_json(o) for o in metadata or []]

        # Validate arguments against known Juju API types.
        if metadata_ is not None and not isinstance(metadata_, (bytes, str, list)):
            raise Exception(
                f"Expected metadata_ to be a Sequence, received: {type(metadata_)}"
            )

        self.metadata = metadata_
        self.unknown_fields = unknown_fields


class CloudInfo(Type):
    _toSchema = {"clouddetails": "CloudDetails", "users": "users"}
    _toPy = {"CloudDetails": "clouddetails", "users": "users"}

    def __init__(self, clouddetails=None, users=None, **unknown_fields):
        """Clouddetails : CloudDetails
        users : typing.Sequence[~CloudUserInfo]
        """
        clouddetails_ = CloudDetails.from_json(clouddetails) if clouddetails else None
        users_ = [CloudUserInfo.from_json(o) for o in users or []]

        # Validate arguments against known Juju API types.
        if clouddetails_ is not None and not isinstance(
            clouddetails_, (dict, CloudDetails)
        ):
            raise Exception(
                f"Expected clouddetails_ to be a CloudDetails, received: {type(clouddetails_)}"
            )

        if users_ is not None and not isinstance(users_, (bytes, str, list)):
            raise Exception(
                f"Expected users_ to be a Sequence, received: {type(users_)}"
            )

        self.clouddetails = clouddetails_
        self.users = users_
        self.unknown_fields = unknown_fields


class CloudInfoResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : CloudInfo
        """
        error_ = Error.from_json(error) if error else None
        result_ = CloudInfo.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (dict, CloudInfo)):
            raise Exception(
                f"Expected result_ to be a CloudInfo, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class CloudInfoResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~CloudInfoResult]"""
        results_ = [CloudInfoResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class CloudInstanceTypesConstraint(Type):
    _toSchema = {
        "cloud_tag": "cloud-tag",
        "constraints": "constraints",
        "region": "region",
    }
    _toPy = {"cloud-tag": "cloud_tag", "constraints": "constraints", "region": "region"}

    def __init__(self, cloud_tag=None, constraints=None, region=None, **unknown_fields):
        """cloud_tag : str
        constraints : Value
        region : str
        """
        cloud_tag_ = cloud_tag
        constraints_ = Value.from_json(constraints) if constraints else None
        region_ = region

        # Validate arguments against known Juju API types.
        if cloud_tag_ is not None and not isinstance(cloud_tag_, (bytes, str)):
            raise Exception(
                f"Expected cloud_tag_ to be a str, received: {type(cloud_tag_)}"
            )

        if constraints_ is not None and not isinstance(constraints_, (dict, Value)):
            raise Exception(
                f"Expected constraints_ to be a Value, received: {type(constraints_)}"
            )

        if region_ is not None and not isinstance(region_, (bytes, str)):
            raise Exception(f"Expected region_ to be a str, received: {type(region_)}")

        self.cloud_tag = cloud_tag_
        self.constraints = constraints_
        self.region = region_
        self.unknown_fields = unknown_fields


class CloudInstanceTypesConstraints(Type):
    _toSchema = {"constraints": "constraints"}
    _toPy = {"constraints": "constraints"}

    def __init__(self, constraints=None, **unknown_fields):
        """Constraints : typing.Sequence[~CloudInstanceTypesConstraint]"""
        constraints_ = [
            CloudInstanceTypesConstraint.from_json(o) for o in constraints or []
        ]

        # Validate arguments against known Juju API types.
        if constraints_ is not None and not isinstance(
            constraints_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected constraints_ to be a Sequence, received: {type(constraints_)}"
            )

        self.constraints = constraints_
        self.unknown_fields = unknown_fields


class CloudRegion(Type):
    _toSchema = {
        "endpoint": "endpoint",
        "identity_endpoint": "identity-endpoint",
        "name": "name",
        "storage_endpoint": "storage-endpoint",
    }
    _toPy = {
        "endpoint": "endpoint",
        "identity-endpoint": "identity_endpoint",
        "name": "name",
        "storage-endpoint": "storage_endpoint",
    }

    def __init__(
        self,
        endpoint=None,
        identity_endpoint=None,
        name=None,
        storage_endpoint=None,
        **unknown_fields,
    ):
        """Endpoint : str
        identity_endpoint : str
        name : str
        storage_endpoint : str
        """
        endpoint_ = endpoint
        identity_endpoint_ = identity_endpoint
        name_ = name
        storage_endpoint_ = storage_endpoint

        # Validate arguments against known Juju API types.
        if endpoint_ is not None and not isinstance(endpoint_, (bytes, str)):
            raise Exception(
                f"Expected endpoint_ to be a str, received: {type(endpoint_)}"
            )

        if identity_endpoint_ is not None and not isinstance(
            identity_endpoint_, (bytes, str)
        ):
            raise Exception(
                f"Expected identity_endpoint_ to be a str, received: {type(identity_endpoint_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if storage_endpoint_ is not None and not isinstance(
            storage_endpoint_, (bytes, str)
        ):
            raise Exception(
                f"Expected storage_endpoint_ to be a str, received: {type(storage_endpoint_)}"
            )

        self.endpoint = endpoint_
        self.identity_endpoint = identity_endpoint_
        self.name = name_
        self.storage_endpoint = storage_endpoint_
        self.unknown_fields = unknown_fields


class CloudResult(Type):
    _toSchema = {"cloud": "cloud", "error": "error"}
    _toPy = {"cloud": "cloud", "error": "error"}

    def __init__(self, cloud=None, error=None, **unknown_fields):
        """Cloud : Cloud
        error : Error
        """
        cloud_ = Cloud.from_json(cloud) if cloud else None
        error_ = Error.from_json(error) if error else None

        # Validate arguments against known Juju API types.
        if cloud_ is not None and not isinstance(cloud_, (dict, Cloud)):
            raise Exception(f"Expected cloud_ to be a Cloud, received: {type(cloud_)}")

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        self.cloud = cloud_
        self.error = error_
        self.unknown_fields = unknown_fields


class CloudResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~CloudResult]"""
        results_ = [CloudResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class CloudSpec(Type):
    _toSchema = {
        "cacertificates": "cacertificates",
        "credential": "credential",
        "endpoint": "endpoint",
        "identity_endpoint": "identity-endpoint",
        "is_controller_cloud": "is-controller-cloud",
        "name": "name",
        "region": "region",
        "skip_tls_verify": "skip-tls-verify",
        "storage_endpoint": "storage-endpoint",
        "type_": "type",
    }
    _toPy = {
        "cacertificates": "cacertificates",
        "credential": "credential",
        "endpoint": "endpoint",
        "identity-endpoint": "identity_endpoint",
        "is-controller-cloud": "is_controller_cloud",
        "name": "name",
        "region": "region",
        "skip-tls-verify": "skip_tls_verify",
        "storage-endpoint": "storage_endpoint",
        "type": "type_",
    }

    def __init__(
        self,
        cacertificates=None,
        credential=None,
        endpoint=None,
        identity_endpoint=None,
        is_controller_cloud=None,
        name=None,
        region=None,
        skip_tls_verify=None,
        storage_endpoint=None,
        type_=None,
        **unknown_fields,
    ):
        """Cacertificates : typing.Sequence[str]
        credential : CloudCredential
        endpoint : str
        identity_endpoint : str
        is_controller_cloud : bool
        name : str
        region : str
        skip_tls_verify : bool
        storage_endpoint : str
        type_ : str
        """
        cacertificates_ = cacertificates
        credential_ = CloudCredential.from_json(credential) if credential else None
        endpoint_ = endpoint
        identity_endpoint_ = identity_endpoint
        is_controller_cloud_ = is_controller_cloud
        name_ = name
        region_ = region
        skip_tls_verify_ = skip_tls_verify
        storage_endpoint_ = storage_endpoint
        type__ = type_

        # Validate arguments against known Juju API types.
        if cacertificates_ is not None and not isinstance(
            cacertificates_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected cacertificates_ to be a Sequence, received: {type(cacertificates_)}"
            )

        if credential_ is not None and not isinstance(
            credential_, (dict, CloudCredential)
        ):
            raise Exception(
                f"Expected credential_ to be a CloudCredential, received: {type(credential_)}"
            )

        if endpoint_ is not None and not isinstance(endpoint_, (bytes, str)):
            raise Exception(
                f"Expected endpoint_ to be a str, received: {type(endpoint_)}"
            )

        if identity_endpoint_ is not None and not isinstance(
            identity_endpoint_, (bytes, str)
        ):
            raise Exception(
                f"Expected identity_endpoint_ to be a str, received: {type(identity_endpoint_)}"
            )

        if is_controller_cloud_ is not None and not isinstance(
            is_controller_cloud_, bool
        ):
            raise Exception(
                f"Expected is_controller_cloud_ to be a bool, received: {type(is_controller_cloud_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if region_ is not None and not isinstance(region_, (bytes, str)):
            raise Exception(f"Expected region_ to be a str, received: {type(region_)}")

        if skip_tls_verify_ is not None and not isinstance(skip_tls_verify_, bool):
            raise Exception(
                f"Expected skip_tls_verify_ to be a bool, received: {type(skip_tls_verify_)}"
            )

        if storage_endpoint_ is not None and not isinstance(
            storage_endpoint_, (bytes, str)
        ):
            raise Exception(
                f"Expected storage_endpoint_ to be a str, received: {type(storage_endpoint_)}"
            )

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        self.cacertificates = cacertificates_
        self.credential = credential_
        self.endpoint = endpoint_
        self.identity_endpoint = identity_endpoint_
        self.is_controller_cloud = is_controller_cloud_
        self.name = name_
        self.region = region_
        self.skip_tls_verify = skip_tls_verify_
        self.storage_endpoint = storage_endpoint_
        self.type_ = type__
        self.unknown_fields = unknown_fields


class CloudSpecResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : CloudSpec
        """
        error_ = Error.from_json(error) if error else None
        result_ = CloudSpec.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (dict, CloudSpec)):
            raise Exception(
                f"Expected result_ to be a CloudSpec, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class CloudSpecResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~CloudSpecResult]"""
        results_ = [CloudSpecResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class CloudUserInfo(Type):
    _toSchema = {"access": "access", "display_name": "display-name", "user": "user"}
    _toPy = {"access": "access", "display-name": "display_name", "user": "user"}

    def __init__(self, access=None, display_name=None, user=None, **unknown_fields):
        """Access : str
        display_name : str
        user : str
        """
        access_ = access
        display_name_ = display_name
        user_ = user

        # Validate arguments against known Juju API types.
        if access_ is not None and not isinstance(access_, (bytes, str)):
            raise Exception(f"Expected access_ to be a str, received: {type(access_)}")

        if display_name_ is not None and not isinstance(display_name_, (bytes, str)):
            raise Exception(
                f"Expected display_name_ to be a str, received: {type(display_name_)}"
            )

        if user_ is not None and not isinstance(user_, (bytes, str)):
            raise Exception(f"Expected user_ to be a str, received: {type(user_)}")

        self.access = access_
        self.display_name = display_name_
        self.user = user_
        self.unknown_fields = unknown_fields


class CloudsResult(Type):
    _toSchema = {"clouds": "clouds"}
    _toPy = {"clouds": "clouds"}

    def __init__(self, clouds=None, **unknown_fields):
        """Clouds : typing.Mapping[str, ~Cloud]"""
        clouds_ = {k: Cloud.from_json(v) for k, v in (clouds or dict()).items()}

        # Validate arguments against known Juju API types.
        if clouds_ is not None and not isinstance(clouds_, dict):
            raise Exception(
                f"Expected clouds_ to be a Mapping, received: {type(clouds_)}"
            )

        self.clouds = clouds_
        self.unknown_fields = unknown_fields


class ConfigResult(Type):
    _toSchema = {"config": "config", "error": "error"}
    _toPy = {"config": "config", "error": "error"}

    def __init__(self, config=None, error=None, **unknown_fields):
        """Config : typing.Mapping[str, typing.Any]
        error : Error
        """
        config_ = config
        error_ = Error.from_json(error) if error else None

        # Validate arguments against known Juju API types.
        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        self.config = config_
        self.error = error_
        self.unknown_fields = unknown_fields


class ConfigSet(Type):
    _toSchema = {
        "application": "application",
        "config": "config",
        "config_yaml": "config-yaml",
        "generation": "generation",
    }
    _toPy = {
        "application": "application",
        "config": "config",
        "config-yaml": "config_yaml",
        "generation": "generation",
    }

    def __init__(
        self,
        application=None,
        config=None,
        config_yaml=None,
        generation=None,
        **unknown_fields,
    ):
        """Application : str
        config : typing.Mapping[str, str]
        config_yaml : str
        generation : str
        """
        application_ = application
        config_ = config
        config_yaml_ = config_yaml
        generation_ = generation

        # Validate arguments against known Juju API types.
        if application_ is not None and not isinstance(application_, (bytes, str)):
            raise Exception(
                f"Expected application_ to be a str, received: {type(application_)}"
            )

        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        if config_yaml_ is not None and not isinstance(config_yaml_, (bytes, str)):
            raise Exception(
                f"Expected config_yaml_ to be a str, received: {type(config_yaml_)}"
            )

        if generation_ is not None and not isinstance(generation_, (bytes, str)):
            raise Exception(
                f"Expected generation_ to be a str, received: {type(generation_)}"
            )

        self.application = application_
        self.config = config_
        self.config_yaml = config_yaml_
        self.generation = generation_
        self.unknown_fields = unknown_fields


class ConfigSetArgs(Type):
    _toSchema = {"args": "Args"}
    _toPy = {"Args": "args"}

    def __init__(self, args=None, **unknown_fields):
        """Args : typing.Sequence[~ConfigSet]"""
        args_ = [ConfigSet.from_json(o) for o in args or []]

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, (bytes, str, list)):
            raise Exception(f"Expected args_ to be a Sequence, received: {type(args_)}")

        self.args = args_
        self.unknown_fields = unknown_fields


class ConfigValue(Type):
    _toSchema = {"source": "source", "value": "value"}
    _toPy = {"source": "source", "value": "value"}

    def __init__(self, source=None, value=None, **unknown_fields):
        """Source : str
        value : Any
        """
        source_ = source
        value_ = value

        # Validate arguments against known Juju API types.
        if source_ is not None and not isinstance(source_, (bytes, str)):
            raise Exception(f"Expected source_ to be a str, received: {type(source_)}")

        self.source = source_
        self.value = value_
        self.unknown_fields = unknown_fields


class Constraints(Type):
    _toSchema = {"count": "Count", "pool": "Pool", "size": "Size"}
    _toPy = {"Count": "count", "Pool": "pool", "Size": "size"}

    def __init__(self, count=None, pool=None, size=None, **unknown_fields):
        """Count : int
        pool : str
        size : int
        """
        count_ = count
        pool_ = pool
        size_ = size

        # Validate arguments against known Juju API types.
        if count_ is not None and not isinstance(count_, int):
            raise Exception(f"Expected count_ to be a int, received: {type(count_)}")

        if pool_ is not None and not isinstance(pool_, (bytes, str)):
            raise Exception(f"Expected pool_ to be a str, received: {type(pool_)}")

        if size_ is not None and not isinstance(size_, int):
            raise Exception(f"Expected size_ to be a int, received: {type(size_)}")

        self.count = count_
        self.pool = pool_
        self.size = size_
        self.unknown_fields = unknown_fields


class ConsumeApplicationArg(Type):
    _toSchema = {
        "application_alias": "application-alias",
        "application_description": "application-description",
        "applicationofferdetails": "ApplicationOfferDetails",
        "bindings": "bindings",
        "endpoints": "endpoints",
        "external_controller": "external-controller",
        "macaroon": "macaroon",
        "offer_name": "offer-name",
        "offer_url": "offer-url",
        "offer_uuid": "offer-uuid",
        "source_model_tag": "source-model-tag",
        "spaces": "spaces",
        "users": "users",
    }
    _toPy = {
        "ApplicationOfferDetails": "applicationofferdetails",
        "application-alias": "application_alias",
        "application-description": "application_description",
        "bindings": "bindings",
        "endpoints": "endpoints",
        "external-controller": "external_controller",
        "macaroon": "macaroon",
        "offer-name": "offer_name",
        "offer-url": "offer_url",
        "offer-uuid": "offer_uuid",
        "source-model-tag": "source_model_tag",
        "spaces": "spaces",
        "users": "users",
    }

    def __init__(
        self,
        applicationofferdetails=None,
        application_alias=None,
        application_description=None,
        bindings=None,
        endpoints=None,
        external_controller=None,
        macaroon=None,
        offer_name=None,
        offer_url=None,
        offer_uuid=None,
        source_model_tag=None,
        spaces=None,
        users=None,
        **unknown_fields,
    ):
        """Applicationofferdetails : ApplicationOfferDetails
        application_alias : str
        application_description : str
        bindings : typing.Mapping[str, str]
        endpoints : typing.Sequence[~RemoteEndpoint]
        external_controller : ExternalControllerInfo
        macaroon : Macaroon
        offer_name : str
        offer_url : str
        offer_uuid : str
        source_model_tag : str
        spaces : typing.Sequence[~RemoteSpace]
        users : typing.Sequence[~OfferUserDetails]
        """
        applicationofferdetails_ = (
            ApplicationOfferDetails.from_json(applicationofferdetails)
            if applicationofferdetails
            else None
        )
        application_alias_ = application_alias
        application_description_ = application_description
        bindings_ = bindings
        endpoints_ = [RemoteEndpoint.from_json(o) for o in endpoints or []]
        external_controller_ = (
            ExternalControllerInfo.from_json(external_controller)
            if external_controller
            else None
        )
        macaroon_ = Macaroon.from_json(macaroon) if macaroon else None
        offer_name_ = offer_name
        offer_url_ = offer_url
        offer_uuid_ = offer_uuid
        source_model_tag_ = source_model_tag
        spaces_ = [RemoteSpace.from_json(o) for o in spaces or []]
        users_ = [OfferUserDetails.from_json(o) for o in users or []]

        # Validate arguments against known Juju API types.
        if applicationofferdetails_ is not None and not isinstance(
            applicationofferdetails_, (dict, ApplicationOfferDetails)
        ):
            raise Exception(
                f"Expected applicationofferdetails_ to be a ApplicationOfferDetails, received: {type(applicationofferdetails_)}"
            )

        if application_alias_ is not None and not isinstance(
            application_alias_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_alias_ to be a str, received: {type(application_alias_)}"
            )

        if application_description_ is not None and not isinstance(
            application_description_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_description_ to be a str, received: {type(application_description_)}"
            )

        if bindings_ is not None and not isinstance(bindings_, dict):
            raise Exception(
                f"Expected bindings_ to be a Mapping, received: {type(bindings_)}"
            )

        if endpoints_ is not None and not isinstance(endpoints_, (bytes, str, list)):
            raise Exception(
                f"Expected endpoints_ to be a Sequence, received: {type(endpoints_)}"
            )

        if external_controller_ is not None and not isinstance(
            external_controller_, (dict, ExternalControllerInfo)
        ):
            raise Exception(
                f"Expected external_controller_ to be a ExternalControllerInfo, received: {type(external_controller_)}"
            )

        if macaroon_ is not None and not isinstance(macaroon_, (dict, Macaroon)):
            raise Exception(
                f"Expected macaroon_ to be a Macaroon, received: {type(macaroon_)}"
            )

        if offer_name_ is not None and not isinstance(offer_name_, (bytes, str)):
            raise Exception(
                f"Expected offer_name_ to be a str, received: {type(offer_name_)}"
            )

        if offer_url_ is not None and not isinstance(offer_url_, (bytes, str)):
            raise Exception(
                f"Expected offer_url_ to be a str, received: {type(offer_url_)}"
            )

        if offer_uuid_ is not None and not isinstance(offer_uuid_, (bytes, str)):
            raise Exception(
                f"Expected offer_uuid_ to be a str, received: {type(offer_uuid_)}"
            )

        if source_model_tag_ is not None and not isinstance(
            source_model_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected source_model_tag_ to be a str, received: {type(source_model_tag_)}"
            )

        if spaces_ is not None and not isinstance(spaces_, (bytes, str, list)):
            raise Exception(
                f"Expected spaces_ to be a Sequence, received: {type(spaces_)}"
            )

        if users_ is not None and not isinstance(users_, (bytes, str, list)):
            raise Exception(
                f"Expected users_ to be a Sequence, received: {type(users_)}"
            )

        self.applicationofferdetails = applicationofferdetails_
        self.application_alias = application_alias_
        self.application_description = application_description_
        self.bindings = bindings_
        self.endpoints = endpoints_
        self.external_controller = external_controller_
        self.macaroon = macaroon_
        self.offer_name = offer_name_
        self.offer_url = offer_url_
        self.offer_uuid = offer_uuid_
        self.source_model_tag = source_model_tag_
        self.spaces = spaces_
        self.users = users_
        self.unknown_fields = unknown_fields


class ConsumeApplicationArgV5(Type):
    _toSchema = {
        "application_alias": "application-alias",
        "application_description": "application-description",
        "applicationofferdetailsv5": "ApplicationOfferDetailsV5",
        "endpoints": "endpoints",
        "external_controller": "external-controller",
        "macaroon": "macaroon",
        "offer_name": "offer-name",
        "offer_url": "offer-url",
        "offer_uuid": "offer-uuid",
        "source_model_tag": "source-model-tag",
        "users": "users",
    }
    _toPy = {
        "ApplicationOfferDetailsV5": "applicationofferdetailsv5",
        "application-alias": "application_alias",
        "application-description": "application_description",
        "endpoints": "endpoints",
        "external-controller": "external_controller",
        "macaroon": "macaroon",
        "offer-name": "offer_name",
        "offer-url": "offer_url",
        "offer-uuid": "offer_uuid",
        "source-model-tag": "source_model_tag",
        "users": "users",
    }

    def __init__(
        self,
        applicationofferdetailsv5=None,
        application_alias=None,
        application_description=None,
        endpoints=None,
        external_controller=None,
        macaroon=None,
        offer_name=None,
        offer_url=None,
        offer_uuid=None,
        source_model_tag=None,
        users=None,
        **unknown_fields,
    ):
        """applicationofferdetailsv5 : ApplicationOfferDetailsV5
        application_alias : str
        application_description : str
        endpoints : typing.Sequence[~RemoteEndpoint]
        external_controller : ExternalControllerInfo
        macaroon : Macaroon
        offer_name : str
        offer_url : str
        offer_uuid : str
        source_model_tag : str
        users : typing.Sequence[~OfferUserDetails]
        """
        applicationofferdetailsv5_ = (
            ApplicationOfferDetailsV5.from_json(applicationofferdetailsv5)
            if applicationofferdetailsv5
            else None
        )
        application_alias_ = application_alias
        application_description_ = application_description
        endpoints_ = [RemoteEndpoint.from_json(o) for o in endpoints or []]
        external_controller_ = (
            ExternalControllerInfo.from_json(external_controller)
            if external_controller
            else None
        )
        macaroon_ = Macaroon.from_json(macaroon) if macaroon else None
        offer_name_ = offer_name
        offer_url_ = offer_url
        offer_uuid_ = offer_uuid
        source_model_tag_ = source_model_tag
        users_ = [OfferUserDetails.from_json(o) for o in users or []]

        # Validate arguments against known Juju API types.
        if applicationofferdetailsv5_ is not None and not isinstance(
            applicationofferdetailsv5_, (dict, ApplicationOfferDetailsV5)
        ):
            raise Exception(
                f"Expected applicationofferdetailsv5_ to be a ApplicationOfferDetailsV5, received: {type(applicationofferdetailsv5_)}"
            )

        if application_alias_ is not None and not isinstance(
            application_alias_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_alias_ to be a str, received: {type(application_alias_)}"
            )

        if application_description_ is not None and not isinstance(
            application_description_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_description_ to be a str, received: {type(application_description_)}"
            )

        if endpoints_ is not None and not isinstance(endpoints_, (bytes, str, list)):
            raise Exception(
                f"Expected endpoints_ to be a Sequence, received: {type(endpoints_)}"
            )

        if external_controller_ is not None and not isinstance(
            external_controller_, (dict, ExternalControllerInfo)
        ):
            raise Exception(
                f"Expected external_controller_ to be a ExternalControllerInfo, received: {type(external_controller_)}"
            )

        if macaroon_ is not None and not isinstance(macaroon_, (dict, Macaroon)):
            raise Exception(
                f"Expected macaroon_ to be a Macaroon, received: {type(macaroon_)}"
            )

        if offer_name_ is not None and not isinstance(offer_name_, (bytes, str)):
            raise Exception(
                f"Expected offer_name_ to be a str, received: {type(offer_name_)}"
            )

        if offer_url_ is not None and not isinstance(offer_url_, (bytes, str)):
            raise Exception(
                f"Expected offer_url_ to be a str, received: {type(offer_url_)}"
            )

        if offer_uuid_ is not None and not isinstance(offer_uuid_, (bytes, str)):
            raise Exception(
                f"Expected offer_uuid_ to be a str, received: {type(offer_uuid_)}"
            )

        if source_model_tag_ is not None and not isinstance(
            source_model_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected source_model_tag_ to be a str, received: {type(source_model_tag_)}"
            )

        if users_ is not None and not isinstance(users_, (bytes, str, list)):
            raise Exception(
                f"Expected users_ to be a Sequence, received: {type(users_)}"
            )

        self.applicationofferdetailsv5 = applicationofferdetailsv5_
        self.application_alias = application_alias_
        self.application_description = application_description_
        self.endpoints = endpoints_
        self.external_controller = external_controller_
        self.macaroon = macaroon_
        self.offer_name = offer_name_
        self.offer_url = offer_url_
        self.offer_uuid = offer_uuid_
        self.source_model_tag = source_model_tag_
        self.users = users_
        self.unknown_fields = unknown_fields


class ConsumeApplicationArgs(Type):
    _toSchema = {"args": "args"}
    _toPy = {"args": "args"}

    def __init__(self, args=None, **unknown_fields):
        """Args : typing.Sequence[~ConsumeApplicationArg]"""
        args_ = [ConsumeApplicationArg.from_json(o) for o in args or []]

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, (bytes, str, list)):
            raise Exception(f"Expected args_ to be a Sequence, received: {type(args_)}")

        self.args = args_
        self.unknown_fields = unknown_fields


class ConsumeApplicationArgsV5(Type):
    _toSchema = {"args": "args"}
    _toPy = {"args": "args"}

    def __init__(self, args=None, **unknown_fields):
        """Args : typing.Sequence[~ConsumeApplicationArgV5]"""
        args_ = [ConsumeApplicationArgV5.from_json(o) for o in args or []]

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, (bytes, str, list)):
            raise Exception(f"Expected args_ to be a Sequence, received: {type(args_)}")

        self.args = args_
        self.unknown_fields = unknown_fields


class ConsumeOfferDetails(Type):
    _toSchema = {
        "external_controller": "external-controller",
        "macaroon": "macaroon",
        "offer": "offer",
    }
    _toPy = {
        "external-controller": "external_controller",
        "macaroon": "macaroon",
        "offer": "offer",
    }

    def __init__(
        self, external_controller=None, macaroon=None, offer=None, **unknown_fields
    ):
        """external_controller : ExternalControllerInfo
        macaroon : Macaroon
        offer : ApplicationOfferDetailsV5
        """
        external_controller_ = (
            ExternalControllerInfo.from_json(external_controller)
            if external_controller
            else None
        )
        macaroon_ = Macaroon.from_json(macaroon) if macaroon else None
        offer_ = ApplicationOfferDetailsV5.from_json(offer) if offer else None

        # Validate arguments against known Juju API types.
        if external_controller_ is not None and not isinstance(
            external_controller_, (dict, ExternalControllerInfo)
        ):
            raise Exception(
                f"Expected external_controller_ to be a ExternalControllerInfo, received: {type(external_controller_)}"
            )

        if macaroon_ is not None and not isinstance(macaroon_, (dict, Macaroon)):
            raise Exception(
                f"Expected macaroon_ to be a Macaroon, received: {type(macaroon_)}"
            )

        if offer_ is not None and not isinstance(
            offer_, (dict, ApplicationOfferDetailsV5)
        ):
            raise Exception(
                f"Expected offer_ to be a ApplicationOfferDetailsV5, received: {type(offer_)}"
            )

        self.external_controller = external_controller_
        self.macaroon = macaroon_
        self.offer = offer_
        self.unknown_fields = unknown_fields


class ConsumeOfferDetailsArg(Type):
    _toSchema = {"offer_urls": "offer-urls", "user_tag": "user-tag"}
    _toPy = {"offer-urls": "offer_urls", "user-tag": "user_tag"}

    def __init__(self, offer_urls=None, user_tag=None, **unknown_fields):
        """offer_urls : OfferURLs
        user_tag : str
        """
        offer_urls_ = OfferURLs.from_json(offer_urls) if offer_urls else None
        user_tag_ = user_tag

        # Validate arguments against known Juju API types.
        if offer_urls_ is not None and not isinstance(offer_urls_, (dict, OfferURLs)):
            raise Exception(
                f"Expected offer_urls_ to be a OfferURLs, received: {type(offer_urls_)}"
            )

        if user_tag_ is not None and not isinstance(user_tag_, (bytes, str)):
            raise Exception(
                f"Expected user_tag_ to be a str, received: {type(user_tag_)}"
            )

        self.offer_urls = offer_urls_
        self.user_tag = user_tag_
        self.unknown_fields = unknown_fields


class ConsumeOfferDetailsResult(Type):
    _toSchema = {
        "consumeofferdetails": "ConsumeOfferDetails",
        "error": "error",
        "external_controller": "external-controller",
        "macaroon": "macaroon",
        "offer": "offer",
    }
    _toPy = {
        "ConsumeOfferDetails": "consumeofferdetails",
        "error": "error",
        "external-controller": "external_controller",
        "macaroon": "macaroon",
        "offer": "offer",
    }

    def __init__(
        self,
        consumeofferdetails=None,
        error=None,
        external_controller=None,
        macaroon=None,
        offer=None,
        **unknown_fields,
    ):
        """Consumeofferdetails : ConsumeOfferDetails
        error : Error
        external_controller : ExternalControllerInfo
        macaroon : Macaroon
        offer : ApplicationOfferDetailsV5
        """
        consumeofferdetails_ = (
            ConsumeOfferDetails.from_json(consumeofferdetails)
            if consumeofferdetails
            else None
        )
        error_ = Error.from_json(error) if error else None
        external_controller_ = (
            ExternalControllerInfo.from_json(external_controller)
            if external_controller
            else None
        )
        macaroon_ = Macaroon.from_json(macaroon) if macaroon else None
        offer_ = ApplicationOfferDetailsV5.from_json(offer) if offer else None

        # Validate arguments against known Juju API types.
        if consumeofferdetails_ is not None and not isinstance(
            consumeofferdetails_, (dict, ConsumeOfferDetails)
        ):
            raise Exception(
                f"Expected consumeofferdetails_ to be a ConsumeOfferDetails, received: {type(consumeofferdetails_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if external_controller_ is not None and not isinstance(
            external_controller_, (dict, ExternalControllerInfo)
        ):
            raise Exception(
                f"Expected external_controller_ to be a ExternalControllerInfo, received: {type(external_controller_)}"
            )

        if macaroon_ is not None and not isinstance(macaroon_, (dict, Macaroon)):
            raise Exception(
                f"Expected macaroon_ to be a Macaroon, received: {type(macaroon_)}"
            )

        if offer_ is not None and not isinstance(
            offer_, (dict, ApplicationOfferDetailsV5)
        ):
            raise Exception(
                f"Expected offer_ to be a ApplicationOfferDetailsV5, received: {type(offer_)}"
            )

        self.consumeofferdetails = consumeofferdetails_
        self.error = error_
        self.external_controller = external_controller_
        self.macaroon = macaroon_
        self.offer = offer_
        self.unknown_fields = unknown_fields


class ConsumeOfferDetailsResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ConsumeOfferDetailsResult]"""
        results_ = [ConsumeOfferDetailsResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ControllerAPIInfoResult(Type):
    _toSchema = {"addresses": "addresses", "cacert": "cacert", "error": "error"}
    _toPy = {"addresses": "addresses", "cacert": "cacert", "error": "error"}

    def __init__(self, addresses=None, cacert=None, error=None, **unknown_fields):
        """Addresses : typing.Sequence[str]
        cacert : str
        error : Error
        """
        addresses_ = addresses
        cacert_ = cacert
        error_ = Error.from_json(error) if error else None

        # Validate arguments against known Juju API types.
        if addresses_ is not None and not isinstance(addresses_, (bytes, str, list)):
            raise Exception(
                f"Expected addresses_ to be a Sequence, received: {type(addresses_)}"
            )

        if cacert_ is not None and not isinstance(cacert_, (bytes, str)):
            raise Exception(f"Expected cacert_ to be a str, received: {type(cacert_)}")

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        self.addresses = addresses_
        self.cacert = cacert_
        self.error = error_
        self.unknown_fields = unknown_fields


class ControllerAPIInfoResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ControllerAPIInfoResult]"""
        results_ = [ControllerAPIInfoResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ControllerConfigResult(Type):
    _toSchema = {"config": "config"}
    _toPy = {"config": "config"}

    def __init__(self, config=None, **unknown_fields):
        """Config : typing.Mapping[str, typing.Any]"""
        config_ = config

        # Validate arguments against known Juju API types.
        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        self.config = config_
        self.unknown_fields = unknown_fields


class ControllerConfigSet(Type):
    _toSchema = {"config": "config"}
    _toPy = {"config": "config"}

    def __init__(self, config=None, **unknown_fields):
        """Config : typing.Mapping[str, typing.Any]"""
        config_ = config

        # Validate arguments against known Juju API types.
        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        self.config = config_
        self.unknown_fields = unknown_fields


class ControllerCredentialInfo(Type):
    _toSchema = {"content": "content", "models": "models"}
    _toPy = {"content": "content", "models": "models"}

    def __init__(self, content=None, models=None, **unknown_fields):
        """Content : CredentialContent
        models : typing.Sequence[~ModelAccess]
        """
        content_ = CredentialContent.from_json(content) if content else None
        models_ = [ModelAccess.from_json(o) for o in models or []]

        # Validate arguments against known Juju API types.
        if content_ is not None and not isinstance(content_, (dict, CredentialContent)):
            raise Exception(
                f"Expected content_ to be a CredentialContent, received: {type(content_)}"
            )

        if models_ is not None and not isinstance(models_, (bytes, str, list)):
            raise Exception(
                f"Expected models_ to be a Sequence, received: {type(models_)}"
            )

        self.content = content_
        self.models = models_
        self.unknown_fields = unknown_fields


class ControllerVersionResults(Type):
    _toSchema = {"git_commit": "git-commit", "version": "version"}
    _toPy = {"git-commit": "git_commit", "version": "version"}

    def __init__(self, git_commit=None, version=None, **unknown_fields):
        """git_commit : str
        version : str
        """
        git_commit_ = git_commit
        version_ = version

        # Validate arguments against known Juju API types.
        if git_commit_ is not None and not isinstance(git_commit_, (bytes, str)):
            raise Exception(
                f"Expected git_commit_ to be a str, received: {type(git_commit_)}"
            )

        if version_ is not None and not isinstance(version_, (bytes, str)):
            raise Exception(
                f"Expected version_ to be a str, received: {type(version_)}"
            )

        self.git_commit = git_commit_
        self.version = version_
        self.unknown_fields = unknown_fields


class ControllersChangeResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : ControllersChanges
        """
        error_ = Error.from_json(error) if error else None
        result_ = ControllersChanges.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (dict, ControllersChanges)):
            raise Exception(
                f"Expected result_ to be a ControllersChanges, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class ControllersChangeResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ControllersChangeResult]"""
        results_ = [ControllersChangeResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ControllersChanges(Type):
    _toSchema = {
        "added": "added",
        "converted": "converted",
        "maintained": "maintained",
        "removed": "removed",
    }
    _toPy = {
        "added": "added",
        "converted": "converted",
        "maintained": "maintained",
        "removed": "removed",
    }

    def __init__(
        self,
        added=None,
        converted=None,
        maintained=None,
        removed=None,
        **unknown_fields,
    ):
        """Added : typing.Sequence[str]
        converted : typing.Sequence[str]
        maintained : typing.Sequence[str]
        removed : typing.Sequence[str]
        """
        added_ = added
        converted_ = converted
        maintained_ = maintained
        removed_ = removed

        # Validate arguments against known Juju API types.
        if added_ is not None and not isinstance(added_, (bytes, str, list)):
            raise Exception(
                f"Expected added_ to be a Sequence, received: {type(added_)}"
            )

        if converted_ is not None and not isinstance(converted_, (bytes, str, list)):
            raise Exception(
                f"Expected converted_ to be a Sequence, received: {type(converted_)}"
            )

        if maintained_ is not None and not isinstance(maintained_, (bytes, str, list)):
            raise Exception(
                f"Expected maintained_ to be a Sequence, received: {type(maintained_)}"
            )

        if removed_ is not None and not isinstance(removed_, (bytes, str, list)):
            raise Exception(
                f"Expected removed_ to be a Sequence, received: {type(removed_)}"
            )

        self.added = added_
        self.converted = converted_
        self.maintained = maintained_
        self.removed = removed_
        self.unknown_fields = unknown_fields


class ControllersSpec(Type):
    _toSchema = {
        "constraints": "constraints",
        "num_controllers": "num-controllers",
        "placement": "placement",
    }
    _toPy = {
        "constraints": "constraints",
        "num-controllers": "num_controllers",
        "placement": "placement",
    }

    def __init__(
        self, constraints=None, num_controllers=None, placement=None, **unknown_fields
    ):
        """Constraints : Value
        num_controllers : int
        placement : typing.Sequence[str]
        """
        constraints_ = Value.from_json(constraints) if constraints else None
        num_controllers_ = num_controllers
        placement_ = placement

        # Validate arguments against known Juju API types.
        if constraints_ is not None and not isinstance(constraints_, (dict, Value)):
            raise Exception(
                f"Expected constraints_ to be a Value, received: {type(constraints_)}"
            )

        if num_controllers_ is not None and not isinstance(num_controllers_, int):
            raise Exception(
                f"Expected num_controllers_ to be a int, received: {type(num_controllers_)}"
            )

        if placement_ is not None and not isinstance(placement_, (bytes, str, list)):
            raise Exception(
                f"Expected placement_ to be a Sequence, received: {type(placement_)}"
            )

        self.constraints = constraints_
        self.num_controllers = num_controllers_
        self.placement = placement_
        self.unknown_fields = unknown_fields


class ControllersSpecs(Type):
    _toSchema = {"specs": "specs"}
    _toPy = {"specs": "specs"}

    def __init__(self, specs=None, **unknown_fields):
        """Specs : typing.Sequence[~ControllersSpec]"""
        specs_ = [ControllersSpec.from_json(o) for o in specs or []]

        # Validate arguments against known Juju API types.
        if specs_ is not None and not isinstance(specs_, (bytes, str, list)):
            raise Exception(
                f"Expected specs_ to be a Sequence, received: {type(specs_)}"
            )

        self.specs = specs_
        self.unknown_fields = unknown_fields


class CreateSecretArg(Type):
    _toSchema = {
        "content": "content",
        "description": "description",
        "expire_time": "expire-time",
        "label": "label",
        "owner_tag": "owner-tag",
        "params": "params",
        "rotate_policy": "rotate-policy",
        "upsertsecretarg": "UpsertSecretArg",
        "uri": "uri",
    }
    _toPy = {
        "UpsertSecretArg": "upsertsecretarg",
        "content": "content",
        "description": "description",
        "expire-time": "expire_time",
        "label": "label",
        "owner-tag": "owner_tag",
        "params": "params",
        "rotate-policy": "rotate_policy",
        "uri": "uri",
    }

    def __init__(
        self,
        upsertsecretarg=None,
        content=None,
        description=None,
        expire_time=None,
        label=None,
        owner_tag=None,
        params=None,
        rotate_policy=None,
        uri=None,
        **unknown_fields,
    ):
        """Upsertsecretarg : UpsertSecretArg
        content : SecretContentParams
        description : str
        expire_time : str
        label : str
        owner_tag : str
        params : typing.Mapping[str, typing.Any]
        rotate_policy : str
        uri : str
        """
        upsertsecretarg_ = (
            UpsertSecretArg.from_json(upsertsecretarg) if upsertsecretarg else None
        )
        content_ = SecretContentParams.from_json(content) if content else None
        description_ = description
        expire_time_ = expire_time
        label_ = label
        owner_tag_ = owner_tag
        params_ = params
        rotate_policy_ = rotate_policy
        uri_ = uri

        # Validate arguments against known Juju API types.
        if upsertsecretarg_ is not None and not isinstance(
            upsertsecretarg_, (dict, UpsertSecretArg)
        ):
            raise Exception(
                f"Expected upsertsecretarg_ to be a UpsertSecretArg, received: {type(upsertsecretarg_)}"
            )

        if content_ is not None and not isinstance(
            content_, (dict, SecretContentParams)
        ):
            raise Exception(
                f"Expected content_ to be a SecretContentParams, received: {type(content_)}"
            )

        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if expire_time_ is not None and not isinstance(expire_time_, (bytes, str)):
            raise Exception(
                f"Expected expire_time_ to be a str, received: {type(expire_time_)}"
            )

        if label_ is not None and not isinstance(label_, (bytes, str)):
            raise Exception(f"Expected label_ to be a str, received: {type(label_)}")

        if owner_tag_ is not None and not isinstance(owner_tag_, (bytes, str)):
            raise Exception(
                f"Expected owner_tag_ to be a str, received: {type(owner_tag_)}"
            )

        if params_ is not None and not isinstance(params_, dict):
            raise Exception(
                f"Expected params_ to be a Mapping, received: {type(params_)}"
            )

        if rotate_policy_ is not None and not isinstance(rotate_policy_, (bytes, str)):
            raise Exception(
                f"Expected rotate_policy_ to be a str, received: {type(rotate_policy_)}"
            )

        if uri_ is not None and not isinstance(uri_, (bytes, str)):
            raise Exception(f"Expected uri_ to be a str, received: {type(uri_)}")

        self.upsertsecretarg = upsertsecretarg_
        self.content = content_
        self.description = description_
        self.expire_time = expire_time_
        self.label = label_
        self.owner_tag = owner_tag_
        self.params = params_
        self.rotate_policy = rotate_policy_
        self.uri = uri_
        self.unknown_fields = unknown_fields


class CreateSecretArgs(Type):
    _toSchema = {"args": "args"}
    _toPy = {"args": "args"}

    def __init__(self, args=None, **unknown_fields):
        """Args : typing.Sequence[~CreateSecretArg]"""
        args_ = [CreateSecretArg.from_json(o) for o in args or []]

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, (bytes, str, list)):
            raise Exception(f"Expected args_ to be a Sequence, received: {type(args_)}")

        self.args = args_
        self.unknown_fields = unknown_fields


class CreateSpaceParams(Type):
    _toSchema = {
        "cidrs": "cidrs",
        "provider_id": "provider-id",
        "public": "public",
        "space_tag": "space-tag",
    }
    _toPy = {
        "cidrs": "cidrs",
        "provider-id": "provider_id",
        "public": "public",
        "space-tag": "space_tag",
    }

    def __init__(
        self,
        cidrs=None,
        provider_id=None,
        public=None,
        space_tag=None,
        **unknown_fields,
    ):
        """Cidrs : typing.Sequence[str]
        provider_id : str
        public : bool
        space_tag : str
        """
        cidrs_ = cidrs
        provider_id_ = provider_id
        public_ = public
        space_tag_ = space_tag

        # Validate arguments against known Juju API types.
        if cidrs_ is not None and not isinstance(cidrs_, (bytes, str, list)):
            raise Exception(
                f"Expected cidrs_ to be a Sequence, received: {type(cidrs_)}"
            )

        if provider_id_ is not None and not isinstance(provider_id_, (bytes, str)):
            raise Exception(
                f"Expected provider_id_ to be a str, received: {type(provider_id_)}"
            )

        if public_ is not None and not isinstance(public_, bool):
            raise Exception(f"Expected public_ to be a bool, received: {type(public_)}")

        if space_tag_ is not None and not isinstance(space_tag_, (bytes, str)):
            raise Exception(
                f"Expected space_tag_ to be a str, received: {type(space_tag_)}"
            )

        self.cidrs = cidrs_
        self.provider_id = provider_id_
        self.public = public_
        self.space_tag = space_tag_
        self.unknown_fields = unknown_fields


class CreateSpacesParams(Type):
    _toSchema = {"spaces": "spaces"}
    _toPy = {"spaces": "spaces"}

    def __init__(self, spaces=None, **unknown_fields):
        """Spaces : typing.Sequence[~CreateSpaceParams]"""
        spaces_ = [CreateSpaceParams.from_json(o) for o in spaces or []]

        # Validate arguments against known Juju API types.
        if spaces_ is not None and not isinstance(spaces_, (bytes, str, list)):
            raise Exception(
                f"Expected spaces_ to be a Sequence, received: {type(spaces_)}"
            )

        self.spaces = spaces_
        self.unknown_fields = unknown_fields


class CredentialContent(Type):
    _toSchema = {
        "attrs": "attrs",
        "auth_type": "auth-type",
        "cloud": "cloud",
        "name": "name",
        "valid": "valid",
    }
    _toPy = {
        "attrs": "attrs",
        "auth-type": "auth_type",
        "cloud": "cloud",
        "name": "name",
        "valid": "valid",
    }

    def __init__(
        self,
        attrs=None,
        auth_type=None,
        cloud=None,
        name=None,
        valid=None,
        **unknown_fields,
    ):
        """Attrs : typing.Mapping[str, str]
        auth_type : str
        cloud : str
        name : str
        valid : bool
        """
        attrs_ = attrs
        auth_type_ = auth_type
        cloud_ = cloud
        name_ = name
        valid_ = valid

        # Validate arguments against known Juju API types.
        if attrs_ is not None and not isinstance(attrs_, dict):
            raise Exception(
                f"Expected attrs_ to be a Mapping, received: {type(attrs_)}"
            )

        if auth_type_ is not None and not isinstance(auth_type_, (bytes, str)):
            raise Exception(
                f"Expected auth_type_ to be a str, received: {type(auth_type_)}"
            )

        if cloud_ is not None and not isinstance(cloud_, (bytes, str)):
            raise Exception(f"Expected cloud_ to be a str, received: {type(cloud_)}")

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if valid_ is not None and not isinstance(valid_, bool):
            raise Exception(f"Expected valid_ to be a bool, received: {type(valid_)}")

        self.attrs = attrs_
        self.auth_type = auth_type_
        self.cloud = cloud_
        self.name = name_
        self.valid = valid_
        self.unknown_fields = unknown_fields


class CredentialContentResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : ControllerCredentialInfo
        """
        error_ = Error.from_json(error) if error else None
        result_ = ControllerCredentialInfo.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(
            result_, (dict, ControllerCredentialInfo)
        ):
            raise Exception(
                f"Expected result_ to be a ControllerCredentialInfo, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class CredentialContentResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~CredentialContentResult]"""
        results_ = [CredentialContentResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class DashboardConnectionInfo(Type):
    _toSchema = {
        "error": "error",
        "proxy_connection": "proxy-connection",
        "ssh_connection": "ssh-connection",
    }
    _toPy = {
        "error": "error",
        "proxy-connection": "proxy_connection",
        "ssh-connection": "ssh_connection",
    }

    def __init__(
        self, error=None, proxy_connection=None, ssh_connection=None, **unknown_fields
    ):
        """Error : Error
        proxy_connection : Proxy
        ssh_connection : DashboardConnectionSSHTunnel
        """
        error_ = Error.from_json(error) if error else None
        proxy_connection_ = (
            Proxy.from_json(proxy_connection) if proxy_connection else None
        )
        ssh_connection_ = (
            DashboardConnectionSSHTunnel.from_json(ssh_connection)
            if ssh_connection
            else None
        )

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if proxy_connection_ is not None and not isinstance(
            proxy_connection_, (dict, Proxy)
        ):
            raise Exception(
                f"Expected proxy_connection_ to be a Proxy, received: {type(proxy_connection_)}"
            )

        if ssh_connection_ is not None and not isinstance(
            ssh_connection_, (dict, DashboardConnectionSSHTunnel)
        ):
            raise Exception(
                f"Expected ssh_connection_ to be a DashboardConnectionSSHTunnel, received: {type(ssh_connection_)}"
            )

        self.error = error_
        self.proxy_connection = proxy_connection_
        self.ssh_connection = ssh_connection_
        self.unknown_fields = unknown_fields


class DashboardConnectionSSHTunnel(Type):
    _toSchema = {"entity": "entity", "host": "host", "model": "model", "port": "port"}
    _toPy = {"entity": "entity", "host": "host", "model": "model", "port": "port"}

    def __init__(self, entity=None, host=None, model=None, port=None, **unknown_fields):
        """Entity : str
        host : str
        model : str
        port : str
        """
        entity_ = entity
        host_ = host
        model_ = model
        port_ = port

        # Validate arguments against known Juju API types.
        if entity_ is not None and not isinstance(entity_, (bytes, str)):
            raise Exception(f"Expected entity_ to be a str, received: {type(entity_)}")

        if host_ is not None and not isinstance(host_, (bytes, str)):
            raise Exception(f"Expected host_ to be a str, received: {type(host_)}")

        if model_ is not None and not isinstance(model_, (bytes, str)):
            raise Exception(f"Expected model_ to be a str, received: {type(model_)}")

        if port_ is not None and not isinstance(port_, (bytes, str)):
            raise Exception(f"Expected port_ to be a str, received: {type(port_)}")

        self.entity = entity_
        self.host = host_
        self.model = model_
        self.port = port_
        self.unknown_fields = unknown_fields


class DeleteSecretArg(Type):
    _toSchema = {"label": "label", "revisions": "revisions", "uri": "uri"}
    _toPy = {"label": "label", "revisions": "revisions", "uri": "uri"}

    def __init__(self, label=None, revisions=None, uri=None, **unknown_fields):
        """Label : str
        revisions : typing.Sequence[int]
        uri : str
        """
        label_ = label
        revisions_ = revisions
        uri_ = uri

        # Validate arguments against known Juju API types.
        if label_ is not None and not isinstance(label_, (bytes, str)):
            raise Exception(f"Expected label_ to be a str, received: {type(label_)}")

        if revisions_ is not None and not isinstance(revisions_, (bytes, str, list)):
            raise Exception(
                f"Expected revisions_ to be a Sequence, received: {type(revisions_)}"
            )

        if uri_ is not None and not isinstance(uri_, (bytes, str)):
            raise Exception(f"Expected uri_ to be a str, received: {type(uri_)}")

        self.label = label_
        self.revisions = revisions_
        self.uri = uri_
        self.unknown_fields = unknown_fields


class DeleteSecretArgs(Type):
    _toSchema = {"args": "args"}
    _toPy = {"args": "args"}

    def __init__(self, args=None, **unknown_fields):
        """Args : typing.Sequence[~DeleteSecretArg]"""
        args_ = [DeleteSecretArg.from_json(o) for o in args or []]

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, (bytes, str, list)):
            raise Exception(f"Expected args_ to be a Sequence, received: {type(args_)}")

        self.args = args_
        self.unknown_fields = unknown_fields


class Delta(Type):
    _toSchema = {"entity": "entity", "removed": "removed"}
    _toPy = {"entity": "entity", "removed": "removed"}

    def __init__(self, entity=None, removed=None, **unknown_fields):
        """Entity : Any
        removed : bool
        """
        entity_ = entity
        removed_ = removed

        # Validate arguments against known Juju API types.
        if removed_ is not None and not isinstance(removed_, bool):
            raise Exception(
                f"Expected removed_ to be a bool, received: {type(removed_)}"
            )

        self.entity = entity_
        self.removed = removed_
        self.unknown_fields = unknown_fields


class DeployFromRepositoryArg(Type):
    _toSchema = {
        "applicationname": "ApplicationName",
        "attachstorage": "AttachStorage",
        "base": "base",
        "channel": "channel",
        "charmname": "CharmName",
        "configyaml": "ConfigYAML",
        "cons": "Cons",
        "devices": "Devices",
        "dryrun": "DryRun",
        "endpoint_bindings": "endpoint-bindings",
        "force": "force",
        "num_units": "num-units",
        "placement": "Placement",
        "resources": "resources",
        "revision": "revision",
        "storage": "Storage",
        "trust": "Trust",
    }
    _toPy = {
        "ApplicationName": "applicationname",
        "AttachStorage": "attachstorage",
        "CharmName": "charmname",
        "ConfigYAML": "configyaml",
        "Cons": "cons",
        "Devices": "devices",
        "DryRun": "dryrun",
        "Placement": "placement",
        "Storage": "storage",
        "Trust": "trust",
        "base": "base",
        "channel": "channel",
        "endpoint-bindings": "endpoint_bindings",
        "force": "force",
        "num-units": "num_units",
        "resources": "resources",
        "revision": "revision",
    }

    def __init__(
        self,
        applicationname=None,
        attachstorage=None,
        charmname=None,
        configyaml=None,
        cons=None,
        devices=None,
        dryrun=None,
        placement=None,
        storage=None,
        trust=None,
        base=None,
        channel=None,
        endpoint_bindings=None,
        force=None,
        num_units=None,
        resources=None,
        revision=None,
        **unknown_fields,
    ):
        """Applicationname : str
        attachstorage : typing.Sequence[str]
        charmname : str
        configyaml : str
        cons : Value
        devices : typing.Mapping[str, ~Constraints]
        dryrun : bool
        placement : typing.Sequence[~Placement]
        storage : typing.Mapping[str, ~Constraints]
        trust : bool
        base : Base
        channel : str
        endpoint_bindings : typing.Mapping[str, str]
        force : bool
        num_units : int
        resources : typing.Mapping[str, str]
        revision : int
        """
        applicationname_ = applicationname
        attachstorage_ = attachstorage
        charmname_ = charmname
        configyaml_ = configyaml
        cons_ = Value.from_json(cons) if cons else None
        devices_ = {k: Constraints.from_json(v) for k, v in (devices or dict()).items()}
        dryrun_ = dryrun
        placement_ = [Placement.from_json(o) for o in placement or []]
        storage_ = {k: Constraints.from_json(v) for k, v in (storage or dict()).items()}
        trust_ = trust
        base_ = Base.from_json(base) if base else None
        channel_ = channel
        endpoint_bindings_ = endpoint_bindings
        force_ = force
        num_units_ = num_units
        resources_ = resources
        revision_ = revision

        # Validate arguments against known Juju API types.
        if applicationname_ is not None and not isinstance(
            applicationname_, (bytes, str)
        ):
            raise Exception(
                f"Expected applicationname_ to be a str, received: {type(applicationname_)}"
            )

        if attachstorage_ is not None and not isinstance(
            attachstorage_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected attachstorage_ to be a Sequence, received: {type(attachstorage_)}"
            )

        if charmname_ is not None and not isinstance(charmname_, (bytes, str)):
            raise Exception(
                f"Expected charmname_ to be a str, received: {type(charmname_)}"
            )

        if configyaml_ is not None and not isinstance(configyaml_, (bytes, str)):
            raise Exception(
                f"Expected configyaml_ to be a str, received: {type(configyaml_)}"
            )

        if cons_ is not None and not isinstance(cons_, (dict, Value)):
            raise Exception(f"Expected cons_ to be a Value, received: {type(cons_)}")

        if devices_ is not None and not isinstance(devices_, dict):
            raise Exception(
                f"Expected devices_ to be a Mapping, received: {type(devices_)}"
            )

        if dryrun_ is not None and not isinstance(dryrun_, bool):
            raise Exception(f"Expected dryrun_ to be a bool, received: {type(dryrun_)}")

        if placement_ is not None and not isinstance(placement_, (bytes, str, list)):
            raise Exception(
                f"Expected placement_ to be a Sequence, received: {type(placement_)}"
            )

        if storage_ is not None and not isinstance(storage_, dict):
            raise Exception(
                f"Expected storage_ to be a Mapping, received: {type(storage_)}"
            )

        if trust_ is not None and not isinstance(trust_, bool):
            raise Exception(f"Expected trust_ to be a bool, received: {type(trust_)}")

        if base_ is not None and not isinstance(base_, (dict, Base)):
            raise Exception(f"Expected base_ to be a Base, received: {type(base_)}")

        if channel_ is not None and not isinstance(channel_, (bytes, str)):
            raise Exception(
                f"Expected channel_ to be a str, received: {type(channel_)}"
            )

        if endpoint_bindings_ is not None and not isinstance(endpoint_bindings_, dict):
            raise Exception(
                f"Expected endpoint_bindings_ to be a Mapping, received: {type(endpoint_bindings_)}"
            )

        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if num_units_ is not None and not isinstance(num_units_, int):
            raise Exception(
                f"Expected num_units_ to be a int, received: {type(num_units_)}"
            )

        if resources_ is not None and not isinstance(resources_, dict):
            raise Exception(
                f"Expected resources_ to be a Mapping, received: {type(resources_)}"
            )

        if revision_ is not None and not isinstance(revision_, int):
            raise Exception(
                f"Expected revision_ to be a int, received: {type(revision_)}"
            )

        self.applicationname = applicationname_
        self.attachstorage = attachstorage_
        self.charmname = charmname_
        self.configyaml = configyaml_
        self.cons = cons_
        self.devices = devices_
        self.dryrun = dryrun_
        self.placement = placement_
        self.storage = storage_
        self.trust = trust_
        self.base = base_
        self.channel = channel_
        self.endpoint_bindings = endpoint_bindings_
        self.force = force_
        self.num_units = num_units_
        self.resources = resources_
        self.revision = revision_
        self.unknown_fields = unknown_fields


class DeployFromRepositoryArgs(Type):
    _toSchema = {"args": "Args"}
    _toPy = {"Args": "args"}

    def __init__(self, args=None, **unknown_fields):
        """Args : typing.Sequence[~DeployFromRepositoryArg]"""
        args_ = [DeployFromRepositoryArg.from_json(o) for o in args or []]

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, (bytes, str, list)):
            raise Exception(f"Expected args_ to be a Sequence, received: {type(args_)}")

        self.args = args_
        self.unknown_fields = unknown_fields


class DeployFromRepositoryInfo(Type):
    _toSchema = {
        "architecture": "architecture",
        "base": "base",
        "channel": "channel",
        "effective_channel": "effective-channel",
        "name": "name",
        "revision": "revision",
    }
    _toPy = {
        "architecture": "architecture",
        "base": "base",
        "channel": "channel",
        "effective-channel": "effective_channel",
        "name": "name",
        "revision": "revision",
    }

    def __init__(
        self,
        architecture=None,
        base=None,
        channel=None,
        effective_channel=None,
        name=None,
        revision=None,
        **unknown_fields,
    ):
        """Architecture : str
        base : Base
        channel : str
        effective_channel : str
        name : str
        revision : int
        """
        architecture_ = architecture
        base_ = Base.from_json(base) if base else None
        channel_ = channel
        effective_channel_ = effective_channel
        name_ = name
        revision_ = revision

        # Validate arguments against known Juju API types.
        if architecture_ is not None and not isinstance(architecture_, (bytes, str)):
            raise Exception(
                f"Expected architecture_ to be a str, received: {type(architecture_)}"
            )

        if base_ is not None and not isinstance(base_, (dict, Base)):
            raise Exception(f"Expected base_ to be a Base, received: {type(base_)}")

        if channel_ is not None and not isinstance(channel_, (bytes, str)):
            raise Exception(
                f"Expected channel_ to be a str, received: {type(channel_)}"
            )

        if effective_channel_ is not None and not isinstance(
            effective_channel_, (bytes, str)
        ):
            raise Exception(
                f"Expected effective_channel_ to be a str, received: {type(effective_channel_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if revision_ is not None and not isinstance(revision_, int):
            raise Exception(
                f"Expected revision_ to be a int, received: {type(revision_)}"
            )

        self.architecture = architecture_
        self.base = base_
        self.channel = channel_
        self.effective_channel = effective_channel_
        self.name = name_
        self.revision = revision_
        self.unknown_fields = unknown_fields


class DeployFromRepositoryResult(Type):
    _toSchema = {
        "errors": "Errors",
        "info": "Info",
        "pendingresourceuploads": "PendingResourceUploads",
    }
    _toPy = {
        "Errors": "errors",
        "Info": "info",
        "PendingResourceUploads": "pendingresourceuploads",
    }

    def __init__(
        self, errors=None, info=None, pendingresourceuploads=None, **unknown_fields
    ):
        """Errors : typing.Sequence[~Error]
        info : DeployFromRepositoryInfo
        pendingresourceuploads : typing.Sequence[~PendingResourceUpload]
        """
        errors_ = [Error.from_json(o) for o in errors or []]
        info_ = DeployFromRepositoryInfo.from_json(info) if info else None
        pendingresourceuploads_ = [
            PendingResourceUpload.from_json(o) for o in pendingresourceuploads or []
        ]

        # Validate arguments against known Juju API types.
        if errors_ is not None and not isinstance(errors_, (bytes, str, list)):
            raise Exception(
                f"Expected errors_ to be a Sequence, received: {type(errors_)}"
            )

        if info_ is not None and not isinstance(
            info_, (dict, DeployFromRepositoryInfo)
        ):
            raise Exception(
                f"Expected info_ to be a DeployFromRepositoryInfo, received: {type(info_)}"
            )

        if pendingresourceuploads_ is not None and not isinstance(
            pendingresourceuploads_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected pendingresourceuploads_ to be a Sequence, received: {type(pendingresourceuploads_)}"
            )

        self.errors = errors_
        self.info = info_
        self.pendingresourceuploads = pendingresourceuploads_
        self.unknown_fields = unknown_fields


class DeployFromRepositoryResults(Type):
    _toSchema = {"results": "Results"}
    _toPy = {"Results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~DeployFromRepositoryResult]"""
        results_ = [DeployFromRepositoryResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class DestroyApplicationInfo(Type):
    _toSchema = {
        "destroyed_storage": "destroyed-storage",
        "destroyed_units": "destroyed-units",
        "detached_storage": "detached-storage",
    }
    _toPy = {
        "destroyed-storage": "destroyed_storage",
        "destroyed-units": "destroyed_units",
        "detached-storage": "detached_storage",
    }

    def __init__(
        self,
        destroyed_storage=None,
        destroyed_units=None,
        detached_storage=None,
        **unknown_fields,
    ):
        """destroyed_storage : typing.Sequence[~Entity]
        destroyed_units : typing.Sequence[~Entity]
        detached_storage : typing.Sequence[~Entity]
        """
        destroyed_storage_ = [Entity.from_json(o) for o in destroyed_storage or []]
        destroyed_units_ = [Entity.from_json(o) for o in destroyed_units or []]
        detached_storage_ = [Entity.from_json(o) for o in detached_storage or []]

        # Validate arguments against known Juju API types.
        if destroyed_storage_ is not None and not isinstance(
            destroyed_storage_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected destroyed_storage_ to be a Sequence, received: {type(destroyed_storage_)}"
            )

        if destroyed_units_ is not None and not isinstance(
            destroyed_units_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected destroyed_units_ to be a Sequence, received: {type(destroyed_units_)}"
            )

        if detached_storage_ is not None and not isinstance(
            detached_storage_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected detached_storage_ to be a Sequence, received: {type(detached_storage_)}"
            )

        self.destroyed_storage = destroyed_storage_
        self.destroyed_units = destroyed_units_
        self.detached_storage = detached_storage_
        self.unknown_fields = unknown_fields


class DestroyApplicationOffers(Type):
    _toSchema = {"force": "force", "offer_urls": "offer-urls"}
    _toPy = {"force": "force", "offer-urls": "offer_urls"}

    def __init__(self, force=None, offer_urls=None, **unknown_fields):
        """Force : bool
        offer_urls : typing.Sequence[str]
        """
        force_ = force
        offer_urls_ = offer_urls

        # Validate arguments against known Juju API types.
        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if offer_urls_ is not None and not isinstance(offer_urls_, (bytes, str, list)):
            raise Exception(
                f"Expected offer_urls_ to be a Sequence, received: {type(offer_urls_)}"
            )

        self.force = force_
        self.offer_urls = offer_urls_
        self.unknown_fields = unknown_fields


class DestroyApplicationParams(Type):
    _toSchema = {
        "application_tag": "application-tag",
        "destroy_storage": "destroy-storage",
        "dry_run": "dry-run",
        "force": "force",
        "max_wait": "max-wait",
    }
    _toPy = {
        "application-tag": "application_tag",
        "destroy-storage": "destroy_storage",
        "dry-run": "dry_run",
        "force": "force",
        "max-wait": "max_wait",
    }

    def __init__(
        self,
        application_tag=None,
        destroy_storage=None,
        dry_run=None,
        force=None,
        max_wait=None,
        **unknown_fields,
    ):
        """application_tag : str
        destroy_storage : bool
        dry_run : bool
        force : bool
        max_wait : int
        """
        application_tag_ = application_tag
        destroy_storage_ = destroy_storage
        dry_run_ = dry_run
        force_ = force
        max_wait_ = max_wait

        # Validate arguments against known Juju API types.
        if application_tag_ is not None and not isinstance(
            application_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_tag_ to be a str, received: {type(application_tag_)}"
            )

        if destroy_storage_ is not None and not isinstance(destroy_storage_, bool):
            raise Exception(
                f"Expected destroy_storage_ to be a bool, received: {type(destroy_storage_)}"
            )

        if dry_run_ is not None and not isinstance(dry_run_, bool):
            raise Exception(
                f"Expected dry_run_ to be a bool, received: {type(dry_run_)}"
            )

        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if max_wait_ is not None and not isinstance(max_wait_, int):
            raise Exception(
                f"Expected max_wait_ to be a int, received: {type(max_wait_)}"
            )

        self.application_tag = application_tag_
        self.destroy_storage = destroy_storage_
        self.dry_run = dry_run_
        self.force = force_
        self.max_wait = max_wait_
        self.unknown_fields = unknown_fields


class DestroyApplicationResult(Type):
    _toSchema = {"error": "error", "info": "info"}
    _toPy = {"error": "error", "info": "info"}

    def __init__(self, error=None, info=None, **unknown_fields):
        """Error : Error
        info : DestroyApplicationInfo
        """
        error_ = Error.from_json(error) if error else None
        info_ = DestroyApplicationInfo.from_json(info) if info else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if info_ is not None and not isinstance(info_, (dict, DestroyApplicationInfo)):
            raise Exception(
                f"Expected info_ to be a DestroyApplicationInfo, received: {type(info_)}"
            )

        self.error = error_
        self.info = info_
        self.unknown_fields = unknown_fields


class DestroyApplicationResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~DestroyApplicationResult]"""
        results_ = [DestroyApplicationResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class DestroyApplicationsParams(Type):
    _toSchema = {"applications": "applications"}
    _toPy = {"applications": "applications"}

    def __init__(self, applications=None, **unknown_fields):
        """Applications : typing.Sequence[~DestroyApplicationParams]"""
        applications_ = [
            DestroyApplicationParams.from_json(o) for o in applications or []
        ]

        # Validate arguments against known Juju API types.
        if applications_ is not None and not isinstance(
            applications_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected applications_ to be a Sequence, received: {type(applications_)}"
            )

        self.applications = applications_
        self.unknown_fields = unknown_fields


class DestroyConsumedApplicationParams(Type):
    _toSchema = {
        "application_tag": "application-tag",
        "force": "force",
        "max_wait": "max-wait",
    }
    _toPy = {
        "application-tag": "application_tag",
        "force": "force",
        "max-wait": "max_wait",
    }

    def __init__(
        self, application_tag=None, force=None, max_wait=None, **unknown_fields
    ):
        """application_tag : str
        force : bool
        max_wait : int
        """
        application_tag_ = application_tag
        force_ = force
        max_wait_ = max_wait

        # Validate arguments against known Juju API types.
        if application_tag_ is not None and not isinstance(
            application_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_tag_ to be a str, received: {type(application_tag_)}"
            )

        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if max_wait_ is not None and not isinstance(max_wait_, int):
            raise Exception(
                f"Expected max_wait_ to be a int, received: {type(max_wait_)}"
            )

        self.application_tag = application_tag_
        self.force = force_
        self.max_wait = max_wait_
        self.unknown_fields = unknown_fields


class DestroyConsumedApplicationsParams(Type):
    _toSchema = {"applications": "applications"}
    _toPy = {"applications": "applications"}

    def __init__(self, applications=None, **unknown_fields):
        """Applications : typing.Sequence[~DestroyConsumedApplicationParams]"""
        applications_ = [
            DestroyConsumedApplicationParams.from_json(o) for o in applications or []
        ]

        # Validate arguments against known Juju API types.
        if applications_ is not None and not isinstance(
            applications_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected applications_ to be a Sequence, received: {type(applications_)}"
            )

        self.applications = applications_
        self.unknown_fields = unknown_fields


class DestroyControllerArgs(Type):
    _toSchema = {
        "destroy_models": "destroy-models",
        "destroy_storage": "destroy-storage",
        "force": "force",
        "max_wait": "max-wait",
        "model_timeout": "model-timeout",
    }
    _toPy = {
        "destroy-models": "destroy_models",
        "destroy-storage": "destroy_storage",
        "force": "force",
        "max-wait": "max_wait",
        "model-timeout": "model_timeout",
    }

    def __init__(
        self,
        destroy_models=None,
        destroy_storage=None,
        force=None,
        max_wait=None,
        model_timeout=None,
        **unknown_fields,
    ):
        """destroy_models : bool
        destroy_storage : bool
        force : bool
        max_wait : int
        model_timeout : int
        """
        destroy_models_ = destroy_models
        destroy_storage_ = destroy_storage
        force_ = force
        max_wait_ = max_wait
        model_timeout_ = model_timeout

        # Validate arguments against known Juju API types.
        if destroy_models_ is not None and not isinstance(destroy_models_, bool):
            raise Exception(
                f"Expected destroy_models_ to be a bool, received: {type(destroy_models_)}"
            )

        if destroy_storage_ is not None and not isinstance(destroy_storage_, bool):
            raise Exception(
                f"Expected destroy_storage_ to be a bool, received: {type(destroy_storage_)}"
            )

        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if max_wait_ is not None and not isinstance(max_wait_, int):
            raise Exception(
                f"Expected max_wait_ to be a int, received: {type(max_wait_)}"
            )

        if model_timeout_ is not None and not isinstance(model_timeout_, int):
            raise Exception(
                f"Expected model_timeout_ to be a int, received: {type(model_timeout_)}"
            )

        self.destroy_models = destroy_models_
        self.destroy_storage = destroy_storage_
        self.force = force_
        self.max_wait = max_wait_
        self.model_timeout = model_timeout_
        self.unknown_fields = unknown_fields


class DestroyMachineInfo(Type):
    _toSchema = {
        "destroyed_containers": "destroyed-containers",
        "destroyed_storage": "destroyed-storage",
        "destroyed_units": "destroyed-units",
        "detached_storage": "detached-storage",
        "machine_id": "machine-id",
    }
    _toPy = {
        "destroyed-containers": "destroyed_containers",
        "destroyed-storage": "destroyed_storage",
        "destroyed-units": "destroyed_units",
        "detached-storage": "detached_storage",
        "machine-id": "machine_id",
    }

    def __init__(
        self,
        destroyed_containers=None,
        destroyed_storage=None,
        destroyed_units=None,
        detached_storage=None,
        machine_id=None,
        **unknown_fields,
    ):
        """destroyed_containers : typing.Sequence[~DestroyMachineResult]
        destroyed_storage : typing.Sequence[~Entity]
        destroyed_units : typing.Sequence[~Entity]
        detached_storage : typing.Sequence[~Entity]
        machine_id : str
        """
        destroyed_containers_ = [
            DestroyMachineResult.from_json(o) for o in destroyed_containers or []
        ]
        destroyed_storage_ = [Entity.from_json(o) for o in destroyed_storage or []]
        destroyed_units_ = [Entity.from_json(o) for o in destroyed_units or []]
        detached_storage_ = [Entity.from_json(o) for o in detached_storage or []]
        machine_id_ = machine_id

        # Validate arguments against known Juju API types.
        if destroyed_containers_ is not None and not isinstance(
            destroyed_containers_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected destroyed_containers_ to be a Sequence, received: {type(destroyed_containers_)}"
            )

        if destroyed_storage_ is not None and not isinstance(
            destroyed_storage_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected destroyed_storage_ to be a Sequence, received: {type(destroyed_storage_)}"
            )

        if destroyed_units_ is not None and not isinstance(
            destroyed_units_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected destroyed_units_ to be a Sequence, received: {type(destroyed_units_)}"
            )

        if detached_storage_ is not None and not isinstance(
            detached_storage_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected detached_storage_ to be a Sequence, received: {type(detached_storage_)}"
            )

        if machine_id_ is not None and not isinstance(machine_id_, (bytes, str)):
            raise Exception(
                f"Expected machine_id_ to be a str, received: {type(machine_id_)}"
            )

        self.destroyed_containers = destroyed_containers_
        self.destroyed_storage = destroyed_storage_
        self.destroyed_units = destroyed_units_
        self.detached_storage = detached_storage_
        self.machine_id = machine_id_
        self.unknown_fields = unknown_fields


class DestroyMachineResult(Type):
    _toSchema = {"error": "error", "info": "info"}
    _toPy = {"error": "error", "info": "info"}

    def __init__(self, error=None, info=None, **unknown_fields):
        """Error : Error
        info : DestroyMachineInfo
        """
        error_ = Error.from_json(error) if error else None
        info_ = DestroyMachineInfo.from_json(info) if info else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if info_ is not None and not isinstance(info_, (dict, DestroyMachineInfo)):
            raise Exception(
                f"Expected info_ to be a DestroyMachineInfo, received: {type(info_)}"
            )

        self.error = error_
        self.info = info_
        self.unknown_fields = unknown_fields


class DestroyMachineResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~DestroyMachineResult]"""
        results_ = [DestroyMachineResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class DestroyMachinesParams(Type):
    _toSchema = {
        "dry_run": "dry-run",
        "force": "force",
        "keep": "keep",
        "machine_tags": "machine-tags",
        "max_wait": "max-wait",
    }
    _toPy = {
        "dry-run": "dry_run",
        "force": "force",
        "keep": "keep",
        "machine-tags": "machine_tags",
        "max-wait": "max_wait",
    }

    def __init__(
        self,
        dry_run=None,
        force=None,
        keep=None,
        machine_tags=None,
        max_wait=None,
        **unknown_fields,
    ):
        """dry_run : bool
        force : bool
        keep : bool
        machine_tags : typing.Sequence[str]
        max_wait : int
        """
        dry_run_ = dry_run
        force_ = force
        keep_ = keep
        machine_tags_ = machine_tags
        max_wait_ = max_wait

        # Validate arguments against known Juju API types.
        if dry_run_ is not None and not isinstance(dry_run_, bool):
            raise Exception(
                f"Expected dry_run_ to be a bool, received: {type(dry_run_)}"
            )

        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if keep_ is not None and not isinstance(keep_, bool):
            raise Exception(f"Expected keep_ to be a bool, received: {type(keep_)}")

        if machine_tags_ is not None and not isinstance(
            machine_tags_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected machine_tags_ to be a Sequence, received: {type(machine_tags_)}"
            )

        if max_wait_ is not None and not isinstance(max_wait_, int):
            raise Exception(
                f"Expected max_wait_ to be a int, received: {type(max_wait_)}"
            )

        self.dry_run = dry_run_
        self.force = force_
        self.keep = keep_
        self.machine_tags = machine_tags_
        self.max_wait = max_wait_
        self.unknown_fields = unknown_fields


class DestroyModelParams(Type):
    _toSchema = {
        "destroy_storage": "destroy-storage",
        "force": "force",
        "max_wait": "max-wait",
        "model_tag": "model-tag",
        "timeout": "timeout",
    }
    _toPy = {
        "destroy-storage": "destroy_storage",
        "force": "force",
        "max-wait": "max_wait",
        "model-tag": "model_tag",
        "timeout": "timeout",
    }

    def __init__(
        self,
        destroy_storage=None,
        force=None,
        max_wait=None,
        model_tag=None,
        timeout=None,
        **unknown_fields,
    ):
        """destroy_storage : bool
        force : bool
        max_wait : int
        model_tag : str
        timeout : int
        """
        destroy_storage_ = destroy_storage
        force_ = force
        max_wait_ = max_wait
        model_tag_ = model_tag
        timeout_ = timeout

        # Validate arguments against known Juju API types.
        if destroy_storage_ is not None and not isinstance(destroy_storage_, bool):
            raise Exception(
                f"Expected destroy_storage_ to be a bool, received: {type(destroy_storage_)}"
            )

        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if max_wait_ is not None and not isinstance(max_wait_, int):
            raise Exception(
                f"Expected max_wait_ to be a int, received: {type(max_wait_)}"
            )

        if model_tag_ is not None and not isinstance(model_tag_, (bytes, str)):
            raise Exception(
                f"Expected model_tag_ to be a str, received: {type(model_tag_)}"
            )

        if timeout_ is not None and not isinstance(timeout_, int):
            raise Exception(
                f"Expected timeout_ to be a int, received: {type(timeout_)}"
            )

        self.destroy_storage = destroy_storage_
        self.force = force_
        self.max_wait = max_wait_
        self.model_tag = model_tag_
        self.timeout = timeout_
        self.unknown_fields = unknown_fields


class DestroyModelsParams(Type):
    _toSchema = {"models": "models"}
    _toPy = {"models": "models"}

    def __init__(self, models=None, **unknown_fields):
        """Models : typing.Sequence[~DestroyModelParams]"""
        models_ = [DestroyModelParams.from_json(o) for o in models or []]

        # Validate arguments against known Juju API types.
        if models_ is not None and not isinstance(models_, (bytes, str, list)):
            raise Exception(
                f"Expected models_ to be a Sequence, received: {type(models_)}"
            )

        self.models = models_
        self.unknown_fields = unknown_fields


class DestroyRelation(Type):
    _toSchema = {
        "endpoints": "endpoints",
        "force": "force",
        "max_wait": "max-wait",
        "relation_id": "relation-id",
    }
    _toPy = {
        "endpoints": "endpoints",
        "force": "force",
        "max-wait": "max_wait",
        "relation-id": "relation_id",
    }

    def __init__(
        self,
        endpoints=None,
        force=None,
        max_wait=None,
        relation_id=None,
        **unknown_fields,
    ):
        """Endpoints : typing.Sequence[str]
        force : bool
        max_wait : int
        relation_id : int
        """
        endpoints_ = endpoints
        force_ = force
        max_wait_ = max_wait
        relation_id_ = relation_id

        # Validate arguments against known Juju API types.
        if endpoints_ is not None and not isinstance(endpoints_, (bytes, str, list)):
            raise Exception(
                f"Expected endpoints_ to be a Sequence, received: {type(endpoints_)}"
            )

        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if max_wait_ is not None and not isinstance(max_wait_, int):
            raise Exception(
                f"Expected max_wait_ to be a int, received: {type(max_wait_)}"
            )

        if relation_id_ is not None and not isinstance(relation_id_, int):
            raise Exception(
                f"Expected relation_id_ to be a int, received: {type(relation_id_)}"
            )

        self.endpoints = endpoints_
        self.force = force_
        self.max_wait = max_wait_
        self.relation_id = relation_id_
        self.unknown_fields = unknown_fields


class DestroyUnitInfo(Type):
    _toSchema = {
        "destroyed_storage": "destroyed-storage",
        "detached_storage": "detached-storage",
    }
    _toPy = {
        "destroyed-storage": "destroyed_storage",
        "detached-storage": "detached_storage",
    }

    def __init__(self, destroyed_storage=None, detached_storage=None, **unknown_fields):
        """destroyed_storage : typing.Sequence[~Entity]
        detached_storage : typing.Sequence[~Entity]
        """
        destroyed_storage_ = [Entity.from_json(o) for o in destroyed_storage or []]
        detached_storage_ = [Entity.from_json(o) for o in detached_storage or []]

        # Validate arguments against known Juju API types.
        if destroyed_storage_ is not None and not isinstance(
            destroyed_storage_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected destroyed_storage_ to be a Sequence, received: {type(destroyed_storage_)}"
            )

        if detached_storage_ is not None and not isinstance(
            detached_storage_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected detached_storage_ to be a Sequence, received: {type(detached_storage_)}"
            )

        self.destroyed_storage = destroyed_storage_
        self.detached_storage = detached_storage_
        self.unknown_fields = unknown_fields


class DestroyUnitParams(Type):
    _toSchema = {
        "destroy_storage": "destroy-storage",
        "dry_run": "dry-run",
        "force": "force",
        "max_wait": "max-wait",
        "unit_tag": "unit-tag",
    }
    _toPy = {
        "destroy-storage": "destroy_storage",
        "dry-run": "dry_run",
        "force": "force",
        "max-wait": "max_wait",
        "unit-tag": "unit_tag",
    }

    def __init__(
        self,
        destroy_storage=None,
        dry_run=None,
        force=None,
        max_wait=None,
        unit_tag=None,
        **unknown_fields,
    ):
        """destroy_storage : bool
        dry_run : bool
        force : bool
        max_wait : int
        unit_tag : str
        """
        destroy_storage_ = destroy_storage
        dry_run_ = dry_run
        force_ = force
        max_wait_ = max_wait
        unit_tag_ = unit_tag

        # Validate arguments against known Juju API types.
        if destroy_storage_ is not None and not isinstance(destroy_storage_, bool):
            raise Exception(
                f"Expected destroy_storage_ to be a bool, received: {type(destroy_storage_)}"
            )

        if dry_run_ is not None and not isinstance(dry_run_, bool):
            raise Exception(
                f"Expected dry_run_ to be a bool, received: {type(dry_run_)}"
            )

        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if max_wait_ is not None and not isinstance(max_wait_, int):
            raise Exception(
                f"Expected max_wait_ to be a int, received: {type(max_wait_)}"
            )

        if unit_tag_ is not None and not isinstance(unit_tag_, (bytes, str)):
            raise Exception(
                f"Expected unit_tag_ to be a str, received: {type(unit_tag_)}"
            )

        self.destroy_storage = destroy_storage_
        self.dry_run = dry_run_
        self.force = force_
        self.max_wait = max_wait_
        self.unit_tag = unit_tag_
        self.unknown_fields = unknown_fields


class DestroyUnitResult(Type):
    _toSchema = {"error": "error", "info": "info"}
    _toPy = {"error": "error", "info": "info"}

    def __init__(self, error=None, info=None, **unknown_fields):
        """Error : Error
        info : DestroyUnitInfo
        """
        error_ = Error.from_json(error) if error else None
        info_ = DestroyUnitInfo.from_json(info) if info else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if info_ is not None and not isinstance(info_, (dict, DestroyUnitInfo)):
            raise Exception(
                f"Expected info_ to be a DestroyUnitInfo, received: {type(info_)}"
            )

        self.error = error_
        self.info = info_
        self.unknown_fields = unknown_fields


class DestroyUnitResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~DestroyUnitResult]"""
        results_ = [DestroyUnitResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class DestroyUnitsParams(Type):
    _toSchema = {"units": "units"}
    _toPy = {"units": "units"}

    def __init__(self, units=None, **unknown_fields):
        """Units : typing.Sequence[~DestroyUnitParams]"""
        units_ = [DestroyUnitParams.from_json(o) for o in units or []]

        # Validate arguments against known Juju API types.
        if units_ is not None and not isinstance(units_, (bytes, str, list)):
            raise Exception(
                f"Expected units_ to be a Sequence, received: {type(units_)}"
            )

        self.units = units_
        self.unknown_fields = unknown_fields


class DetailedStatus(Type):
    _toSchema = {
        "data": "data",
        "err": "err",
        "info": "info",
        "kind": "kind",
        "life": "life",
        "since": "since",
        "status": "status",
        "version": "version",
    }
    _toPy = {
        "data": "data",
        "err": "err",
        "info": "info",
        "kind": "kind",
        "life": "life",
        "since": "since",
        "status": "status",
        "version": "version",
    }

    def __init__(
        self,
        data=None,
        err=None,
        info=None,
        kind=None,
        life=None,
        since=None,
        status=None,
        version=None,
        **unknown_fields,
    ):
        """Data : typing.Mapping[str, typing.Any]
        err : Error
        info : str
        kind : str
        life : str
        since : str
        status : str
        version : str
        """
        data_ = data
        err_ = Error.from_json(err) if err else None
        info_ = info
        kind_ = kind
        life_ = life
        since_ = since
        status_ = status
        version_ = version

        # Validate arguments against known Juju API types.
        if data_ is not None and not isinstance(data_, dict):
            raise Exception(f"Expected data_ to be a Mapping, received: {type(data_)}")

        if err_ is not None and not isinstance(err_, (dict, Error)):
            raise Exception(f"Expected err_ to be a Error, received: {type(err_)}")

        if info_ is not None and not isinstance(info_, (bytes, str)):
            raise Exception(f"Expected info_ to be a str, received: {type(info_)}")

        if kind_ is not None and not isinstance(kind_, (bytes, str)):
            raise Exception(f"Expected kind_ to be a str, received: {type(kind_)}")

        if life_ is not None and not isinstance(life_, (bytes, str)):
            raise Exception(f"Expected life_ to be a str, received: {type(life_)}")

        if since_ is not None and not isinstance(since_, (bytes, str)):
            raise Exception(f"Expected since_ to be a str, received: {type(since_)}")

        if status_ is not None and not isinstance(status_, (bytes, str)):
            raise Exception(f"Expected status_ to be a str, received: {type(status_)}")

        if version_ is not None and not isinstance(version_, (bytes, str)):
            raise Exception(
                f"Expected version_ to be a str, received: {type(version_)}"
            )

        self.data = data_
        self.err = err_
        self.info = info_
        self.kind = kind_
        self.life = life_
        self.since = since_
        self.status = status_
        self.version = version_
        self.unknown_fields = unknown_fields


class DownloadInfoResult(Type):
    _toSchema = {"charm_origin": "charm-origin", "url": "url"}
    _toPy = {"charm-origin": "charm_origin", "url": "url"}

    def __init__(self, charm_origin=None, url=None, **unknown_fields):
        """charm_origin : CharmOrigin
        url : str
        """
        charm_origin_ = CharmOrigin.from_json(charm_origin) if charm_origin else None
        url_ = url

        # Validate arguments against known Juju API types.
        if charm_origin_ is not None and not isinstance(
            charm_origin_, (dict, CharmOrigin)
        ):
            raise Exception(
                f"Expected charm_origin_ to be a CharmOrigin, received: {type(charm_origin_)}"
            )

        if url_ is not None and not isinstance(url_, (bytes, str)):
            raise Exception(f"Expected url_ to be a str, received: {type(url_)}")

        self.charm_origin = charm_origin_
        self.url = url_
        self.unknown_fields = unknown_fields


class DownloadInfoResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~DownloadInfoResult]"""
        results_ = [DownloadInfoResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class DumpModelRequest(Type):
    _toSchema = {"entities": "entities", "simplified": "simplified"}
    _toPy = {"entities": "entities", "simplified": "simplified"}

    def __init__(self, entities=None, simplified=None, **unknown_fields):
        """Entities : typing.Sequence[~Entity]
        simplified : bool
        """
        entities_ = [Entity.from_json(o) for o in entities or []]
        simplified_ = simplified

        # Validate arguments against known Juju API types.
        if entities_ is not None and not isinstance(entities_, (bytes, str, list)):
            raise Exception(
                f"Expected entities_ to be a Sequence, received: {type(entities_)}"
            )

        if simplified_ is not None and not isinstance(simplified_, bool):
            raise Exception(
                f"Expected simplified_ to be a bool, received: {type(simplified_)}"
            )

        self.entities = entities_
        self.simplified = simplified_
        self.unknown_fields = unknown_fields


class EndpointFilterAttributes(Type):
    _toSchema = {"interface": "interface", "name": "name", "role": "role"}
    _toPy = {"interface": "interface", "name": "name", "role": "role"}

    def __init__(self, interface=None, name=None, role=None, **unknown_fields):
        """Interface : str
        name : str
        role : str
        """
        interface_ = interface
        name_ = name
        role_ = role

        # Validate arguments against known Juju API types.
        if interface_ is not None and not isinstance(interface_, (bytes, str)):
            raise Exception(
                f"Expected interface_ to be a str, received: {type(interface_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if role_ is not None and not isinstance(role_, (bytes, str)):
            raise Exception(f"Expected role_ to be a str, received: {type(role_)}")

        self.interface = interface_
        self.name = name_
        self.role = role_
        self.unknown_fields = unknown_fields


class EndpointRelationData(Type):
    _toSchema = {
        "applicationdata": "ApplicationData",
        "cross_model": "cross-model",
        "endpoint": "endpoint",
        "related_endpoint": "related-endpoint",
        "relation_id": "relation-id",
        "unit_relation_data": "unit-relation-data",
    }
    _toPy = {
        "ApplicationData": "applicationdata",
        "cross-model": "cross_model",
        "endpoint": "endpoint",
        "related-endpoint": "related_endpoint",
        "relation-id": "relation_id",
        "unit-relation-data": "unit_relation_data",
    }

    def __init__(
        self,
        applicationdata=None,
        cross_model=None,
        endpoint=None,
        related_endpoint=None,
        relation_id=None,
        unit_relation_data=None,
        **unknown_fields,
    ):
        """Applicationdata : typing.Mapping[str, typing.Any]
        cross_model : bool
        endpoint : str
        related_endpoint : str
        relation_id : int
        unit_relation_data : typing.Mapping[str, ~RelationData]
        """
        applicationdata_ = applicationdata
        cross_model_ = cross_model
        endpoint_ = endpoint
        related_endpoint_ = related_endpoint
        relation_id_ = relation_id
        unit_relation_data_ = {
            k: RelationData.from_json(v)
            for k, v in (unit_relation_data or dict()).items()
        }

        # Validate arguments against known Juju API types.
        if applicationdata_ is not None and not isinstance(applicationdata_, dict):
            raise Exception(
                f"Expected applicationdata_ to be a Mapping, received: {type(applicationdata_)}"
            )

        if cross_model_ is not None and not isinstance(cross_model_, bool):
            raise Exception(
                f"Expected cross_model_ to be a bool, received: {type(cross_model_)}"
            )

        if endpoint_ is not None and not isinstance(endpoint_, (bytes, str)):
            raise Exception(
                f"Expected endpoint_ to be a str, received: {type(endpoint_)}"
            )

        if related_endpoint_ is not None and not isinstance(
            related_endpoint_, (bytes, str)
        ):
            raise Exception(
                f"Expected related_endpoint_ to be a str, received: {type(related_endpoint_)}"
            )

        if relation_id_ is not None and not isinstance(relation_id_, int):
            raise Exception(
                f"Expected relation_id_ to be a int, received: {type(relation_id_)}"
            )

        if unit_relation_data_ is not None and not isinstance(
            unit_relation_data_, dict
        ):
            raise Exception(
                f"Expected unit_relation_data_ to be a Mapping, received: {type(unit_relation_data_)}"
            )

        self.applicationdata = applicationdata_
        self.cross_model = cross_model_
        self.endpoint = endpoint_
        self.related_endpoint = related_endpoint_
        self.relation_id = relation_id_
        self.unit_relation_data = unit_relation_data_
        self.unknown_fields = unknown_fields


class EndpointStatus(Type):
    _toSchema = {
        "application": "application",
        "name": "name",
        "role": "role",
        "subordinate": "subordinate",
    }
    _toPy = {
        "application": "application",
        "name": "name",
        "role": "role",
        "subordinate": "subordinate",
    }

    def __init__(
        self, application=None, name=None, role=None, subordinate=None, **unknown_fields
    ):
        """Application : str
        name : str
        role : str
        subordinate : bool
        """
        application_ = application
        name_ = name
        role_ = role
        subordinate_ = subordinate

        # Validate arguments against known Juju API types.
        if application_ is not None and not isinstance(application_, (bytes, str)):
            raise Exception(
                f"Expected application_ to be a str, received: {type(application_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if role_ is not None and not isinstance(role_, (bytes, str)):
            raise Exception(f"Expected role_ to be a str, received: {type(role_)}")

        if subordinate_ is not None and not isinstance(subordinate_, bool):
            raise Exception(
                f"Expected subordinate_ to be a bool, received: {type(subordinate_)}"
            )

        self.application = application_
        self.name = name_
        self.role = role_
        self.subordinate = subordinate_
        self.unknown_fields = unknown_fields


class EnqueuedActions(Type):
    _toSchema = {"actions": "actions", "operation": "operation"}
    _toPy = {"actions": "actions", "operation": "operation"}

    def __init__(self, actions=None, operation=None, **unknown_fields):
        """Actions : typing.Sequence[~ActionResult]
        operation : str
        """
        actions_ = [ActionResult.from_json(o) for o in actions or []]
        operation_ = operation

        # Validate arguments against known Juju API types.
        if actions_ is not None and not isinstance(actions_, (bytes, str, list)):
            raise Exception(
                f"Expected actions_ to be a Sequence, received: {type(actions_)}"
            )

        if operation_ is not None and not isinstance(operation_, (bytes, str)):
            raise Exception(
                f"Expected operation_ to be a str, received: {type(operation_)}"
            )

        self.actions = actions_
        self.operation = operation_
        self.unknown_fields = unknown_fields


class Entities(Type):
    _toSchema = {"entities": "entities"}
    _toPy = {"entities": "entities"}

    def __init__(self, entities=None, **unknown_fields):
        """Entities : typing.Sequence[~Entity]"""
        entities_ = [Entity.from_json(o) for o in entities or []]

        # Validate arguments against known Juju API types.
        if entities_ is not None and not isinstance(entities_, (bytes, str, list)):
            raise Exception(
                f"Expected entities_ to be a Sequence, received: {type(entities_)}"
            )

        self.entities = entities_
        self.unknown_fields = unknown_fields


class Entity(Type):
    _toSchema = {"tag": "tag"}
    _toPy = {"tag": "tag"}

    def __init__(self, tag=None, **unknown_fields):
        """Tag : str"""
        tag_ = tag

        # Validate arguments against known Juju API types.
        if tag_ is not None and not isinstance(tag_, (bytes, str)):
            raise Exception(f"Expected tag_ to be a str, received: {type(tag_)}")

        self.tag = tag_
        self.unknown_fields = unknown_fields


class EntityAnnotations(Type):
    _toSchema = {"annotations": "annotations", "entity": "entity"}
    _toPy = {"annotations": "annotations", "entity": "entity"}

    def __init__(self, annotations=None, entity=None, **unknown_fields):
        """Annotations : typing.Mapping[str, str]
        entity : str
        """
        annotations_ = annotations
        entity_ = entity

        # Validate arguments against known Juju API types.
        if annotations_ is not None and not isinstance(annotations_, dict):
            raise Exception(
                f"Expected annotations_ to be a Mapping, received: {type(annotations_)}"
            )

        if entity_ is not None and not isinstance(entity_, (bytes, str)):
            raise Exception(f"Expected entity_ to be a str, received: {type(entity_)}")

        self.annotations = annotations_
        self.entity = entity_
        self.unknown_fields = unknown_fields


class EntityMetrics(Type):
    _toSchema = {"error": "error", "metrics": "metrics"}
    _toPy = {"error": "error", "metrics": "metrics"}

    def __init__(self, error=None, metrics=None, **unknown_fields):
        """Error : Error
        metrics : typing.Sequence[~MetricResult]
        """
        error_ = Error.from_json(error) if error else None
        metrics_ = [MetricResult.from_json(o) for o in metrics or []]

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if metrics_ is not None and not isinstance(metrics_, (bytes, str, list)):
            raise Exception(
                f"Expected metrics_ to be a Sequence, received: {type(metrics_)}"
            )

        self.error = error_
        self.metrics = metrics_
        self.unknown_fields = unknown_fields


class EntityPassword(Type):
    _toSchema = {"password": "password", "tag": "tag"}
    _toPy = {"password": "password", "tag": "tag"}

    def __init__(self, password=None, tag=None, **unknown_fields):
        """Password : str
        tag : str
        """
        password_ = password
        tag_ = tag

        # Validate arguments against known Juju API types.
        if password_ is not None and not isinstance(password_, (bytes, str)):
            raise Exception(
                f"Expected password_ to be a str, received: {type(password_)}"
            )

        if tag_ is not None and not isinstance(tag_, (bytes, str)):
            raise Exception(f"Expected tag_ to be a str, received: {type(tag_)}")

        self.password = password_
        self.tag = tag_
        self.unknown_fields = unknown_fields


class EntityPasswords(Type):
    _toSchema = {"changes": "changes"}
    _toPy = {"changes": "changes"}

    def __init__(self, changes=None, **unknown_fields):
        """Changes : typing.Sequence[~EntityPassword]"""
        changes_ = [EntityPassword.from_json(o) for o in changes or []]

        # Validate arguments against known Juju API types.
        if changes_ is not None and not isinstance(changes_, (bytes, str, list)):
            raise Exception(
                f"Expected changes_ to be a Sequence, received: {type(changes_)}"
            )

        self.changes = changes_
        self.unknown_fields = unknown_fields


class EntityStatus(Type):
    _toSchema = {"data": "data", "info": "info", "since": "since", "status": "status"}
    _toPy = {"data": "data", "info": "info", "since": "since", "status": "status"}

    def __init__(self, data=None, info=None, since=None, status=None, **unknown_fields):
        """Data : typing.Mapping[str, typing.Any]
        info : str
        since : str
        status : str
        """
        data_ = data
        info_ = info
        since_ = since
        status_ = status

        # Validate arguments against known Juju API types.
        if data_ is not None and not isinstance(data_, dict):
            raise Exception(f"Expected data_ to be a Mapping, received: {type(data_)}")

        if info_ is not None and not isinstance(info_, (bytes, str)):
            raise Exception(f"Expected info_ to be a str, received: {type(info_)}")

        if since_ is not None and not isinstance(since_, (bytes, str)):
            raise Exception(f"Expected since_ to be a str, received: {type(since_)}")

        if status_ is not None and not isinstance(status_, (bytes, str)):
            raise Exception(f"Expected status_ to be a str, received: {type(status_)}")

        self.data = data_
        self.info = info_
        self.since = since_
        self.status = status_
        self.unknown_fields = unknown_fields


class Error(Type):
    _toSchema = {"code": "code", "info": "info", "message": "message"}
    _toPy = {"code": "code", "info": "info", "message": "message"}

    def __init__(self, code=None, info=None, message=None, **unknown_fields):
        """Code : str
        info : typing.Mapping[str, typing.Any]
        message : str
        """
        code_ = code
        info_ = info
        message_ = message

        # Validate arguments against known Juju API types.
        if code_ is not None and not isinstance(code_, (bytes, str)):
            raise Exception(f"Expected code_ to be a str, received: {type(code_)}")

        if info_ is not None and not isinstance(info_, dict):
            raise Exception(f"Expected info_ to be a Mapping, received: {type(info_)}")

        if message_ is not None and not isinstance(message_, (bytes, str)):
            raise Exception(
                f"Expected message_ to be a str, received: {type(message_)}"
            )

        self.code = code_
        self.info = info_
        self.message = message_
        self.unknown_fields = unknown_fields


class ErrorResult(Type):
    _toSchema = {"error": "error"}
    _toPy = {"error": "error"}

    def __init__(self, error=None, **unknown_fields):
        """Error : Error"""
        error_ = Error.from_json(error) if error else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        self.error = error_
        self.unknown_fields = unknown_fields


class ErrorResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ErrorResult]"""
        results_ = [ErrorResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ExportBundleParams(Type):
    _toSchema = {
        "include_charm_defaults": "include-charm-defaults",
        "include_series": "include-series",
    }
    _toPy = {
        "include-charm-defaults": "include_charm_defaults",
        "include-series": "include_series",
    }

    def __init__(
        self, include_charm_defaults=None, include_series=None, **unknown_fields
    ):
        """include_charm_defaults : bool
        include_series : bool
        """
        include_charm_defaults_ = include_charm_defaults
        include_series_ = include_series

        # Validate arguments against known Juju API types.
        if include_charm_defaults_ is not None and not isinstance(
            include_charm_defaults_, bool
        ):
            raise Exception(
                f"Expected include_charm_defaults_ to be a bool, received: {type(include_charm_defaults_)}"
            )

        if include_series_ is not None and not isinstance(include_series_, bool):
            raise Exception(
                f"Expected include_series_ to be a bool, received: {type(include_series_)}"
            )

        self.include_charm_defaults = include_charm_defaults_
        self.include_series = include_series_
        self.unknown_fields = unknown_fields


class ExposedEndpoint(Type):
    _toSchema = {
        "expose_to_cidrs": "expose-to-cidrs",
        "expose_to_spaces": "expose-to-spaces",
    }
    _toPy = {
        "expose-to-cidrs": "expose_to_cidrs",
        "expose-to-spaces": "expose_to_spaces",
    }

    def __init__(self, expose_to_cidrs=None, expose_to_spaces=None, **unknown_fields):
        """expose_to_cidrs : typing.Sequence[str]
        expose_to_spaces : typing.Sequence[str]
        """
        expose_to_cidrs_ = expose_to_cidrs
        expose_to_spaces_ = expose_to_spaces

        # Validate arguments against known Juju API types.
        if expose_to_cidrs_ is not None and not isinstance(
            expose_to_cidrs_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected expose_to_cidrs_ to be a Sequence, received: {type(expose_to_cidrs_)}"
            )

        if expose_to_spaces_ is not None and not isinstance(
            expose_to_spaces_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected expose_to_spaces_ to be a Sequence, received: {type(expose_to_spaces_)}"
            )

        self.expose_to_cidrs = expose_to_cidrs_
        self.expose_to_spaces = expose_to_spaces_
        self.unknown_fields = unknown_fields


class ExpressionTree(Type):
    _toSchema = {"expression": "Expression"}
    _toPy = {"Expression": "expression"}

    def __init__(self, expression=None, **unknown_fields):
        """Expression : Any"""
        expression_ = expression

        # Validate arguments against known Juju API types.
        self.expression = expression_
        self.unknown_fields = unknown_fields


class ExternalControllerInfo(Type):
    _toSchema = {
        "addrs": "addrs",
        "ca_cert": "ca-cert",
        "controller_alias": "controller-alias",
        "controller_tag": "controller-tag",
    }
    _toPy = {
        "addrs": "addrs",
        "ca-cert": "ca_cert",
        "controller-alias": "controller_alias",
        "controller-tag": "controller_tag",
    }

    def __init__(
        self,
        addrs=None,
        ca_cert=None,
        controller_alias=None,
        controller_tag=None,
        **unknown_fields,
    ):
        """Addrs : typing.Sequence[str]
        ca_cert : str
        controller_alias : str
        controller_tag : str
        """
        addrs_ = addrs
        ca_cert_ = ca_cert
        controller_alias_ = controller_alias
        controller_tag_ = controller_tag

        # Validate arguments against known Juju API types.
        if addrs_ is not None and not isinstance(addrs_, (bytes, str, list)):
            raise Exception(
                f"Expected addrs_ to be a Sequence, received: {type(addrs_)}"
            )

        if ca_cert_ is not None and not isinstance(ca_cert_, (bytes, str)):
            raise Exception(
                f"Expected ca_cert_ to be a str, received: {type(ca_cert_)}"
            )

        if controller_alias_ is not None and not isinstance(
            controller_alias_, (bytes, str)
        ):
            raise Exception(
                f"Expected controller_alias_ to be a str, received: {type(controller_alias_)}"
            )

        if controller_tag_ is not None and not isinstance(
            controller_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected controller_tag_ to be a str, received: {type(controller_tag_)}"
            )

        self.addrs = addrs_
        self.ca_cert = ca_cert_
        self.controller_alias = controller_alias_
        self.controller_tag = controller_tag_
        self.unknown_fields = unknown_fields


class FilesystemAttachmentDetails(Type):
    _toSchema = {
        "filesystemattachmentinfo": "FilesystemAttachmentInfo",
        "life": "life",
        "mount_point": "mount-point",
        "read_only": "read-only",
    }
    _toPy = {
        "FilesystemAttachmentInfo": "filesystemattachmentinfo",
        "life": "life",
        "mount-point": "mount_point",
        "read-only": "read_only",
    }

    def __init__(
        self,
        filesystemattachmentinfo=None,
        life=None,
        mount_point=None,
        read_only=None,
        **unknown_fields,
    ):
        """Filesystemattachmentinfo : FilesystemAttachmentInfo
        life : str
        mount_point : str
        read_only : bool
        """
        filesystemattachmentinfo_ = (
            FilesystemAttachmentInfo.from_json(filesystemattachmentinfo)
            if filesystemattachmentinfo
            else None
        )
        life_ = life
        mount_point_ = mount_point
        read_only_ = read_only

        # Validate arguments against known Juju API types.
        if filesystemattachmentinfo_ is not None and not isinstance(
            filesystemattachmentinfo_, (dict, FilesystemAttachmentInfo)
        ):
            raise Exception(
                f"Expected filesystemattachmentinfo_ to be a FilesystemAttachmentInfo, received: {type(filesystemattachmentinfo_)}"
            )

        if life_ is not None and not isinstance(life_, (bytes, str)):
            raise Exception(f"Expected life_ to be a str, received: {type(life_)}")

        if mount_point_ is not None and not isinstance(mount_point_, (bytes, str)):
            raise Exception(
                f"Expected mount_point_ to be a str, received: {type(mount_point_)}"
            )

        if read_only_ is not None and not isinstance(read_only_, bool):
            raise Exception(
                f"Expected read_only_ to be a bool, received: {type(read_only_)}"
            )

        self.filesystemattachmentinfo = filesystemattachmentinfo_
        self.life = life_
        self.mount_point = mount_point_
        self.read_only = read_only_
        self.unknown_fields = unknown_fields


class FilesystemAttachmentInfo(Type):
    _toSchema = {"mount_point": "mount-point", "read_only": "read-only"}
    _toPy = {"mount-point": "mount_point", "read-only": "read_only"}

    def __init__(self, mount_point=None, read_only=None, **unknown_fields):
        """mount_point : str
        read_only : bool
        """
        mount_point_ = mount_point
        read_only_ = read_only

        # Validate arguments against known Juju API types.
        if mount_point_ is not None and not isinstance(mount_point_, (bytes, str)):
            raise Exception(
                f"Expected mount_point_ to be a str, received: {type(mount_point_)}"
            )

        if read_only_ is not None and not isinstance(read_only_, bool):
            raise Exception(
                f"Expected read_only_ to be a bool, received: {type(read_only_)}"
            )

        self.mount_point = mount_point_
        self.read_only = read_only_
        self.unknown_fields = unknown_fields


class FilesystemDetails(Type):
    _toSchema = {
        "filesystem_tag": "filesystem-tag",
        "info": "info",
        "life": "life",
        "machine_attachments": "machine-attachments",
        "status": "status",
        "storage": "storage",
        "unit_attachments": "unit-attachments",
        "volume_tag": "volume-tag",
    }
    _toPy = {
        "filesystem-tag": "filesystem_tag",
        "info": "info",
        "life": "life",
        "machine-attachments": "machine_attachments",
        "status": "status",
        "storage": "storage",
        "unit-attachments": "unit_attachments",
        "volume-tag": "volume_tag",
    }

    def __init__(
        self,
        filesystem_tag=None,
        info=None,
        life=None,
        machine_attachments=None,
        status=None,
        storage=None,
        unit_attachments=None,
        volume_tag=None,
        **unknown_fields,
    ):
        """filesystem_tag : str
        info : FilesystemInfo
        life : str
        machine_attachments : typing.Mapping[str, ~FilesystemAttachmentDetails]
        status : EntityStatus
        storage : StorageDetails
        unit_attachments : typing.Mapping[str, ~FilesystemAttachmentDetails]
        volume_tag : str
        """
        filesystem_tag_ = filesystem_tag
        info_ = FilesystemInfo.from_json(info) if info else None
        life_ = life
        machine_attachments_ = {
            k: FilesystemAttachmentDetails.from_json(v)
            for k, v in (machine_attachments or dict()).items()
        }
        status_ = EntityStatus.from_json(status) if status else None
        storage_ = StorageDetails.from_json(storage) if storage else None
        unit_attachments_ = {
            k: FilesystemAttachmentDetails.from_json(v)
            for k, v in (unit_attachments or dict()).items()
        }
        volume_tag_ = volume_tag

        # Validate arguments against known Juju API types.
        if filesystem_tag_ is not None and not isinstance(
            filesystem_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected filesystem_tag_ to be a str, received: {type(filesystem_tag_)}"
            )

        if info_ is not None and not isinstance(info_, (dict, FilesystemInfo)):
            raise Exception(
                f"Expected info_ to be a FilesystemInfo, received: {type(info_)}"
            )

        if life_ is not None and not isinstance(life_, (bytes, str)):
            raise Exception(f"Expected life_ to be a str, received: {type(life_)}")

        if machine_attachments_ is not None and not isinstance(
            machine_attachments_, dict
        ):
            raise Exception(
                f"Expected machine_attachments_ to be a Mapping, received: {type(machine_attachments_)}"
            )

        if status_ is not None and not isinstance(status_, (dict, EntityStatus)):
            raise Exception(
                f"Expected status_ to be a EntityStatus, received: {type(status_)}"
            )

        if storage_ is not None and not isinstance(storage_, (dict, StorageDetails)):
            raise Exception(
                f"Expected storage_ to be a StorageDetails, received: {type(storage_)}"
            )

        if unit_attachments_ is not None and not isinstance(unit_attachments_, dict):
            raise Exception(
                f"Expected unit_attachments_ to be a Mapping, received: {type(unit_attachments_)}"
            )

        if volume_tag_ is not None and not isinstance(volume_tag_, (bytes, str)):
            raise Exception(
                f"Expected volume_tag_ to be a str, received: {type(volume_tag_)}"
            )

        self.filesystem_tag = filesystem_tag_
        self.info = info_
        self.life = life_
        self.machine_attachments = machine_attachments_
        self.status = status_
        self.storage = storage_
        self.unit_attachments = unit_attachments_
        self.volume_tag = volume_tag_
        self.unknown_fields = unknown_fields


class FilesystemDetailsListResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : typing.Sequence[~FilesystemDetails]
        """
        error_ = Error.from_json(error) if error else None
        result_ = [FilesystemDetails.from_json(o) for o in result or []]

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (bytes, str, list)):
            raise Exception(
                f"Expected result_ to be a Sequence, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class FilesystemDetailsListResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~FilesystemDetailsListResult]"""
        results_ = [FilesystemDetailsListResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class FilesystemFilter(Type):
    _toSchema = {"machines": "machines"}
    _toPy = {"machines": "machines"}

    def __init__(self, machines=None, **unknown_fields):
        """Machines : typing.Sequence[str]"""
        machines_ = machines

        # Validate arguments against known Juju API types.
        if machines_ is not None and not isinstance(machines_, (bytes, str, list)):
            raise Exception(
                f"Expected machines_ to be a Sequence, received: {type(machines_)}"
            )

        self.machines = machines_
        self.unknown_fields = unknown_fields


class FilesystemFilters(Type):
    _toSchema = {"filters": "filters"}
    _toPy = {"filters": "filters"}

    def __init__(self, filters=None, **unknown_fields):
        """Filters : typing.Sequence[~FilesystemFilter]"""
        filters_ = [FilesystemFilter.from_json(o) for o in filters or []]

        # Validate arguments against known Juju API types.
        if filters_ is not None and not isinstance(filters_, (bytes, str, list)):
            raise Exception(
                f"Expected filters_ to be a Sequence, received: {type(filters_)}"
            )

        self.filters = filters_
        self.unknown_fields = unknown_fields


class FilesystemInfo(Type):
    _toSchema = {"filesystem_id": "filesystem-id", "pool": "pool", "size": "size"}
    _toPy = {"filesystem-id": "filesystem_id", "pool": "pool", "size": "size"}

    def __init__(self, filesystem_id=None, pool=None, size=None, **unknown_fields):
        """filesystem_id : str
        pool : str
        size : int
        """
        filesystem_id_ = filesystem_id
        pool_ = pool
        size_ = size

        # Validate arguments against known Juju API types.
        if filesystem_id_ is not None and not isinstance(filesystem_id_, (bytes, str)):
            raise Exception(
                f"Expected filesystem_id_ to be a str, received: {type(filesystem_id_)}"
            )

        if pool_ is not None and not isinstance(pool_, (bytes, str)):
            raise Exception(f"Expected pool_ to be a str, received: {type(pool_)}")

        if size_ is not None and not isinstance(size_, int):
            raise Exception(f"Expected size_ to be a int, received: {type(size_)}")

        self.filesystem_id = filesystem_id_
        self.pool = pool_
        self.size = size_
        self.unknown_fields = unknown_fields


class FindToolsParams(Type):
    _toSchema = {
        "agentstream": "agentstream",
        "arch": "arch",
        "major": "major",
        "number": "number",
        "os_type": "os-type",
    }
    _toPy = {
        "agentstream": "agentstream",
        "arch": "arch",
        "major": "major",
        "number": "number",
        "os-type": "os_type",
    }

    def __init__(
        self,
        agentstream=None,
        arch=None,
        major=None,
        number=None,
        os_type=None,
        **unknown_fields,
    ):
        """Agentstream : str
        arch : str
        major : int
        number : Number
        os_type : str
        """
        agentstream_ = agentstream
        arch_ = arch
        major_ = major
        number_ = Number.from_json(number) if number else None
        os_type_ = os_type

        # Validate arguments against known Juju API types.
        if agentstream_ is not None and not isinstance(agentstream_, (bytes, str)):
            raise Exception(
                f"Expected agentstream_ to be a str, received: {type(agentstream_)}"
            )

        if arch_ is not None and not isinstance(arch_, (bytes, str)):
            raise Exception(f"Expected arch_ to be a str, received: {type(arch_)}")

        if major_ is not None and not isinstance(major_, int):
            raise Exception(f"Expected major_ to be a int, received: {type(major_)}")

        if number_ is not None and not isinstance(number_, (dict, Number)):
            raise Exception(
                f"Expected number_ to be a Number, received: {type(number_)}"
            )

        if os_type_ is not None and not isinstance(os_type_, (bytes, str)):
            raise Exception(
                f"Expected os_type_ to be a str, received: {type(os_type_)}"
            )

        self.agentstream = agentstream_
        self.arch = arch_
        self.major = major_
        self.number = number_
        self.os_type = os_type_
        self.unknown_fields = unknown_fields


class FindToolsResult(Type):
    _toSchema = {"error": "error", "list_": "list"}
    _toPy = {"error": "error", "list": "list_"}

    def __init__(self, error=None, list_=None, **unknown_fields):
        """Error : Error
        list_ : typing.Sequence[~Tools]
        """
        error_ = Error.from_json(error) if error else None
        list__ = [Tools.from_json(o) for o in list_ or []]

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if list__ is not None and not isinstance(list__, (bytes, str, list)):
            raise Exception(
                f"Expected list__ to be a Sequence, received: {type(list__)}"
            )

        self.error = error_
        self.list_ = list__
        self.unknown_fields = unknown_fields


class FirewallRule(Type):
    _toSchema = {"known_service": "known-service", "whitelist_cidrs": "whitelist-cidrs"}
    _toPy = {"known-service": "known_service", "whitelist-cidrs": "whitelist_cidrs"}

    def __init__(self, known_service=None, whitelist_cidrs=None, **unknown_fields):
        """known_service : str
        whitelist_cidrs : typing.Sequence[str]
        """
        known_service_ = known_service
        whitelist_cidrs_ = whitelist_cidrs

        # Validate arguments against known Juju API types.
        if known_service_ is not None and not isinstance(known_service_, (bytes, str)):
            raise Exception(
                f"Expected known_service_ to be a str, received: {type(known_service_)}"
            )

        if whitelist_cidrs_ is not None and not isinstance(
            whitelist_cidrs_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected whitelist_cidrs_ to be a Sequence, received: {type(whitelist_cidrs_)}"
            )

        self.known_service = known_service_
        self.whitelist_cidrs = whitelist_cidrs_
        self.unknown_fields = unknown_fields


class FirewallRuleArgs(Type):
    _toSchema = {"args": "args"}
    _toPy = {"args": "args"}

    def __init__(self, args=None, **unknown_fields):
        """Args : typing.Sequence[~FirewallRule]"""
        args_ = [FirewallRule.from_json(o) for o in args or []]

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, (bytes, str, list)):
            raise Exception(f"Expected args_ to be a Sequence, received: {type(args_)}")

        self.args = args_
        self.unknown_fields = unknown_fields


class FullStatus(Type):
    _toSchema = {
        "applications": "applications",
        "branches": "branches",
        "controller_timestamp": "controller-timestamp",
        "filesystems": "filesystems",
        "machines": "machines",
        "model": "model",
        "offers": "offers",
        "relations": "relations",
        "remote_applications": "remote-applications",
        "storage": "storage",
        "volumes": "volumes",
    }
    _toPy = {
        "applications": "applications",
        "branches": "branches",
        "controller-timestamp": "controller_timestamp",
        "filesystems": "filesystems",
        "machines": "machines",
        "model": "model",
        "offers": "offers",
        "relations": "relations",
        "remote-applications": "remote_applications",
        "storage": "storage",
        "volumes": "volumes",
    }

    def __init__(
        self,
        applications=None,
        branches=None,
        controller_timestamp=None,
        filesystems=None,
        machines=None,
        model=None,
        offers=None,
        relations=None,
        remote_applications=None,
        storage=None,
        volumes=None,
        **unknown_fields,
    ):
        """Applications : typing.Mapping[str, ~ApplicationStatus]
        branches : typing.Mapping[str, ~BranchStatus]
        controller_timestamp : str
        filesystems : typing.Sequence[~FilesystemDetails]
        machines : typing.Mapping[str, ~MachineStatus]
        model : ModelStatusInfo
        offers : typing.Mapping[str, ~ApplicationOfferStatus]
        relations : typing.Sequence[~RelationStatus]
        remote_applications : typing.Mapping[str, ~RemoteApplicationStatus]
        storage : typing.Sequence[~StorageDetails]
        volumes : typing.Sequence[~VolumeDetails]
        """
        applications_ = {
            k: ApplicationStatus.from_json(v)
            for k, v in (applications or dict()).items()
        }
        branches_ = {
            k: BranchStatus.from_json(v) for k, v in (branches or dict()).items()
        }
        controller_timestamp_ = controller_timestamp
        filesystems_ = [FilesystemDetails.from_json(o) for o in filesystems or []]
        machines_ = {
            k: MachineStatus.from_json(v) for k, v in (machines or dict()).items()
        }
        model_ = ModelStatusInfo.from_json(model) if model else None
        offers_ = {
            k: ApplicationOfferStatus.from_json(v)
            for k, v in (offers or dict()).items()
        }
        relations_ = [RelationStatus.from_json(o) for o in relations or []]
        remote_applications_ = {
            k: RemoteApplicationStatus.from_json(v)
            for k, v in (remote_applications or dict()).items()
        }
        storage_ = [StorageDetails.from_json(o) for o in storage or []]
        volumes_ = [VolumeDetails.from_json(o) for o in volumes or []]

        # Validate arguments against known Juju API types.
        if applications_ is not None and not isinstance(applications_, dict):
            raise Exception(
                f"Expected applications_ to be a Mapping, received: {type(applications_)}"
            )

        if branches_ is not None and not isinstance(branches_, dict):
            raise Exception(
                f"Expected branches_ to be a Mapping, received: {type(branches_)}"
            )

        if controller_timestamp_ is not None and not isinstance(
            controller_timestamp_, (bytes, str)
        ):
            raise Exception(
                f"Expected controller_timestamp_ to be a str, received: {type(controller_timestamp_)}"
            )

        if filesystems_ is not None and not isinstance(
            filesystems_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected filesystems_ to be a Sequence, received: {type(filesystems_)}"
            )

        if machines_ is not None and not isinstance(machines_, dict):
            raise Exception(
                f"Expected machines_ to be a Mapping, received: {type(machines_)}"
            )

        if model_ is not None and not isinstance(model_, (dict, ModelStatusInfo)):
            raise Exception(
                f"Expected model_ to be a ModelStatusInfo, received: {type(model_)}"
            )

        if offers_ is not None and not isinstance(offers_, dict):
            raise Exception(
                f"Expected offers_ to be a Mapping, received: {type(offers_)}"
            )

        if relations_ is not None and not isinstance(relations_, (bytes, str, list)):
            raise Exception(
                f"Expected relations_ to be a Sequence, received: {type(relations_)}"
            )

        if remote_applications_ is not None and not isinstance(
            remote_applications_, dict
        ):
            raise Exception(
                f"Expected remote_applications_ to be a Mapping, received: {type(remote_applications_)}"
            )

        if storage_ is not None and not isinstance(storage_, (bytes, str, list)):
            raise Exception(
                f"Expected storage_ to be a Sequence, received: {type(storage_)}"
            )

        if volumes_ is not None and not isinstance(volumes_, (bytes, str, list)):
            raise Exception(
                f"Expected volumes_ to be a Sequence, received: {type(volumes_)}"
            )

        self.applications = applications_
        self.branches = branches_
        self.controller_timestamp = controller_timestamp_
        self.filesystems = filesystems_
        self.machines = machines_
        self.model = model_
        self.offers = offers_
        self.relations = relations_
        self.remote_applications = remote_applications_
        self.storage = storage_
        self.volumes = volumes_
        self.unknown_fields = unknown_fields


class Generation(Type):
    _toSchema = {
        "applications": "applications",
        "branch": "branch",
        "completed": "completed",
        "completed_by": "completed-by",
        "created": "created",
        "created_by": "created-by",
        "generation_id": "generation-id",
    }
    _toPy = {
        "applications": "applications",
        "branch": "branch",
        "completed": "completed",
        "completed-by": "completed_by",
        "created": "created",
        "created-by": "created_by",
        "generation-id": "generation_id",
    }

    def __init__(
        self,
        applications=None,
        branch=None,
        completed=None,
        completed_by=None,
        created=None,
        created_by=None,
        generation_id=None,
        **unknown_fields,
    ):
        """Applications : typing.Sequence[~GenerationApplication]
        branch : str
        completed : int
        completed_by : str
        created : int
        created_by : str
        generation_id : int
        """
        applications_ = [GenerationApplication.from_json(o) for o in applications or []]
        branch_ = branch
        completed_ = completed
        completed_by_ = completed_by
        created_ = created
        created_by_ = created_by
        generation_id_ = generation_id

        # Validate arguments against known Juju API types.
        if applications_ is not None and not isinstance(
            applications_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected applications_ to be a Sequence, received: {type(applications_)}"
            )

        if branch_ is not None and not isinstance(branch_, (bytes, str)):
            raise Exception(f"Expected branch_ to be a str, received: {type(branch_)}")

        if completed_ is not None and not isinstance(completed_, int):
            raise Exception(
                f"Expected completed_ to be a int, received: {type(completed_)}"
            )

        if completed_by_ is not None and not isinstance(completed_by_, (bytes, str)):
            raise Exception(
                f"Expected completed_by_ to be a str, received: {type(completed_by_)}"
            )

        if created_ is not None and not isinstance(created_, int):
            raise Exception(
                f"Expected created_ to be a int, received: {type(created_)}"
            )

        if created_by_ is not None and not isinstance(created_by_, (bytes, str)):
            raise Exception(
                f"Expected created_by_ to be a str, received: {type(created_by_)}"
            )

        if generation_id_ is not None and not isinstance(generation_id_, int):
            raise Exception(
                f"Expected generation_id_ to be a int, received: {type(generation_id_)}"
            )

        self.applications = applications_
        self.branch = branch_
        self.completed = completed_
        self.completed_by = completed_by_
        self.created = created_
        self.created_by = created_by_
        self.generation_id = generation_id_
        self.unknown_fields = unknown_fields


class GenerationApplication(Type):
    _toSchema = {
        "application": "application",
        "config": "config",
        "pending": "pending",
        "progress": "progress",
        "tracking": "tracking",
    }
    _toPy = {
        "application": "application",
        "config": "config",
        "pending": "pending",
        "progress": "progress",
        "tracking": "tracking",
    }

    def __init__(
        self,
        application=None,
        config=None,
        pending=None,
        progress=None,
        tracking=None,
        **unknown_fields,
    ):
        """Application : str
        config : typing.Mapping[str, typing.Any]
        pending : typing.Sequence[str]
        progress : str
        tracking : typing.Sequence[str]
        """
        application_ = application
        config_ = config
        pending_ = pending
        progress_ = progress
        tracking_ = tracking

        # Validate arguments against known Juju API types.
        if application_ is not None and not isinstance(application_, (bytes, str)):
            raise Exception(
                f"Expected application_ to be a str, received: {type(application_)}"
            )

        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        if pending_ is not None and not isinstance(pending_, (bytes, str, list)):
            raise Exception(
                f"Expected pending_ to be a Sequence, received: {type(pending_)}"
            )

        if progress_ is not None and not isinstance(progress_, (bytes, str)):
            raise Exception(
                f"Expected progress_ to be a str, received: {type(progress_)}"
            )

        if tracking_ is not None and not isinstance(tracking_, (bytes, str, list)):
            raise Exception(
                f"Expected tracking_ to be a Sequence, received: {type(tracking_)}"
            )

        self.application = application_
        self.config = config_
        self.pending = pending_
        self.progress = progress_
        self.tracking = tracking_
        self.unknown_fields = unknown_fields


class GenerationId(Type):
    _toSchema = {"generation_id": "generation-id"}
    _toPy = {"generation-id": "generation_id"}

    def __init__(self, generation_id=None, **unknown_fields):
        """generation_id : int"""
        generation_id_ = generation_id

        # Validate arguments against known Juju API types.
        if generation_id_ is not None and not isinstance(generation_id_, int):
            raise Exception(
                f"Expected generation_id_ to be a int, received: {type(generation_id_)}"
            )

        self.generation_id = generation_id_
        self.unknown_fields = unknown_fields


class GenerationResult(Type):
    _toSchema = {"error": "error", "generation": "generation"}
    _toPy = {"error": "error", "generation": "generation"}

    def __init__(self, error=None, generation=None, **unknown_fields):
        """Error : Error
        generation : Generation
        """
        error_ = Error.from_json(error) if error else None
        generation_ = Generation.from_json(generation) if generation else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if generation_ is not None and not isinstance(generation_, (dict, Generation)):
            raise Exception(
                f"Expected generation_ to be a Generation, received: {type(generation_)}"
            )

        self.error = error_
        self.generation = generation_
        self.unknown_fields = unknown_fields


class GetConstraintsResults(Type):
    _toSchema = {"constraints": "constraints"}
    _toPy = {"constraints": "constraints"}

    def __init__(self, constraints=None, **unknown_fields):
        """Constraints : Value"""
        constraints_ = Value.from_json(constraints) if constraints else None

        # Validate arguments against known Juju API types.
        if constraints_ is not None and not isinstance(constraints_, (dict, Value)):
            raise Exception(
                f"Expected constraints_ to be a Value, received: {type(constraints_)}"
            )

        self.constraints = constraints_
        self.unknown_fields = unknown_fields


class GrantRevokeUserSecretArg(Type):
    _toSchema = {"applications": "applications", "label": "label", "uri": "uri"}
    _toPy = {"applications": "applications", "label": "label", "uri": "uri"}

    def __init__(self, applications=None, label=None, uri=None, **unknown_fields):
        """Applications : typing.Sequence[str]
        label : str
        uri : str
        """
        applications_ = applications
        label_ = label
        uri_ = uri

        # Validate arguments against known Juju API types.
        if applications_ is not None and not isinstance(
            applications_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected applications_ to be a Sequence, received: {type(applications_)}"
            )

        if label_ is not None and not isinstance(label_, (bytes, str)):
            raise Exception(f"Expected label_ to be a str, received: {type(label_)}")

        if uri_ is not None and not isinstance(uri_, (bytes, str)):
            raise Exception(f"Expected uri_ to be a str, received: {type(uri_)}")

        self.applications = applications_
        self.label = label_
        self.uri = uri_
        self.unknown_fields = unknown_fields


class HardwareCharacteristics(Type):
    _toSchema = {
        "arch": "arch",
        "availability_zone": "availability-zone",
        "cpu_cores": "cpu-cores",
        "cpu_power": "cpu-power",
        "mem": "mem",
        "root_disk": "root-disk",
        "root_disk_source": "root-disk-source",
        "tags": "tags",
        "virt_type": "virt-type",
    }
    _toPy = {
        "arch": "arch",
        "availability-zone": "availability_zone",
        "cpu-cores": "cpu_cores",
        "cpu-power": "cpu_power",
        "mem": "mem",
        "root-disk": "root_disk",
        "root-disk-source": "root_disk_source",
        "tags": "tags",
        "virt-type": "virt_type",
    }

    def __init__(
        self,
        arch=None,
        availability_zone=None,
        cpu_cores=None,
        cpu_power=None,
        mem=None,
        root_disk=None,
        root_disk_source=None,
        tags=None,
        virt_type=None,
        **unknown_fields,
    ):
        """Arch : str
        availability_zone : str
        cpu_cores : int
        cpu_power : int
        mem : int
        root_disk : int
        root_disk_source : str
        tags : typing.Sequence[str]
        virt_type : str
        """
        arch_ = arch
        availability_zone_ = availability_zone
        cpu_cores_ = cpu_cores
        cpu_power_ = cpu_power
        mem_ = mem
        root_disk_ = root_disk
        root_disk_source_ = root_disk_source
        tags_ = tags
        virt_type_ = virt_type

        # Validate arguments against known Juju API types.
        if arch_ is not None and not isinstance(arch_, (bytes, str)):
            raise Exception(f"Expected arch_ to be a str, received: {type(arch_)}")

        if availability_zone_ is not None and not isinstance(
            availability_zone_, (bytes, str)
        ):
            raise Exception(
                f"Expected availability_zone_ to be a str, received: {type(availability_zone_)}"
            )

        if cpu_cores_ is not None and not isinstance(cpu_cores_, int):
            raise Exception(
                f"Expected cpu_cores_ to be a int, received: {type(cpu_cores_)}"
            )

        if cpu_power_ is not None and not isinstance(cpu_power_, int):
            raise Exception(
                f"Expected cpu_power_ to be a int, received: {type(cpu_power_)}"
            )

        if mem_ is not None and not isinstance(mem_, int):
            raise Exception(f"Expected mem_ to be a int, received: {type(mem_)}")

        if root_disk_ is not None and not isinstance(root_disk_, int):
            raise Exception(
                f"Expected root_disk_ to be a int, received: {type(root_disk_)}"
            )

        if root_disk_source_ is not None and not isinstance(
            root_disk_source_, (bytes, str)
        ):
            raise Exception(
                f"Expected root_disk_source_ to be a str, received: {type(root_disk_source_)}"
            )

        if tags_ is not None and not isinstance(tags_, (bytes, str, list)):
            raise Exception(f"Expected tags_ to be a Sequence, received: {type(tags_)}")

        if virt_type_ is not None and not isinstance(virt_type_, (bytes, str)):
            raise Exception(
                f"Expected virt_type_ to be a str, received: {type(virt_type_)}"
            )

        self.arch = arch_
        self.availability_zone = availability_zone_
        self.cpu_cores = cpu_cores_
        self.cpu_power = cpu_power_
        self.mem = mem_
        self.root_disk = root_disk_
        self.root_disk_source = root_disk_source_
        self.tags = tags_
        self.virt_type = virt_type_
        self.unknown_fields = unknown_fields


class History(Type):
    _toSchema = {"error": "error", "statuses": "statuses"}
    _toPy = {"error": "error", "statuses": "statuses"}

    def __init__(self, error=None, statuses=None, **unknown_fields):
        """Error : Error
        statuses : typing.Sequence[~DetailedStatus]
        """
        error_ = Error.from_json(error) if error else None
        statuses_ = [DetailedStatus.from_json(o) for o in statuses or []]

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if statuses_ is not None and not isinstance(statuses_, (bytes, str, list)):
            raise Exception(
                f"Expected statuses_ to be a Sequence, received: {type(statuses_)}"
            )

        self.error = error_
        self.statuses = statuses_
        self.unknown_fields = unknown_fields


class HostPort(Type):
    _toSchema = {
        "address": "Address",
        "cidr": "cidr",
        "config_type": "config-type",
        "is_secondary": "is-secondary",
        "port": "port",
        "scope": "scope",
        "space_id": "space-id",
        "space_name": "space-name",
        "type_": "type",
        "value": "value",
    }
    _toPy = {
        "Address": "address",
        "cidr": "cidr",
        "config-type": "config_type",
        "is-secondary": "is_secondary",
        "port": "port",
        "scope": "scope",
        "space-id": "space_id",
        "space-name": "space_name",
        "type": "type_",
        "value": "value",
    }

    def __init__(
        self,
        address=None,
        cidr=None,
        config_type=None,
        is_secondary=None,
        port=None,
        scope=None,
        space_id=None,
        space_name=None,
        type_=None,
        value=None,
        **unknown_fields,
    ):
        """Address : Address
        cidr : str
        config_type : str
        is_secondary : bool
        port : int
        scope : str
        space_id : str
        space_name : str
        type_ : str
        value : str
        """
        address_ = Address.from_json(address) if address else None
        cidr_ = cidr
        config_type_ = config_type
        is_secondary_ = is_secondary
        port_ = port
        scope_ = scope
        space_id_ = space_id
        space_name_ = space_name
        type__ = type_
        value_ = value

        # Validate arguments against known Juju API types.
        if address_ is not None and not isinstance(address_, (dict, Address)):
            raise Exception(
                f"Expected address_ to be a Address, received: {type(address_)}"
            )

        if cidr_ is not None and not isinstance(cidr_, (bytes, str)):
            raise Exception(f"Expected cidr_ to be a str, received: {type(cidr_)}")

        if config_type_ is not None and not isinstance(config_type_, (bytes, str)):
            raise Exception(
                f"Expected config_type_ to be a str, received: {type(config_type_)}"
            )

        if is_secondary_ is not None and not isinstance(is_secondary_, bool):
            raise Exception(
                f"Expected is_secondary_ to be a bool, received: {type(is_secondary_)}"
            )

        if port_ is not None and not isinstance(port_, int):
            raise Exception(f"Expected port_ to be a int, received: {type(port_)}")

        if scope_ is not None and not isinstance(scope_, (bytes, str)):
            raise Exception(f"Expected scope_ to be a str, received: {type(scope_)}")

        if space_id_ is not None and not isinstance(space_id_, (bytes, str)):
            raise Exception(
                f"Expected space_id_ to be a str, received: {type(space_id_)}"
            )

        if space_name_ is not None and not isinstance(space_name_, (bytes, str)):
            raise Exception(
                f"Expected space_name_ to be a str, received: {type(space_name_)}"
            )

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        if value_ is not None and not isinstance(value_, (bytes, str)):
            raise Exception(f"Expected value_ to be a str, received: {type(value_)}")

        self.address = address_
        self.cidr = cidr_
        self.config_type = config_type_
        self.is_secondary = is_secondary_
        self.port = port_
        self.scope = scope_
        self.space_id = space_id_
        self.space_name = space_name_
        self.type_ = type__
        self.value = value_
        self.unknown_fields = unknown_fields


class HostedModelConfig(Type):
    _toSchema = {
        "cloud_spec": "cloud-spec",
        "config": "config",
        "error": "error",
        "name": "name",
        "owner": "owner",
    }
    _toPy = {
        "cloud-spec": "cloud_spec",
        "config": "config",
        "error": "error",
        "name": "name",
        "owner": "owner",
    }

    def __init__(
        self,
        cloud_spec=None,
        config=None,
        error=None,
        name=None,
        owner=None,
        **unknown_fields,
    ):
        """cloud_spec : CloudSpec
        config : typing.Mapping[str, typing.Any]
        error : Error
        name : str
        owner : str
        """
        cloud_spec_ = CloudSpec.from_json(cloud_spec) if cloud_spec else None
        config_ = config
        error_ = Error.from_json(error) if error else None
        name_ = name
        owner_ = owner

        # Validate arguments against known Juju API types.
        if cloud_spec_ is not None and not isinstance(cloud_spec_, (dict, CloudSpec)):
            raise Exception(
                f"Expected cloud_spec_ to be a CloudSpec, received: {type(cloud_spec_)}"
            )

        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if owner_ is not None and not isinstance(owner_, (bytes, str)):
            raise Exception(f"Expected owner_ to be a str, received: {type(owner_)}")

        self.cloud_spec = cloud_spec_
        self.config = config_
        self.error = error_
        self.name = name_
        self.owner = owner_
        self.unknown_fields = unknown_fields


class HostedModelConfigsResults(Type):
    _toSchema = {"models": "models"}
    _toPy = {"models": "models"}

    def __init__(self, models=None, **unknown_fields):
        """Models : typing.Sequence[~HostedModelConfig]"""
        models_ = [HostedModelConfig.from_json(o) for o in models or []]

        # Validate arguments against known Juju API types.
        if models_ is not None and not isinstance(models_, (bytes, str, list)):
            raise Exception(
                f"Expected models_ to be a Sequence, received: {type(models_)}"
            )

        self.models = models_
        self.unknown_fields = unknown_fields


class ImageMetadataFilter(Type):
    _toSchema = {
        "arches": "arches",
        "region": "region",
        "root_storage_type": "root-storage-type",
        "stream": "stream",
        "versions": "versions",
        "virt_type": "virt-type",
    }
    _toPy = {
        "arches": "arches",
        "region": "region",
        "root-storage-type": "root_storage_type",
        "stream": "stream",
        "versions": "versions",
        "virt-type": "virt_type",
    }

    def __init__(
        self,
        arches=None,
        region=None,
        root_storage_type=None,
        stream=None,
        versions=None,
        virt_type=None,
        **unknown_fields,
    ):
        """Arches : typing.Sequence[str]
        region : str
        root_storage_type : str
        stream : str
        versions : typing.Sequence[str]
        virt_type : str
        """
        arches_ = arches
        region_ = region
        root_storage_type_ = root_storage_type
        stream_ = stream
        versions_ = versions
        virt_type_ = virt_type

        # Validate arguments against known Juju API types.
        if arches_ is not None and not isinstance(arches_, (bytes, str, list)):
            raise Exception(
                f"Expected arches_ to be a Sequence, received: {type(arches_)}"
            )

        if region_ is not None and not isinstance(region_, (bytes, str)):
            raise Exception(f"Expected region_ to be a str, received: {type(region_)}")

        if root_storage_type_ is not None and not isinstance(
            root_storage_type_, (bytes, str)
        ):
            raise Exception(
                f"Expected root_storage_type_ to be a str, received: {type(root_storage_type_)}"
            )

        if stream_ is not None and not isinstance(stream_, (bytes, str)):
            raise Exception(f"Expected stream_ to be a str, received: {type(stream_)}")

        if versions_ is not None and not isinstance(versions_, (bytes, str, list)):
            raise Exception(
                f"Expected versions_ to be a Sequence, received: {type(versions_)}"
            )

        if virt_type_ is not None and not isinstance(virt_type_, (bytes, str)):
            raise Exception(
                f"Expected virt_type_ to be a str, received: {type(virt_type_)}"
            )

        self.arches = arches_
        self.region = region_
        self.root_storage_type = root_storage_type_
        self.stream = stream_
        self.versions = versions_
        self.virt_type = virt_type_
        self.unknown_fields = unknown_fields


class ImportStorageDetails(Type):
    _toSchema = {"storage_tag": "storage-tag"}
    _toPy = {"storage-tag": "storage_tag"}

    def __init__(self, storage_tag=None, **unknown_fields):
        """storage_tag : str"""
        storage_tag_ = storage_tag

        # Validate arguments against known Juju API types.
        if storage_tag_ is not None and not isinstance(storage_tag_, (bytes, str)):
            raise Exception(
                f"Expected storage_tag_ to be a str, received: {type(storage_tag_)}"
            )

        self.storage_tag = storage_tag_
        self.unknown_fields = unknown_fields


class ImportStorageParams(Type):
    _toSchema = {
        "kind": "kind",
        "pool": "pool",
        "provider_id": "provider-id",
        "storage_name": "storage-name",
    }
    _toPy = {
        "kind": "kind",
        "pool": "pool",
        "provider-id": "provider_id",
        "storage-name": "storage_name",
    }

    def __init__(
        self,
        kind=None,
        pool=None,
        provider_id=None,
        storage_name=None,
        **unknown_fields,
    ):
        """Kind : int
        pool : str
        provider_id : str
        storage_name : str
        """
        kind_ = kind
        pool_ = pool
        provider_id_ = provider_id
        storage_name_ = storage_name

        # Validate arguments against known Juju API types.
        if kind_ is not None and not isinstance(kind_, int):
            raise Exception(f"Expected kind_ to be a int, received: {type(kind_)}")

        if pool_ is not None and not isinstance(pool_, (bytes, str)):
            raise Exception(f"Expected pool_ to be a str, received: {type(pool_)}")

        if provider_id_ is not None and not isinstance(provider_id_, (bytes, str)):
            raise Exception(
                f"Expected provider_id_ to be a str, received: {type(provider_id_)}"
            )

        if storage_name_ is not None and not isinstance(storage_name_, (bytes, str)):
            raise Exception(
                f"Expected storage_name_ to be a str, received: {type(storage_name_)}"
            )

        self.kind = kind_
        self.pool = pool_
        self.provider_id = provider_id_
        self.storage_name = storage_name_
        self.unknown_fields = unknown_fields


class ImportStorageResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : ImportStorageDetails
        """
        error_ = Error.from_json(error) if error else None
        result_ = ImportStorageDetails.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(
            result_, (dict, ImportStorageDetails)
        ):
            raise Exception(
                f"Expected result_ to be a ImportStorageDetails, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class ImportStorageResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ImportStorageResult]"""
        results_ = [ImportStorageResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class InitiateMigrationArgs(Type):
    _toSchema = {"specs": "specs"}
    _toPy = {"specs": "specs"}

    def __init__(self, specs=None, **unknown_fields):
        """Specs : typing.Sequence[~MigrationSpec]"""
        specs_ = [MigrationSpec.from_json(o) for o in specs or []]

        # Validate arguments against known Juju API types.
        if specs_ is not None and not isinstance(specs_, (bytes, str, list)):
            raise Exception(
                f"Expected specs_ to be a Sequence, received: {type(specs_)}"
            )

        self.specs = specs_
        self.unknown_fields = unknown_fields


class InitiateMigrationResult(Type):
    _toSchema = {
        "error": "error",
        "migration_id": "migration-id",
        "model_tag": "model-tag",
    }
    _toPy = {"error": "error", "migration-id": "migration_id", "model-tag": "model_tag"}

    def __init__(self, error=None, migration_id=None, model_tag=None, **unknown_fields):
        """Error : Error
        migration_id : str
        model_tag : str
        """
        error_ = Error.from_json(error) if error else None
        migration_id_ = migration_id
        model_tag_ = model_tag

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if migration_id_ is not None and not isinstance(migration_id_, (bytes, str)):
            raise Exception(
                f"Expected migration_id_ to be a str, received: {type(migration_id_)}"
            )

        if model_tag_ is not None and not isinstance(model_tag_, (bytes, str)):
            raise Exception(
                f"Expected model_tag_ to be a str, received: {type(model_tag_)}"
            )

        self.error = error_
        self.migration_id = migration_id_
        self.model_tag = model_tag_
        self.unknown_fields = unknown_fields


class InitiateMigrationResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~InitiateMigrationResult]"""
        results_ = [InitiateMigrationResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class InstanceType(Type):
    _toSchema = {
        "arches": "arches",
        "cost": "cost",
        "cpu_cores": "cpu-cores",
        "memory": "memory",
        "name": "name",
        "root_disk": "root-disk",
        "virt_type": "virt-type",
    }
    _toPy = {
        "arches": "arches",
        "cost": "cost",
        "cpu-cores": "cpu_cores",
        "memory": "memory",
        "name": "name",
        "root-disk": "root_disk",
        "virt-type": "virt_type",
    }

    def __init__(
        self,
        arches=None,
        cost=None,
        cpu_cores=None,
        memory=None,
        name=None,
        root_disk=None,
        virt_type=None,
        **unknown_fields,
    ):
        """Arches : typing.Sequence[str]
        cost : int
        cpu_cores : int
        memory : int
        name : str
        root_disk : int
        virt_type : str
        """
        arches_ = arches
        cost_ = cost
        cpu_cores_ = cpu_cores
        memory_ = memory
        name_ = name
        root_disk_ = root_disk
        virt_type_ = virt_type

        # Validate arguments against known Juju API types.
        if arches_ is not None and not isinstance(arches_, (bytes, str, list)):
            raise Exception(
                f"Expected arches_ to be a Sequence, received: {type(arches_)}"
            )

        if cost_ is not None and not isinstance(cost_, int):
            raise Exception(f"Expected cost_ to be a int, received: {type(cost_)}")

        if cpu_cores_ is not None and not isinstance(cpu_cores_, int):
            raise Exception(
                f"Expected cpu_cores_ to be a int, received: {type(cpu_cores_)}"
            )

        if memory_ is not None and not isinstance(memory_, int):
            raise Exception(f"Expected memory_ to be a int, received: {type(memory_)}")

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if root_disk_ is not None and not isinstance(root_disk_, int):
            raise Exception(
                f"Expected root_disk_ to be a int, received: {type(root_disk_)}"
            )

        if virt_type_ is not None and not isinstance(virt_type_, (bytes, str)):
            raise Exception(
                f"Expected virt_type_ to be a str, received: {type(virt_type_)}"
            )

        self.arches = arches_
        self.cost = cost_
        self.cpu_cores = cpu_cores_
        self.memory = memory_
        self.name = name_
        self.root_disk = root_disk_
        self.virt_type = virt_type_
        self.unknown_fields = unknown_fields


class InstanceTypesResult(Type):
    _toSchema = {
        "cost_currency": "cost-currency",
        "cost_divisor": "cost-divisor",
        "cost_unit": "cost-unit",
        "error": "error",
        "instance_types": "instance-types",
    }
    _toPy = {
        "cost-currency": "cost_currency",
        "cost-divisor": "cost_divisor",
        "cost-unit": "cost_unit",
        "error": "error",
        "instance-types": "instance_types",
    }

    def __init__(
        self,
        cost_currency=None,
        cost_divisor=None,
        cost_unit=None,
        error=None,
        instance_types=None,
        **unknown_fields,
    ):
        """cost_currency : str
        cost_divisor : int
        cost_unit : str
        error : Error
        instance_types : typing.Sequence[~InstanceType]
        """
        cost_currency_ = cost_currency
        cost_divisor_ = cost_divisor
        cost_unit_ = cost_unit
        error_ = Error.from_json(error) if error else None
        instance_types_ = [InstanceType.from_json(o) for o in instance_types or []]

        # Validate arguments against known Juju API types.
        if cost_currency_ is not None and not isinstance(cost_currency_, (bytes, str)):
            raise Exception(
                f"Expected cost_currency_ to be a str, received: {type(cost_currency_)}"
            )

        if cost_divisor_ is not None and not isinstance(cost_divisor_, int):
            raise Exception(
                f"Expected cost_divisor_ to be a int, received: {type(cost_divisor_)}"
            )

        if cost_unit_ is not None and not isinstance(cost_unit_, (bytes, str)):
            raise Exception(
                f"Expected cost_unit_ to be a str, received: {type(cost_unit_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if instance_types_ is not None and not isinstance(
            instance_types_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected instance_types_ to be a Sequence, received: {type(instance_types_)}"
            )

        self.cost_currency = cost_currency_
        self.cost_divisor = cost_divisor_
        self.cost_unit = cost_unit_
        self.error = error_
        self.instance_types = instance_types_
        self.unknown_fields = unknown_fields


class InstanceTypesResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~InstanceTypesResult]"""
        results_ = [InstanceTypesResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class IntResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : int
        """
        error_ = Error.from_json(error) if error else None
        result_ = result

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, int):
            raise Exception(f"Expected result_ to be a int, received: {type(result_)}")

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class InvalidateCredentialArg(Type):
    _toSchema = {"reason": "reason"}
    _toPy = {"reason": "reason"}

    def __init__(self, reason=None, **unknown_fields):
        """Reason : str"""
        reason_ = reason

        # Validate arguments against known Juju API types.
        if reason_ is not None and not isinstance(reason_, (bytes, str)):
            raise Exception(f"Expected reason_ to be a str, received: {type(reason_)}")

        self.reason = reason_
        self.unknown_fields = unknown_fields


class IsMeteredResult(Type):
    _toSchema = {"metered": "metered"}
    _toPy = {"metered": "metered"}

    def __init__(self, metered=None, **unknown_fields):
        """Metered : bool"""
        metered_ = metered

        # Validate arguments against known Juju API types.
        if metered_ is not None and not isinstance(metered_, bool):
            raise Exception(
                f"Expected metered_ to be a bool, received: {type(metered_)}"
            )

        self.metered = metered_
        self.unknown_fields = unknown_fields


class LXDProfile(Type):
    _toSchema = {"config": "config", "description": "description", "devices": "devices"}
    _toPy = {"config": "config", "description": "description", "devices": "devices"}

    def __init__(self, config=None, description=None, devices=None, **unknown_fields):
        """Config : typing.Mapping[str, str]
        description : str
        devices : typing.Mapping[str, typing.Any]
        """
        config_ = config
        description_ = description
        devices_ = devices

        # Validate arguments against known Juju API types.
        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if devices_ is not None and not isinstance(devices_, dict):
            raise Exception(
                f"Expected devices_ to be a Mapping, received: {type(devices_)}"
            )

        self.config = config_
        self.description = description_
        self.devices = devices_
        self.unknown_fields = unknown_fields


class ListCloudImageMetadataResult(Type):
    _toSchema = {"result": "result"}
    _toPy = {"result": "result"}

    def __init__(self, result=None, **unknown_fields):
        """Result : typing.Sequence[~CloudImageMetadata]"""
        result_ = [CloudImageMetadata.from_json(o) for o in result or []]

        # Validate arguments against known Juju API types.
        if result_ is not None and not isinstance(result_, (bytes, str, list)):
            raise Exception(
                f"Expected result_ to be a Sequence, received: {type(result_)}"
            )

        self.result = result_
        self.unknown_fields = unknown_fields


class ListCloudInfo(Type):
    _toSchema = {"clouddetails": "CloudDetails", "user_access": "user-access"}
    _toPy = {"CloudDetails": "clouddetails", "user-access": "user_access"}

    def __init__(self, clouddetails=None, user_access=None, **unknown_fields):
        """Clouddetails : CloudDetails
        user_access : str
        """
        clouddetails_ = CloudDetails.from_json(clouddetails) if clouddetails else None
        user_access_ = user_access

        # Validate arguments against known Juju API types.
        if clouddetails_ is not None and not isinstance(
            clouddetails_, (dict, CloudDetails)
        ):
            raise Exception(
                f"Expected clouddetails_ to be a CloudDetails, received: {type(clouddetails_)}"
            )

        if user_access_ is not None and not isinstance(user_access_, (bytes, str)):
            raise Exception(
                f"Expected user_access_ to be a str, received: {type(user_access_)}"
            )

        self.clouddetails = clouddetails_
        self.user_access = user_access_
        self.unknown_fields = unknown_fields


class ListCloudInfoResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : ListCloudInfo
        """
        error_ = Error.from_json(error) if error else None
        result_ = ListCloudInfo.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (dict, ListCloudInfo)):
            raise Exception(
                f"Expected result_ to be a ListCloudInfo, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class ListCloudInfoResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ListCloudInfoResult]"""
        results_ = [ListCloudInfoResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ListCloudsRequest(Type):
    _toSchema = {"all_": "all", "user_tag": "user-tag"}
    _toPy = {"all": "all_", "user-tag": "user_tag"}

    def __init__(self, all_=None, user_tag=None, **unknown_fields):
        """all_ : bool
        user_tag : str
        """
        all__ = all_
        user_tag_ = user_tag

        # Validate arguments against known Juju API types.
        if all__ is not None and not isinstance(all__, bool):
            raise Exception(f"Expected all__ to be a bool, received: {type(all__)}")

        if user_tag_ is not None and not isinstance(user_tag_, (bytes, str)):
            raise Exception(
                f"Expected user_tag_ to be a str, received: {type(user_tag_)}"
            )

        self.all_ = all__
        self.user_tag = user_tag_
        self.unknown_fields = unknown_fields


class ListFirewallRulesResults(Type):
    _toSchema = {"rules": "Rules"}
    _toPy = {"Rules": "rules"}

    def __init__(self, rules=None, **unknown_fields):
        """Rules : typing.Sequence[~FirewallRule]"""
        rules_ = [FirewallRule.from_json(o) for o in rules or []]

        # Validate arguments against known Juju API types.
        if rules_ is not None and not isinstance(rules_, (bytes, str, list)):
            raise Exception(
                f"Expected rules_ to be a Sequence, received: {type(rules_)}"
            )

        self.rules = rules_
        self.unknown_fields = unknown_fields


class ListResourcesArgs(Type):
    _toSchema = {"entities": "entities"}
    _toPy = {"entities": "entities"}

    def __init__(self, entities=None, **unknown_fields):
        """Entities : typing.Sequence[~Entity]"""
        entities_ = [Entity.from_json(o) for o in entities or []]

        # Validate arguments against known Juju API types.
        if entities_ is not None and not isinstance(entities_, (bytes, str, list)):
            raise Exception(
                f"Expected entities_ to be a Sequence, received: {type(entities_)}"
            )

        self.entities = entities_
        self.unknown_fields = unknown_fields


class ListSSHKeys(Type):
    _toSchema = {"entities": "entities", "mode": "mode"}
    _toPy = {"entities": "entities", "mode": "mode"}

    def __init__(self, entities=None, mode=None, **unknown_fields):
        """Entities : Entities
        mode : bool
        """
        entities_ = Entities.from_json(entities) if entities else None
        mode_ = mode

        # Validate arguments against known Juju API types.
        if entities_ is not None and not isinstance(entities_, (dict, Entities)):
            raise Exception(
                f"Expected entities_ to be a Entities, received: {type(entities_)}"
            )

        if mode_ is not None and not isinstance(mode_, bool):
            raise Exception(f"Expected mode_ to be a bool, received: {type(mode_)}")

        self.entities = entities_
        self.mode = mode_
        self.unknown_fields = unknown_fields


class ListSecretBackendsArgs(Type):
    _toSchema = {"names": "names", "reveal": "reveal"}
    _toPy = {"names": "names", "reveal": "reveal"}

    def __init__(self, names=None, reveal=None, **unknown_fields):
        """Names : typing.Sequence[str]
        reveal : bool
        """
        names_ = names
        reveal_ = reveal

        # Validate arguments against known Juju API types.
        if names_ is not None and not isinstance(names_, (bytes, str, list)):
            raise Exception(
                f"Expected names_ to be a Sequence, received: {type(names_)}"
            )

        if reveal_ is not None and not isinstance(reveal_, bool):
            raise Exception(f"Expected reveal_ to be a bool, received: {type(reveal_)}")

        self.names = names_
        self.reveal = reveal_
        self.unknown_fields = unknown_fields


class ListSecretBackendsResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~SecretBackendResult]"""
        results_ = [SecretBackendResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ListSecretResult(Type):
    _toSchema = {
        "access": "access",
        "create_time": "create-time",
        "description": "description",
        "label": "label",
        "latest_expire_time": "latest-expire-time",
        "latest_revision": "latest-revision",
        "latest_revision_checksum": "latest-revision-checksum",
        "next_rotate_time": "next-rotate-time",
        "owner_tag": "owner-tag",
        "revisions": "revisions",
        "rotate_policy": "rotate-policy",
        "update_time": "update-time",
        "uri": "uri",
        "value": "value",
        "version": "version",
    }
    _toPy = {
        "access": "access",
        "create-time": "create_time",
        "description": "description",
        "label": "label",
        "latest-expire-time": "latest_expire_time",
        "latest-revision": "latest_revision",
        "latest-revision-checksum": "latest_revision_checksum",
        "next-rotate-time": "next_rotate_time",
        "owner-tag": "owner_tag",
        "revisions": "revisions",
        "rotate-policy": "rotate_policy",
        "update-time": "update_time",
        "uri": "uri",
        "value": "value",
        "version": "version",
    }

    def __init__(
        self,
        access=None,
        create_time=None,
        description=None,
        label=None,
        latest_expire_time=None,
        latest_revision=None,
        latest_revision_checksum=None,
        next_rotate_time=None,
        owner_tag=None,
        revisions=None,
        rotate_policy=None,
        update_time=None,
        uri=None,
        value=None,
        version=None,
        **unknown_fields,
    ):
        """Access : typing.Sequence[~AccessInfo]
        create_time : str
        description : str
        label : str
        latest_expire_time : str
        latest_revision : int
        latest_revision_checksum : str
        next_rotate_time : str
        owner_tag : str
        revisions : typing.Sequence[~SecretRevision]
        rotate_policy : str
        update_time : str
        uri : str
        value : SecretValueResult
        version : int
        """
        access_ = [AccessInfo.from_json(o) for o in access or []]
        create_time_ = create_time
        description_ = description
        label_ = label
        latest_expire_time_ = latest_expire_time
        latest_revision_ = latest_revision
        latest_revision_checksum_ = latest_revision_checksum
        next_rotate_time_ = next_rotate_time
        owner_tag_ = owner_tag
        revisions_ = [SecretRevision.from_json(o) for o in revisions or []]
        rotate_policy_ = rotate_policy
        update_time_ = update_time
        uri_ = uri
        value_ = SecretValueResult.from_json(value) if value else None
        version_ = version

        # Validate arguments against known Juju API types.
        if access_ is not None and not isinstance(access_, (bytes, str, list)):
            raise Exception(
                f"Expected access_ to be a Sequence, received: {type(access_)}"
            )

        if create_time_ is not None and not isinstance(create_time_, (bytes, str)):
            raise Exception(
                f"Expected create_time_ to be a str, received: {type(create_time_)}"
            )

        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if label_ is not None and not isinstance(label_, (bytes, str)):
            raise Exception(f"Expected label_ to be a str, received: {type(label_)}")

        if latest_expire_time_ is not None and not isinstance(
            latest_expire_time_, (bytes, str)
        ):
            raise Exception(
                f"Expected latest_expire_time_ to be a str, received: {type(latest_expire_time_)}"
            )

        if latest_revision_ is not None and not isinstance(latest_revision_, int):
            raise Exception(
                f"Expected latest_revision_ to be a int, received: {type(latest_revision_)}"
            )

        if latest_revision_checksum_ is not None and not isinstance(
            latest_revision_checksum_, (bytes, str)
        ):
            raise Exception(
                f"Expected latest_revision_checksum_ to be a str, received: {type(latest_revision_checksum_)}"
            )

        if next_rotate_time_ is not None and not isinstance(
            next_rotate_time_, (bytes, str)
        ):
            raise Exception(
                f"Expected next_rotate_time_ to be a str, received: {type(next_rotate_time_)}"
            )

        if owner_tag_ is not None and not isinstance(owner_tag_, (bytes, str)):
            raise Exception(
                f"Expected owner_tag_ to be a str, received: {type(owner_tag_)}"
            )

        if revisions_ is not None and not isinstance(revisions_, (bytes, str, list)):
            raise Exception(
                f"Expected revisions_ to be a Sequence, received: {type(revisions_)}"
            )

        if rotate_policy_ is not None and not isinstance(rotate_policy_, (bytes, str)):
            raise Exception(
                f"Expected rotate_policy_ to be a str, received: {type(rotate_policy_)}"
            )

        if update_time_ is not None and not isinstance(update_time_, (bytes, str)):
            raise Exception(
                f"Expected update_time_ to be a str, received: {type(update_time_)}"
            )

        if uri_ is not None and not isinstance(uri_, (bytes, str)):
            raise Exception(f"Expected uri_ to be a str, received: {type(uri_)}")

        if value_ is not None and not isinstance(value_, (dict, SecretValueResult)):
            raise Exception(
                f"Expected value_ to be a SecretValueResult, received: {type(value_)}"
            )

        if version_ is not None and not isinstance(version_, int):
            raise Exception(
                f"Expected version_ to be a int, received: {type(version_)}"
            )

        self.access = access_
        self.create_time = create_time_
        self.description = description_
        self.label = label_
        self.latest_expire_time = latest_expire_time_
        self.latest_revision = latest_revision_
        self.latest_revision_checksum = latest_revision_checksum_
        self.next_rotate_time = next_rotate_time_
        self.owner_tag = owner_tag_
        self.revisions = revisions_
        self.rotate_policy = rotate_policy_
        self.update_time = update_time_
        self.uri = uri_
        self.value = value_
        self.version = version_
        self.unknown_fields = unknown_fields


class ListSecretResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ListSecretResult]"""
        results_ = [ListSecretResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ListSecretsArgs(Type):
    _toSchema = {"filter_": "filter", "show_secrets": "show-secrets"}
    _toPy = {"filter": "filter_", "show-secrets": "show_secrets"}

    def __init__(self, filter_=None, show_secrets=None, **unknown_fields):
        """filter_ : SecretsFilter
        show_secrets : bool
        """
        filter__ = SecretsFilter.from_json(filter_) if filter_ else None
        show_secrets_ = show_secrets

        # Validate arguments against known Juju API types.
        if filter__ is not None and not isinstance(filter__, (dict, SecretsFilter)):
            raise Exception(
                f"Expected filter__ to be a SecretsFilter, received: {type(filter__)}"
            )

        if show_secrets_ is not None and not isinstance(show_secrets_, bool):
            raise Exception(
                f"Expected show_secrets_ to be a bool, received: {type(show_secrets_)}"
            )

        self.filter_ = filter__
        self.show_secrets = show_secrets_
        self.unknown_fields = unknown_fields


class ListSpacesResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~Space]"""
        results_ = [Space.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ListSubnetsResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~Subnet]"""
        results_ = [Subnet.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class LoginRequest(Type):
    _toSchema = {
        "auth_tag": "auth-tag",
        "bakery_version": "bakery-version",
        "cli_args": "cli-args",
        "client_version": "client-version",
        "credentials": "credentials",
        "macaroons": "macaroons",
        "nonce": "nonce",
        "token": "token",
        "user_data": "user-data",
    }
    _toPy = {
        "auth-tag": "auth_tag",
        "bakery-version": "bakery_version",
        "cli-args": "cli_args",
        "client-version": "client_version",
        "credentials": "credentials",
        "macaroons": "macaroons",
        "nonce": "nonce",
        "token": "token",
        "user-data": "user_data",
    }

    def __init__(
        self,
        auth_tag=None,
        bakery_version=None,
        cli_args=None,
        client_version=None,
        credentials=None,
        macaroons=None,
        nonce=None,
        token=None,
        user_data=None,
        **unknown_fields,
    ):
        """auth_tag : str
        bakery_version : int
        cli_args : str
        client_version : str
        credentials : str
        macaroons : typing.Sequence[~Macaroon]
        nonce : str
        token : str
        user_data : str
        """
        auth_tag_ = auth_tag
        bakery_version_ = bakery_version
        cli_args_ = cli_args
        client_version_ = client_version
        credentials_ = credentials
        macaroons_ = [Macaroon.from_json(o) for o in macaroons or []]
        nonce_ = nonce
        token_ = token
        user_data_ = user_data

        # Validate arguments against known Juju API types.
        if auth_tag_ is not None and not isinstance(auth_tag_, (bytes, str)):
            raise Exception(
                f"Expected auth_tag_ to be a str, received: {type(auth_tag_)}"
            )

        if bakery_version_ is not None and not isinstance(bakery_version_, int):
            raise Exception(
                f"Expected bakery_version_ to be a int, received: {type(bakery_version_)}"
            )

        if cli_args_ is not None and not isinstance(cli_args_, (bytes, str)):
            raise Exception(
                f"Expected cli_args_ to be a str, received: {type(cli_args_)}"
            )

        if client_version_ is not None and not isinstance(
            client_version_, (bytes, str)
        ):
            raise Exception(
                f"Expected client_version_ to be a str, received: {type(client_version_)}"
            )

        if credentials_ is not None and not isinstance(credentials_, (bytes, str)):
            raise Exception(
                f"Expected credentials_ to be a str, received: {type(credentials_)}"
            )

        if macaroons_ is not None and not isinstance(macaroons_, (bytes, str, list)):
            raise Exception(
                f"Expected macaroons_ to be a Sequence, received: {type(macaroons_)}"
            )

        if nonce_ is not None and not isinstance(nonce_, (bytes, str)):
            raise Exception(f"Expected nonce_ to be a str, received: {type(nonce_)}")

        if token_ is not None and not isinstance(token_, (bytes, str)):
            raise Exception(f"Expected token_ to be a str, received: {type(token_)}")

        if user_data_ is not None and not isinstance(user_data_, (bytes, str)):
            raise Exception(
                f"Expected user_data_ to be a str, received: {type(user_data_)}"
            )

        self.auth_tag = auth_tag_
        self.bakery_version = bakery_version_
        self.cli_args = cli_args_
        self.client_version = client_version_
        self.credentials = credentials_
        self.macaroons = macaroons_
        self.nonce = nonce_
        self.token = token_
        self.user_data = user_data_
        self.unknown_fields = unknown_fields


class LoginResult(Type):
    _toSchema = {
        "bakery_discharge_required": "bakery-discharge-required",
        "controller_tag": "controller-tag",
        "discharge_required": "discharge-required",
        "discharge_required_error": "discharge-required-error",
        "facades": "facades",
        "model_tag": "model-tag",
        "public_dns_name": "public-dns-name",
        "server_version": "server-version",
        "servers": "servers",
        "user_info": "user-info",
    }
    _toPy = {
        "bakery-discharge-required": "bakery_discharge_required",
        "controller-tag": "controller_tag",
        "discharge-required": "discharge_required",
        "discharge-required-error": "discharge_required_error",
        "facades": "facades",
        "model-tag": "model_tag",
        "public-dns-name": "public_dns_name",
        "server-version": "server_version",
        "servers": "servers",
        "user-info": "user_info",
    }

    def __init__(
        self,
        bakery_discharge_required=None,
        controller_tag=None,
        discharge_required=None,
        discharge_required_error=None,
        facades=None,
        model_tag=None,
        public_dns_name=None,
        server_version=None,
        servers=None,
        user_info=None,
        **unknown_fields,
    ):
        """bakery_discharge_required : Macaroon
        controller_tag : str
        discharge_required : Macaroon
        discharge_required_error : str
        facades : typing.Sequence[~FacadeVersions]
        model_tag : str
        public_dns_name : str
        server_version : str
        servers : typing.Sequence[~HostPort]
        user_info : AuthUserInfo
        """
        bakery_discharge_required_ = (
            Macaroon.from_json(bakery_discharge_required)
            if bakery_discharge_required
            else None
        )
        controller_tag_ = controller_tag
        discharge_required_ = (
            Macaroon.from_json(discharge_required) if discharge_required else None
        )
        discharge_required_error_ = discharge_required_error
        facades_ = [FacadeVersions.from_json(o) for o in facades or []]
        model_tag_ = model_tag
        public_dns_name_ = public_dns_name
        server_version_ = server_version
        servers_ = [HostPort.from_json(o) for o in servers or []]
        user_info_ = AuthUserInfo.from_json(user_info) if user_info else None

        # Validate arguments against known Juju API types.
        if bakery_discharge_required_ is not None and not isinstance(
            bakery_discharge_required_, (dict, Macaroon)
        ):
            raise Exception(
                f"Expected bakery_discharge_required_ to be a Macaroon, received: {type(bakery_discharge_required_)}"
            )

        if controller_tag_ is not None and not isinstance(
            controller_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected controller_tag_ to be a str, received: {type(controller_tag_)}"
            )

        if discharge_required_ is not None and not isinstance(
            discharge_required_, (dict, Macaroon)
        ):
            raise Exception(
                f"Expected discharge_required_ to be a Macaroon, received: {type(discharge_required_)}"
            )

        if discharge_required_error_ is not None and not isinstance(
            discharge_required_error_, (bytes, str)
        ):
            raise Exception(
                f"Expected discharge_required_error_ to be a str, received: {type(discharge_required_error_)}"
            )

        if facades_ is not None and not isinstance(facades_, (bytes, str, list)):
            raise Exception(
                f"Expected facades_ to be a Sequence, received: {type(facades_)}"
            )

        if model_tag_ is not None and not isinstance(model_tag_, (bytes, str)):
            raise Exception(
                f"Expected model_tag_ to be a str, received: {type(model_tag_)}"
            )

        if public_dns_name_ is not None and not isinstance(
            public_dns_name_, (bytes, str)
        ):
            raise Exception(
                f"Expected public_dns_name_ to be a str, received: {type(public_dns_name_)}"
            )

        if server_version_ is not None and not isinstance(
            server_version_, (bytes, str)
        ):
            raise Exception(
                f"Expected server_version_ to be a str, received: {type(server_version_)}"
            )

        if servers_ is not None and not isinstance(servers_, (bytes, str, list)):
            raise Exception(
                f"Expected servers_ to be a Sequence, received: {type(servers_)}"
            )

        if user_info_ is not None and not isinstance(user_info_, (dict, AuthUserInfo)):
            raise Exception(
                f"Expected user_info_ to be a AuthUserInfo, received: {type(user_info_)}"
            )

        self.bakery_discharge_required = bakery_discharge_required_
        self.controller_tag = controller_tag_
        self.discharge_required = discharge_required_
        self.discharge_required_error = discharge_required_error_
        self.facades = facades_
        self.model_tag = model_tag_
        self.public_dns_name = public_dns_name_
        self.server_version = server_version_
        self.servers = servers_
        self.user_info = user_info_
        self.unknown_fields = unknown_fields


class Macaroon(Type):
    _toSchema = {}
    _toPy = {}

    def __init__(self, **unknown_fields):
        """ """
        self.unknown_fields = unknown_fields


class MachineHardware(Type):
    _toSchema = {
        "arch": "arch",
        "availability_zone": "availability-zone",
        "cores": "cores",
        "cpu_power": "cpu-power",
        "mem": "mem",
        "root_disk": "root-disk",
        "tags": "tags",
        "virt_type": "virt-type",
    }
    _toPy = {
        "arch": "arch",
        "availability-zone": "availability_zone",
        "cores": "cores",
        "cpu-power": "cpu_power",
        "mem": "mem",
        "root-disk": "root_disk",
        "tags": "tags",
        "virt-type": "virt_type",
    }

    def __init__(
        self,
        arch=None,
        availability_zone=None,
        cores=None,
        cpu_power=None,
        mem=None,
        root_disk=None,
        tags=None,
        virt_type=None,
        **unknown_fields,
    ):
        """Arch : str
        availability_zone : str
        cores : int
        cpu_power : int
        mem : int
        root_disk : int
        tags : typing.Sequence[str]
        virt_type : str
        """
        arch_ = arch
        availability_zone_ = availability_zone
        cores_ = cores
        cpu_power_ = cpu_power
        mem_ = mem
        root_disk_ = root_disk
        tags_ = tags
        virt_type_ = virt_type

        # Validate arguments against known Juju API types.
        if arch_ is not None and not isinstance(arch_, (bytes, str)):
            raise Exception(f"Expected arch_ to be a str, received: {type(arch_)}")

        if availability_zone_ is not None and not isinstance(
            availability_zone_, (bytes, str)
        ):
            raise Exception(
                f"Expected availability_zone_ to be a str, received: {type(availability_zone_)}"
            )

        if cores_ is not None and not isinstance(cores_, int):
            raise Exception(f"Expected cores_ to be a int, received: {type(cores_)}")

        if cpu_power_ is not None and not isinstance(cpu_power_, int):
            raise Exception(
                f"Expected cpu_power_ to be a int, received: {type(cpu_power_)}"
            )

        if mem_ is not None and not isinstance(mem_, int):
            raise Exception(f"Expected mem_ to be a int, received: {type(mem_)}")

        if root_disk_ is not None and not isinstance(root_disk_, int):
            raise Exception(
                f"Expected root_disk_ to be a int, received: {type(root_disk_)}"
            )

        if tags_ is not None and not isinstance(tags_, (bytes, str, list)):
            raise Exception(f"Expected tags_ to be a Sequence, received: {type(tags_)}")

        if virt_type_ is not None and not isinstance(virt_type_, (bytes, str)):
            raise Exception(
                f"Expected virt_type_ to be a str, received: {type(virt_type_)}"
            )

        self.arch = arch_
        self.availability_zone = availability_zone_
        self.cores = cores_
        self.cpu_power = cpu_power_
        self.mem = mem_
        self.root_disk = root_disk_
        self.tags = tags_
        self.virt_type = virt_type_
        self.unknown_fields = unknown_fields


class MachineStatus(Type):
    _toSchema = {
        "agent_status": "agent-status",
        "base": "base",
        "constraints": "constraints",
        "containers": "containers",
        "display_name": "display-name",
        "dns_name": "dns-name",
        "hardware": "hardware",
        "has_vote": "has-vote",
        "hostname": "hostname",
        "id_": "id",
        "instance_id": "instance-id",
        "instance_status": "instance-status",
        "ip_addresses": "ip-addresses",
        "jobs": "jobs",
        "lxd_profiles": "lxd-profiles",
        "modification_status": "modification-status",
        "network_interfaces": "network-interfaces",
        "primary_controller_machine": "primary-controller-machine",
        "wants_vote": "wants-vote",
    }
    _toPy = {
        "agent-status": "agent_status",
        "base": "base",
        "constraints": "constraints",
        "containers": "containers",
        "display-name": "display_name",
        "dns-name": "dns_name",
        "hardware": "hardware",
        "has-vote": "has_vote",
        "hostname": "hostname",
        "id": "id_",
        "instance-id": "instance_id",
        "instance-status": "instance_status",
        "ip-addresses": "ip_addresses",
        "jobs": "jobs",
        "lxd-profiles": "lxd_profiles",
        "modification-status": "modification_status",
        "network-interfaces": "network_interfaces",
        "primary-controller-machine": "primary_controller_machine",
        "wants-vote": "wants_vote",
    }

    def __init__(
        self,
        agent_status=None,
        base=None,
        constraints=None,
        containers=None,
        display_name=None,
        dns_name=None,
        hardware=None,
        has_vote=None,
        hostname=None,
        id_=None,
        instance_id=None,
        instance_status=None,
        ip_addresses=None,
        jobs=None,
        lxd_profiles=None,
        modification_status=None,
        network_interfaces=None,
        primary_controller_machine=None,
        wants_vote=None,
        **unknown_fields,
    ):
        """agent_status : DetailedStatus
        base : Base
        constraints : str
        containers : typing.Mapping[str, ~MachineStatus]
        display_name : str
        dns_name : str
        hardware : str
        has_vote : bool
        hostname : str
        id_ : str
        instance_id : str
        instance_status : DetailedStatus
        ip_addresses : typing.Sequence[str]
        jobs : typing.Sequence[str]
        lxd_profiles : typing.Mapping[str, ~LXDProfile]
        modification_status : DetailedStatus
        network_interfaces : typing.Mapping[str, ~NetworkInterface]
        primary_controller_machine : bool
        wants_vote : bool
        """
        agent_status_ = DetailedStatus.from_json(agent_status) if agent_status else None
        base_ = Base.from_json(base) if base else None
        constraints_ = constraints
        containers_ = {
            k: MachineStatus.from_json(v) for k, v in (containers or dict()).items()
        }
        display_name_ = display_name
        dns_name_ = dns_name
        hardware_ = hardware
        has_vote_ = has_vote
        hostname_ = hostname
        id__ = id_
        instance_id_ = instance_id
        instance_status_ = (
            DetailedStatus.from_json(instance_status) if instance_status else None
        )
        ip_addresses_ = ip_addresses
        jobs_ = jobs
        lxd_profiles_ = {
            k: LXDProfile.from_json(v) for k, v in (lxd_profiles or dict()).items()
        }
        modification_status_ = (
            DetailedStatus.from_json(modification_status)
            if modification_status
            else None
        )
        network_interfaces_ = {
            k: NetworkInterface.from_json(v)
            for k, v in (network_interfaces or dict()).items()
        }
        primary_controller_machine_ = primary_controller_machine
        wants_vote_ = wants_vote

        # Validate arguments against known Juju API types.
        if agent_status_ is not None and not isinstance(
            agent_status_, (dict, DetailedStatus)
        ):
            raise Exception(
                f"Expected agent_status_ to be a DetailedStatus, received: {type(agent_status_)}"
            )

        if base_ is not None and not isinstance(base_, (dict, Base)):
            raise Exception(f"Expected base_ to be a Base, received: {type(base_)}")

        if constraints_ is not None and not isinstance(constraints_, (bytes, str)):
            raise Exception(
                f"Expected constraints_ to be a str, received: {type(constraints_)}"
            )

        if containers_ is not None and not isinstance(containers_, dict):
            raise Exception(
                f"Expected containers_ to be a Mapping, received: {type(containers_)}"
            )

        if display_name_ is not None and not isinstance(display_name_, (bytes, str)):
            raise Exception(
                f"Expected display_name_ to be a str, received: {type(display_name_)}"
            )

        if dns_name_ is not None and not isinstance(dns_name_, (bytes, str)):
            raise Exception(
                f"Expected dns_name_ to be a str, received: {type(dns_name_)}"
            )

        if hardware_ is not None and not isinstance(hardware_, (bytes, str)):
            raise Exception(
                f"Expected hardware_ to be a str, received: {type(hardware_)}"
            )

        if has_vote_ is not None and not isinstance(has_vote_, bool):
            raise Exception(
                f"Expected has_vote_ to be a bool, received: {type(has_vote_)}"
            )

        if hostname_ is not None and not isinstance(hostname_, (bytes, str)):
            raise Exception(
                f"Expected hostname_ to be a str, received: {type(hostname_)}"
            )

        if id__ is not None and not isinstance(id__, (bytes, str)):
            raise Exception(f"Expected id__ to be a str, received: {type(id__)}")

        if instance_id_ is not None and not isinstance(instance_id_, (bytes, str)):
            raise Exception(
                f"Expected instance_id_ to be a str, received: {type(instance_id_)}"
            )

        if instance_status_ is not None and not isinstance(
            instance_status_, (dict, DetailedStatus)
        ):
            raise Exception(
                f"Expected instance_status_ to be a DetailedStatus, received: {type(instance_status_)}"
            )

        if ip_addresses_ is not None and not isinstance(
            ip_addresses_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected ip_addresses_ to be a Sequence, received: {type(ip_addresses_)}"
            )

        if jobs_ is not None and not isinstance(jobs_, (bytes, str, list)):
            raise Exception(f"Expected jobs_ to be a Sequence, received: {type(jobs_)}")

        if lxd_profiles_ is not None and not isinstance(lxd_profiles_, dict):
            raise Exception(
                f"Expected lxd_profiles_ to be a Mapping, received: {type(lxd_profiles_)}"
            )

        if modification_status_ is not None and not isinstance(
            modification_status_, (dict, DetailedStatus)
        ):
            raise Exception(
                f"Expected modification_status_ to be a DetailedStatus, received: {type(modification_status_)}"
            )

        if network_interfaces_ is not None and not isinstance(
            network_interfaces_, dict
        ):
            raise Exception(
                f"Expected network_interfaces_ to be a Mapping, received: {type(network_interfaces_)}"
            )

        if primary_controller_machine_ is not None and not isinstance(
            primary_controller_machine_, bool
        ):
            raise Exception(
                f"Expected primary_controller_machine_ to be a bool, received: {type(primary_controller_machine_)}"
            )

        if wants_vote_ is not None and not isinstance(wants_vote_, bool):
            raise Exception(
                f"Expected wants_vote_ to be a bool, received: {type(wants_vote_)}"
            )

        self.agent_status = agent_status_
        self.base = base_
        self.constraints = constraints_
        self.containers = containers_
        self.display_name = display_name_
        self.dns_name = dns_name_
        self.hardware = hardware_
        self.has_vote = has_vote_
        self.hostname = hostname_
        self.id_ = id__
        self.instance_id = instance_id_
        self.instance_status = instance_status_
        self.ip_addresses = ip_addresses_
        self.jobs = jobs_
        self.lxd_profiles = lxd_profiles_
        self.modification_status = modification_status_
        self.network_interfaces = network_interfaces_
        self.primary_controller_machine = primary_controller_machine_
        self.wants_vote = wants_vote_
        self.unknown_fields = unknown_fields


class MapResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : typing.Mapping[str, typing.Any]
        """
        error_ = Error.from_json(error) if error else None
        result_ = result

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, dict):
            raise Exception(
                f"Expected result_ to be a Mapping, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class MapResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~MapResult]"""
        results_ = [MapResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class MetadataImageIds(Type):
    _toSchema = {"image_ids": "image-ids"}
    _toPy = {"image-ids": "image_ids"}

    def __init__(self, image_ids=None, **unknown_fields):
        """image_ids : typing.Sequence[str]"""
        image_ids_ = image_ids

        # Validate arguments against known Juju API types.
        if image_ids_ is not None and not isinstance(image_ids_, (bytes, str, list)):
            raise Exception(
                f"Expected image_ids_ to be a Sequence, received: {type(image_ids_)}"
            )

        self.image_ids = image_ids_
        self.unknown_fields = unknown_fields


class MetadataSaveParams(Type):
    _toSchema = {"metadata": "metadata"}
    _toPy = {"metadata": "metadata"}

    def __init__(self, metadata=None, **unknown_fields):
        """Metadata : typing.Sequence[~CloudImageMetadataList]"""
        metadata_ = [CloudImageMetadataList.from_json(o) for o in metadata or []]

        # Validate arguments against known Juju API types.
        if metadata_ is not None and not isinstance(metadata_, (bytes, str, list)):
            raise Exception(
                f"Expected metadata_ to be a Sequence, received: {type(metadata_)}"
            )

        self.metadata = metadata_
        self.unknown_fields = unknown_fields


class MeterStatus(Type):
    _toSchema = {"color": "color", "message": "message"}
    _toPy = {"color": "color", "message": "message"}

    def __init__(self, color=None, message=None, **unknown_fields):
        """Color : str
        message : str
        """
        color_ = color
        message_ = message

        # Validate arguments against known Juju API types.
        if color_ is not None and not isinstance(color_, (bytes, str)):
            raise Exception(f"Expected color_ to be a str, received: {type(color_)}")

        if message_ is not None and not isinstance(message_, (bytes, str)):
            raise Exception(
                f"Expected message_ to be a str, received: {type(message_)}"
            )

        self.color = color_
        self.message = message_
        self.unknown_fields = unknown_fields


class MeterStatusParam(Type):
    _toSchema = {"code": "code", "info": "info", "tag": "tag"}
    _toPy = {"code": "code", "info": "info", "tag": "tag"}

    def __init__(self, code=None, info=None, tag=None, **unknown_fields):
        """Code : str
        info : str
        tag : str
        """
        code_ = code
        info_ = info
        tag_ = tag

        # Validate arguments against known Juju API types.
        if code_ is not None and not isinstance(code_, (bytes, str)):
            raise Exception(f"Expected code_ to be a str, received: {type(code_)}")

        if info_ is not None and not isinstance(info_, (bytes, str)):
            raise Exception(f"Expected info_ to be a str, received: {type(info_)}")

        if tag_ is not None and not isinstance(tag_, (bytes, str)):
            raise Exception(f"Expected tag_ to be a str, received: {type(tag_)}")

        self.code = code_
        self.info = info_
        self.tag = tag_
        self.unknown_fields = unknown_fields


class MeterStatusParams(Type):
    _toSchema = {"statues": "statues"}
    _toPy = {"statues": "statues"}

    def __init__(self, statues=None, **unknown_fields):
        """Statues : typing.Sequence[~MeterStatusParam]"""
        statues_ = [MeterStatusParam.from_json(o) for o in statues or []]

        # Validate arguments against known Juju API types.
        if statues_ is not None and not isinstance(statues_, (bytes, str, list)):
            raise Exception(
                f"Expected statues_ to be a Sequence, received: {type(statues_)}"
            )

        self.statues = statues_
        self.unknown_fields = unknown_fields


class MetricResult(Type):
    _toSchema = {
        "key": "key",
        "labels": "labels",
        "time": "time",
        "unit": "unit",
        "value": "value",
    }
    _toPy = {
        "key": "key",
        "labels": "labels",
        "time": "time",
        "unit": "unit",
        "value": "value",
    }

    def __init__(
        self, key=None, labels=None, time=None, unit=None, value=None, **unknown_fields
    ):
        """Key : str
        labels : typing.Mapping[str, str]
        time : str
        unit : str
        value : str
        """
        key_ = key
        labels_ = labels
        time_ = time
        unit_ = unit
        value_ = value

        # Validate arguments against known Juju API types.
        if key_ is not None and not isinstance(key_, (bytes, str)):
            raise Exception(f"Expected key_ to be a str, received: {type(key_)}")

        if labels_ is not None and not isinstance(labels_, dict):
            raise Exception(
                f"Expected labels_ to be a Mapping, received: {type(labels_)}"
            )

        if time_ is not None and not isinstance(time_, (bytes, str)):
            raise Exception(f"Expected time_ to be a str, received: {type(time_)}")

        if unit_ is not None and not isinstance(unit_, (bytes, str)):
            raise Exception(f"Expected unit_ to be a str, received: {type(unit_)}")

        if value_ is not None and not isinstance(value_, (bytes, str)):
            raise Exception(f"Expected value_ to be a str, received: {type(value_)}")

        self.key = key_
        self.labels = labels_
        self.time = time_
        self.unit = unit_
        self.value = value_
        self.unknown_fields = unknown_fields


class MetricResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~EntityMetrics]"""
        results_ = [EntityMetrics.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class MigrationSpec(Type):
    _toSchema = {"model_tag": "model-tag", "target_info": "target-info"}
    _toPy = {"model-tag": "model_tag", "target-info": "target_info"}

    def __init__(self, model_tag=None, target_info=None, **unknown_fields):
        """model_tag : str
        target_info : MigrationTargetInfo
        """
        model_tag_ = model_tag
        target_info_ = (
            MigrationTargetInfo.from_json(target_info) if target_info else None
        )

        # Validate arguments against known Juju API types.
        if model_tag_ is not None and not isinstance(model_tag_, (bytes, str)):
            raise Exception(
                f"Expected model_tag_ to be a str, received: {type(model_tag_)}"
            )

        if target_info_ is not None and not isinstance(
            target_info_, (dict, MigrationTargetInfo)
        ):
            raise Exception(
                f"Expected target_info_ to be a MigrationTargetInfo, received: {type(target_info_)}"
            )

        self.model_tag = model_tag_
        self.target_info = target_info_
        self.unknown_fields = unknown_fields


class MigrationTargetInfo(Type):
    _toSchema = {
        "addrs": "addrs",
        "auth_tag": "auth-tag",
        "ca_cert": "ca-cert",
        "controller_alias": "controller-alias",
        "controller_tag": "controller-tag",
        "macaroons": "macaroons",
        "password": "password",
    }
    _toPy = {
        "addrs": "addrs",
        "auth-tag": "auth_tag",
        "ca-cert": "ca_cert",
        "controller-alias": "controller_alias",
        "controller-tag": "controller_tag",
        "macaroons": "macaroons",
        "password": "password",
    }

    def __init__(
        self,
        addrs=None,
        auth_tag=None,
        ca_cert=None,
        controller_alias=None,
        controller_tag=None,
        macaroons=None,
        password=None,
        **unknown_fields,
    ):
        """Addrs : typing.Sequence[str]
        auth_tag : str
        ca_cert : str
        controller_alias : str
        controller_tag : str
        macaroons : str
        password : str
        """
        addrs_ = addrs
        auth_tag_ = auth_tag
        ca_cert_ = ca_cert
        controller_alias_ = controller_alias
        controller_tag_ = controller_tag
        macaroons_ = macaroons
        password_ = password

        # Validate arguments against known Juju API types.
        if addrs_ is not None and not isinstance(addrs_, (bytes, str, list)):
            raise Exception(
                f"Expected addrs_ to be a Sequence, received: {type(addrs_)}"
            )

        if auth_tag_ is not None and not isinstance(auth_tag_, (bytes, str)):
            raise Exception(
                f"Expected auth_tag_ to be a str, received: {type(auth_tag_)}"
            )

        if ca_cert_ is not None and not isinstance(ca_cert_, (bytes, str)):
            raise Exception(
                f"Expected ca_cert_ to be a str, received: {type(ca_cert_)}"
            )

        if controller_alias_ is not None and not isinstance(
            controller_alias_, (bytes, str)
        ):
            raise Exception(
                f"Expected controller_alias_ to be a str, received: {type(controller_alias_)}"
            )

        if controller_tag_ is not None and not isinstance(
            controller_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected controller_tag_ to be a str, received: {type(controller_tag_)}"
            )

        if macaroons_ is not None and not isinstance(macaroons_, (bytes, str)):
            raise Exception(
                f"Expected macaroons_ to be a str, received: {type(macaroons_)}"
            )

        if password_ is not None and not isinstance(password_, (bytes, str)):
            raise Exception(
                f"Expected password_ to be a str, received: {type(password_)}"
            )

        self.addrs = addrs_
        self.auth_tag = auth_tag_
        self.ca_cert = ca_cert_
        self.controller_alias = controller_alias_
        self.controller_tag = controller_tag_
        self.macaroons = macaroons_
        self.password = password_
        self.unknown_fields = unknown_fields


class Model(Type):
    _toSchema = {
        "name": "name",
        "owner_tag": "owner-tag",
        "type_": "type",
        "uuid": "uuid",
    }
    _toPy = {"name": "name", "owner-tag": "owner_tag", "type": "type_", "uuid": "uuid"}

    def __init__(
        self, name=None, owner_tag=None, type_=None, uuid=None, **unknown_fields
    ):
        """Name : str
        owner_tag : str
        type_ : str
        uuid : str
        """
        name_ = name
        owner_tag_ = owner_tag
        type__ = type_
        uuid_ = uuid

        # Validate arguments against known Juju API types.
        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if owner_tag_ is not None and not isinstance(owner_tag_, (bytes, str)):
            raise Exception(
                f"Expected owner_tag_ to be a str, received: {type(owner_tag_)}"
            )

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        if uuid_ is not None and not isinstance(uuid_, (bytes, str)):
            raise Exception(f"Expected uuid_ to be a str, received: {type(uuid_)}")

        self.name = name_
        self.owner_tag = owner_tag_
        self.type_ = type__
        self.uuid = uuid_
        self.unknown_fields = unknown_fields


class ModelAccess(Type):
    _toSchema = {"access": "access", "model": "model"}
    _toPy = {"access": "access", "model": "model"}

    def __init__(self, access=None, model=None, **unknown_fields):
        """Access : str
        model : str
        """
        access_ = access
        model_ = model

        # Validate arguments against known Juju API types.
        if access_ is not None and not isinstance(access_, (bytes, str)):
            raise Exception(f"Expected access_ to be a str, received: {type(access_)}")

        if model_ is not None and not isinstance(model_, (bytes, str)):
            raise Exception(f"Expected model_ to be a str, received: {type(model_)}")

        self.access = access_
        self.model = model_
        self.unknown_fields = unknown_fields


class ModelApplicationInfo(Type):
    _toSchema = {"name": "name"}
    _toPy = {"name": "name"}

    def __init__(self, name=None, **unknown_fields):
        """Name : str"""
        name_ = name

        # Validate arguments against known Juju API types.
        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        self.name = name_
        self.unknown_fields = unknown_fields


class ModelBlockInfo(Type):
    _toSchema = {
        "blocks": "blocks",
        "model_uuid": "model-uuid",
        "name": "name",
        "owner_tag": "owner-tag",
    }
    _toPy = {
        "blocks": "blocks",
        "model-uuid": "model_uuid",
        "name": "name",
        "owner-tag": "owner_tag",
    }

    def __init__(
        self, blocks=None, model_uuid=None, name=None, owner_tag=None, **unknown_fields
    ):
        """Blocks : typing.Sequence[str]
        model_uuid : str
        name : str
        owner_tag : str
        """
        blocks_ = blocks
        model_uuid_ = model_uuid
        name_ = name
        owner_tag_ = owner_tag

        # Validate arguments against known Juju API types.
        if blocks_ is not None and not isinstance(blocks_, (bytes, str, list)):
            raise Exception(
                f"Expected blocks_ to be a Sequence, received: {type(blocks_)}"
            )

        if model_uuid_ is not None and not isinstance(model_uuid_, (bytes, str)):
            raise Exception(
                f"Expected model_uuid_ to be a str, received: {type(model_uuid_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if owner_tag_ is not None and not isinstance(owner_tag_, (bytes, str)):
            raise Exception(
                f"Expected owner_tag_ to be a str, received: {type(owner_tag_)}"
            )

        self.blocks = blocks_
        self.model_uuid = model_uuid_
        self.name = name_
        self.owner_tag = owner_tag_
        self.unknown_fields = unknown_fields


class ModelBlockInfoList(Type):
    _toSchema = {"models": "models"}
    _toPy = {"models": "models"}

    def __init__(self, models=None, **unknown_fields):
        """Models : typing.Sequence[~ModelBlockInfo]"""
        models_ = [ModelBlockInfo.from_json(o) for o in models or []]

        # Validate arguments against known Juju API types.
        if models_ is not None and not isinstance(models_, (bytes, str, list)):
            raise Exception(
                f"Expected models_ to be a Sequence, received: {type(models_)}"
            )

        self.models = models_
        self.unknown_fields = unknown_fields


class ModelConfigResults(Type):
    _toSchema = {"config": "config"}
    _toPy = {"config": "config"}

    def __init__(self, config=None, **unknown_fields):
        """Config : typing.Mapping[str, ~ConfigValue]"""
        config_ = {k: ConfigValue.from_json(v) for k, v in (config or dict()).items()}

        # Validate arguments against known Juju API types.
        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        self.config = config_
        self.unknown_fields = unknown_fields


class ModelCreateArgs(Type):
    _toSchema = {
        "cloud_tag": "cloud-tag",
        "config": "config",
        "credential": "credential",
        "name": "name",
        "owner_tag": "owner-tag",
        "region": "region",
    }
    _toPy = {
        "cloud-tag": "cloud_tag",
        "config": "config",
        "credential": "credential",
        "name": "name",
        "owner-tag": "owner_tag",
        "region": "region",
    }

    def __init__(
        self,
        cloud_tag=None,
        config=None,
        credential=None,
        name=None,
        owner_tag=None,
        region=None,
        **unknown_fields,
    ):
        """cloud_tag : str
        config : typing.Mapping[str, typing.Any]
        credential : str
        name : str
        owner_tag : str
        region : str
        """
        cloud_tag_ = cloud_tag
        config_ = config
        credential_ = credential
        name_ = name
        owner_tag_ = owner_tag
        region_ = region

        # Validate arguments against known Juju API types.
        if cloud_tag_ is not None and not isinstance(cloud_tag_, (bytes, str)):
            raise Exception(
                f"Expected cloud_tag_ to be a str, received: {type(cloud_tag_)}"
            )

        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        if credential_ is not None and not isinstance(credential_, (bytes, str)):
            raise Exception(
                f"Expected credential_ to be a str, received: {type(credential_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if owner_tag_ is not None and not isinstance(owner_tag_, (bytes, str)):
            raise Exception(
                f"Expected owner_tag_ to be a str, received: {type(owner_tag_)}"
            )

        if region_ is not None and not isinstance(region_, (bytes, str)):
            raise Exception(f"Expected region_ to be a str, received: {type(region_)}")

        self.cloud_tag = cloud_tag_
        self.config = config_
        self.credential = credential_
        self.name = name_
        self.owner_tag = owner_tag_
        self.region = region_
        self.unknown_fields = unknown_fields


class ModelDefaultValues(Type):
    _toSchema = {
        "cloud_region": "cloud-region",
        "cloud_tag": "cloud-tag",
        "config": "config",
    }
    _toPy = {
        "cloud-region": "cloud_region",
        "cloud-tag": "cloud_tag",
        "config": "config",
    }

    def __init__(
        self, cloud_region=None, cloud_tag=None, config=None, **unknown_fields
    ):
        """cloud_region : str
        cloud_tag : str
        config : typing.Mapping[str, typing.Any]
        """
        cloud_region_ = cloud_region
        cloud_tag_ = cloud_tag
        config_ = config

        # Validate arguments against known Juju API types.
        if cloud_region_ is not None and not isinstance(cloud_region_, (bytes, str)):
            raise Exception(
                f"Expected cloud_region_ to be a str, received: {type(cloud_region_)}"
            )

        if cloud_tag_ is not None and not isinstance(cloud_tag_, (bytes, str)):
            raise Exception(
                f"Expected cloud_tag_ to be a str, received: {type(cloud_tag_)}"
            )

        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        self.cloud_region = cloud_region_
        self.cloud_tag = cloud_tag_
        self.config = config_
        self.unknown_fields = unknown_fields


class ModelDefaults(Type):
    _toSchema = {"controller": "controller", "default": "default", "regions": "regions"}
    _toPy = {"controller": "controller", "default": "default", "regions": "regions"}

    def __init__(self, controller=None, default=None, regions=None, **unknown_fields):
        """Controller : Any
        default : Any
        regions : typing.Sequence[~RegionDefaults]
        """
        controller_ = controller
        default_ = default
        regions_ = [RegionDefaults.from_json(o) for o in regions or []]

        # Validate arguments against known Juju API types.
        if regions_ is not None and not isinstance(regions_, (bytes, str, list)):
            raise Exception(
                f"Expected regions_ to be a Sequence, received: {type(regions_)}"
            )

        self.controller = controller_
        self.default = default_
        self.regions = regions_
        self.unknown_fields = unknown_fields


class ModelDefaultsResult(Type):
    _toSchema = {"config": "config", "error": "error"}
    _toPy = {"config": "config", "error": "error"}

    def __init__(self, config=None, error=None, **unknown_fields):
        """Config : typing.Mapping[str, ~ModelDefaults]
        error : Error
        """
        config_ = {k: ModelDefaults.from_json(v) for k, v in (config or dict()).items()}
        error_ = Error.from_json(error) if error else None

        # Validate arguments against known Juju API types.
        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        self.config = config_
        self.error = error_
        self.unknown_fields = unknown_fields


class ModelDefaultsResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ModelDefaultsResult]"""
        results_ = [ModelDefaultsResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ModelEntityCount(Type):
    _toSchema = {"count": "count", "entity": "entity"}
    _toPy = {"count": "count", "entity": "entity"}

    def __init__(self, count=None, entity=None, **unknown_fields):
        """Count : int
        entity : str
        """
        count_ = count
        entity_ = entity

        # Validate arguments against known Juju API types.
        if count_ is not None and not isinstance(count_, int):
            raise Exception(f"Expected count_ to be a int, received: {type(count_)}")

        if entity_ is not None and not isinstance(entity_, (bytes, str)):
            raise Exception(f"Expected entity_ to be a str, received: {type(entity_)}")

        self.count = count_
        self.entity = entity_
        self.unknown_fields = unknown_fields


class ModelFilesystemInfo(Type):
    _toSchema = {
        "detachable": "detachable",
        "id_": "id",
        "message": "message",
        "provider_id": "provider-id",
        "status": "status",
    }
    _toPy = {
        "detachable": "detachable",
        "id": "id_",
        "message": "message",
        "provider-id": "provider_id",
        "status": "status",
    }

    def __init__(
        self,
        detachable=None,
        id_=None,
        message=None,
        provider_id=None,
        status=None,
        **unknown_fields,
    ):
        """Detachable : bool
        id_ : str
        message : str
        provider_id : str
        status : str
        """
        detachable_ = detachable
        id__ = id_
        message_ = message
        provider_id_ = provider_id
        status_ = status

        # Validate arguments against known Juju API types.
        if detachable_ is not None and not isinstance(detachable_, bool):
            raise Exception(
                f"Expected detachable_ to be a bool, received: {type(detachable_)}"
            )

        if id__ is not None and not isinstance(id__, (bytes, str)):
            raise Exception(f"Expected id__ to be a str, received: {type(id__)}")

        if message_ is not None and not isinstance(message_, (bytes, str)):
            raise Exception(
                f"Expected message_ to be a str, received: {type(message_)}"
            )

        if provider_id_ is not None and not isinstance(provider_id_, (bytes, str)):
            raise Exception(
                f"Expected provider_id_ to be a str, received: {type(provider_id_)}"
            )

        if status_ is not None and not isinstance(status_, (bytes, str)):
            raise Exception(f"Expected status_ to be a str, received: {type(status_)}")

        self.detachable = detachable_
        self.id_ = id__
        self.message = message_
        self.provider_id = provider_id_
        self.status = status_
        self.unknown_fields = unknown_fields


class ModelInfo(Type):
    _toSchema = {
        "agent_version": "agent-version",
        "cloud_credential_tag": "cloud-credential-tag",
        "cloud_credential_validity": "cloud-credential-validity",
        "cloud_region": "cloud-region",
        "cloud_tag": "cloud-tag",
        "controller_uuid": "controller-uuid",
        "default_base": "default-base",
        "default_series": "default-series",
        "is_controller": "is-controller",
        "life": "life",
        "machines": "machines",
        "migration": "migration",
        "name": "name",
        "owner_tag": "owner-tag",
        "provider_type": "provider-type",
        "secret_backends": "secret-backends",
        "sla": "sla",
        "status": "status",
        "supported_features": "supported-features",
        "type_": "type",
        "users": "users",
        "uuid": "uuid",
    }
    _toPy = {
        "agent-version": "agent_version",
        "cloud-credential-tag": "cloud_credential_tag",
        "cloud-credential-validity": "cloud_credential_validity",
        "cloud-region": "cloud_region",
        "cloud-tag": "cloud_tag",
        "controller-uuid": "controller_uuid",
        "default-base": "default_base",
        "default-series": "default_series",
        "is-controller": "is_controller",
        "life": "life",
        "machines": "machines",
        "migration": "migration",
        "name": "name",
        "owner-tag": "owner_tag",
        "provider-type": "provider_type",
        "secret-backends": "secret_backends",
        "sla": "sla",
        "status": "status",
        "supported-features": "supported_features",
        "type": "type_",
        "users": "users",
        "uuid": "uuid",
    }

    def __init__(
        self,
        agent_version=None,
        cloud_credential_tag=None,
        cloud_credential_validity=None,
        cloud_region=None,
        cloud_tag=None,
        controller_uuid=None,
        default_base=None,
        default_series=None,
        is_controller=None,
        life=None,
        machines=None,
        migration=None,
        name=None,
        owner_tag=None,
        provider_type=None,
        secret_backends=None,
        sla=None,
        status=None,
        supported_features=None,
        type_=None,
        users=None,
        uuid=None,
        **unknown_fields,
    ):
        """agent_version : Number
        cloud_credential_tag : str
        cloud_credential_validity : bool
        cloud_region : str
        cloud_tag : str
        controller_uuid : str
        default_base : str
        default_series : str
        is_controller : bool
        life : str
        machines : typing.Sequence[~ModelMachineInfo]
        migration : ModelMigrationStatus
        name : str
        owner_tag : str
        provider_type : str
        secret_backends : typing.Sequence[~SecretBackendResult]
        sla : ModelSLAInfo
        status : EntityStatus
        supported_features : typing.Sequence[~SupportedFeature]
        type_ : str
        users : typing.Sequence[~ModelUserInfo]
        uuid : str
        """
        agent_version_ = Number.from_json(agent_version) if agent_version else None
        cloud_credential_tag_ = cloud_credential_tag
        cloud_credential_validity_ = cloud_credential_validity
        cloud_region_ = cloud_region
        cloud_tag_ = cloud_tag
        controller_uuid_ = controller_uuid
        default_base_ = default_base
        default_series_ = default_series
        is_controller_ = is_controller
        life_ = life
        machines_ = [ModelMachineInfo.from_json(o) for o in machines or []]
        migration_ = ModelMigrationStatus.from_json(migration) if migration else None
        name_ = name
        owner_tag_ = owner_tag
        provider_type_ = provider_type
        secret_backends_ = [
            SecretBackendResult.from_json(o) for o in secret_backends or []
        ]
        sla_ = ModelSLAInfo.from_json(sla) if sla else None
        status_ = EntityStatus.from_json(status) if status else None
        supported_features_ = [
            SupportedFeature.from_json(o) for o in supported_features or []
        ]
        type__ = type_
        users_ = [ModelUserInfo.from_json(o) for o in users or []]
        uuid_ = uuid

        # Validate arguments against known Juju API types.
        if agent_version_ is not None and not isinstance(
            agent_version_, (dict, Number)
        ):
            raise Exception(
                f"Expected agent_version_ to be a Number, received: {type(agent_version_)}"
            )

        if cloud_credential_tag_ is not None and not isinstance(
            cloud_credential_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected cloud_credential_tag_ to be a str, received: {type(cloud_credential_tag_)}"
            )

        if cloud_credential_validity_ is not None and not isinstance(
            cloud_credential_validity_, bool
        ):
            raise Exception(
                f"Expected cloud_credential_validity_ to be a bool, received: {type(cloud_credential_validity_)}"
            )

        if cloud_region_ is not None and not isinstance(cloud_region_, (bytes, str)):
            raise Exception(
                f"Expected cloud_region_ to be a str, received: {type(cloud_region_)}"
            )

        if cloud_tag_ is not None and not isinstance(cloud_tag_, (bytes, str)):
            raise Exception(
                f"Expected cloud_tag_ to be a str, received: {type(cloud_tag_)}"
            )

        if controller_uuid_ is not None and not isinstance(
            controller_uuid_, (bytes, str)
        ):
            raise Exception(
                f"Expected controller_uuid_ to be a str, received: {type(controller_uuid_)}"
            )

        if default_base_ is not None and not isinstance(default_base_, (bytes, str)):
            raise Exception(
                f"Expected default_base_ to be a str, received: {type(default_base_)}"
            )

        if default_series_ is not None and not isinstance(
            default_series_, (bytes, str)
        ):
            raise Exception(
                f"Expected default_series_ to be a str, received: {type(default_series_)}"
            )

        if is_controller_ is not None and not isinstance(is_controller_, bool):
            raise Exception(
                f"Expected is_controller_ to be a bool, received: {type(is_controller_)}"
            )

        if life_ is not None and not isinstance(life_, (bytes, str)):
            raise Exception(f"Expected life_ to be a str, received: {type(life_)}")

        if machines_ is not None and not isinstance(machines_, (bytes, str, list)):
            raise Exception(
                f"Expected machines_ to be a Sequence, received: {type(machines_)}"
            )

        if migration_ is not None and not isinstance(
            migration_, (dict, ModelMigrationStatus)
        ):
            raise Exception(
                f"Expected migration_ to be a ModelMigrationStatus, received: {type(migration_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if owner_tag_ is not None and not isinstance(owner_tag_, (bytes, str)):
            raise Exception(
                f"Expected owner_tag_ to be a str, received: {type(owner_tag_)}"
            )

        if provider_type_ is not None and not isinstance(provider_type_, (bytes, str)):
            raise Exception(
                f"Expected provider_type_ to be a str, received: {type(provider_type_)}"
            )

        if secret_backends_ is not None and not isinstance(
            secret_backends_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected secret_backends_ to be a Sequence, received: {type(secret_backends_)}"
            )

        if sla_ is not None and not isinstance(sla_, (dict, ModelSLAInfo)):
            raise Exception(
                f"Expected sla_ to be a ModelSLAInfo, received: {type(sla_)}"
            )

        if status_ is not None and not isinstance(status_, (dict, EntityStatus)):
            raise Exception(
                f"Expected status_ to be a EntityStatus, received: {type(status_)}"
            )

        if supported_features_ is not None and not isinstance(
            supported_features_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected supported_features_ to be a Sequence, received: {type(supported_features_)}"
            )

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        if users_ is not None and not isinstance(users_, (bytes, str, list)):
            raise Exception(
                f"Expected users_ to be a Sequence, received: {type(users_)}"
            )

        if uuid_ is not None and not isinstance(uuid_, (bytes, str)):
            raise Exception(f"Expected uuid_ to be a str, received: {type(uuid_)}")

        self.agent_version = agent_version_
        self.cloud_credential_tag = cloud_credential_tag_
        self.cloud_credential_validity = cloud_credential_validity_
        self.cloud_region = cloud_region_
        self.cloud_tag = cloud_tag_
        self.controller_uuid = controller_uuid_
        self.default_base = default_base_
        self.default_series = default_series_
        self.is_controller = is_controller_
        self.life = life_
        self.machines = machines_
        self.migration = migration_
        self.name = name_
        self.owner_tag = owner_tag_
        self.provider_type = provider_type_
        self.secret_backends = secret_backends_
        self.sla = sla_
        self.status = status_
        self.supported_features = supported_features_
        self.type_ = type__
        self.users = users_
        self.uuid = uuid_
        self.unknown_fields = unknown_fields


class ModelInfoResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : ModelInfo
        """
        error_ = Error.from_json(error) if error else None
        result_ = ModelInfo.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (dict, ModelInfo)):
            raise Exception(
                f"Expected result_ to be a ModelInfo, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class ModelInfoResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ModelInfoResult]"""
        results_ = [ModelInfoResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ModelInstanceTypesConstraint(Type):
    _toSchema = {"value": "value"}
    _toPy = {"value": "value"}

    def __init__(self, value=None, **unknown_fields):
        """Value : Value"""
        value_ = Value.from_json(value) if value else None

        # Validate arguments against known Juju API types.
        if value_ is not None and not isinstance(value_, (dict, Value)):
            raise Exception(f"Expected value_ to be a Value, received: {type(value_)}")

        self.value = value_
        self.unknown_fields = unknown_fields


class ModelInstanceTypesConstraints(Type):
    _toSchema = {"constraints": "constraints"}
    _toPy = {"constraints": "constraints"}

    def __init__(self, constraints=None, **unknown_fields):
        """Constraints : typing.Sequence[~ModelInstanceTypesConstraint]"""
        constraints_ = [
            ModelInstanceTypesConstraint.from_json(o) for o in constraints or []
        ]

        # Validate arguments against known Juju API types.
        if constraints_ is not None and not isinstance(
            constraints_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected constraints_ to be a Sequence, received: {type(constraints_)}"
            )

        self.constraints = constraints_
        self.unknown_fields = unknown_fields


class ModelMachineInfo(Type):
    _toSchema = {
        "display_name": "display-name",
        "ha_primary": "ha-primary",
        "hardware": "hardware",
        "has_vote": "has-vote",
        "id_": "id",
        "instance_id": "instance-id",
        "message": "message",
        "status": "status",
        "wants_vote": "wants-vote",
    }
    _toPy = {
        "display-name": "display_name",
        "ha-primary": "ha_primary",
        "hardware": "hardware",
        "has-vote": "has_vote",
        "id": "id_",
        "instance-id": "instance_id",
        "message": "message",
        "status": "status",
        "wants-vote": "wants_vote",
    }

    def __init__(
        self,
        display_name=None,
        ha_primary=None,
        hardware=None,
        has_vote=None,
        id_=None,
        instance_id=None,
        message=None,
        status=None,
        wants_vote=None,
        **unknown_fields,
    ):
        """display_name : str
        ha_primary : bool
        hardware : MachineHardware
        has_vote : bool
        id_ : str
        instance_id : str
        message : str
        status : str
        wants_vote : bool
        """
        display_name_ = display_name
        ha_primary_ = ha_primary
        hardware_ = MachineHardware.from_json(hardware) if hardware else None
        has_vote_ = has_vote
        id__ = id_
        instance_id_ = instance_id
        message_ = message
        status_ = status
        wants_vote_ = wants_vote

        # Validate arguments against known Juju API types.
        if display_name_ is not None and not isinstance(display_name_, (bytes, str)):
            raise Exception(
                f"Expected display_name_ to be a str, received: {type(display_name_)}"
            )

        if ha_primary_ is not None and not isinstance(ha_primary_, bool):
            raise Exception(
                f"Expected ha_primary_ to be a bool, received: {type(ha_primary_)}"
            )

        if hardware_ is not None and not isinstance(hardware_, (dict, MachineHardware)):
            raise Exception(
                f"Expected hardware_ to be a MachineHardware, received: {type(hardware_)}"
            )

        if has_vote_ is not None and not isinstance(has_vote_, bool):
            raise Exception(
                f"Expected has_vote_ to be a bool, received: {type(has_vote_)}"
            )

        if id__ is not None and not isinstance(id__, (bytes, str)):
            raise Exception(f"Expected id__ to be a str, received: {type(id__)}")

        if instance_id_ is not None and not isinstance(instance_id_, (bytes, str)):
            raise Exception(
                f"Expected instance_id_ to be a str, received: {type(instance_id_)}"
            )

        if message_ is not None and not isinstance(message_, (bytes, str)):
            raise Exception(
                f"Expected message_ to be a str, received: {type(message_)}"
            )

        if status_ is not None and not isinstance(status_, (bytes, str)):
            raise Exception(f"Expected status_ to be a str, received: {type(status_)}")

        if wants_vote_ is not None and not isinstance(wants_vote_, bool):
            raise Exception(
                f"Expected wants_vote_ to be a bool, received: {type(wants_vote_)}"
            )

        self.display_name = display_name_
        self.ha_primary = ha_primary_
        self.hardware = hardware_
        self.has_vote = has_vote_
        self.id_ = id__
        self.instance_id = instance_id_
        self.message = message_
        self.status = status_
        self.wants_vote = wants_vote_
        self.unknown_fields = unknown_fields


class ModelMigrationStatus(Type):
    _toSchema = {"end": "end", "start": "start", "status": "status"}
    _toPy = {"end": "end", "start": "start", "status": "status"}

    def __init__(self, end=None, start=None, status=None, **unknown_fields):
        """End : str
        start : str
        status : str
        """
        end_ = end
        start_ = start
        status_ = status

        # Validate arguments against known Juju API types.
        if end_ is not None and not isinstance(end_, (bytes, str)):
            raise Exception(f"Expected end_ to be a str, received: {type(end_)}")

        if start_ is not None and not isinstance(start_, (bytes, str)):
            raise Exception(f"Expected start_ to be a str, received: {type(start_)}")

        if status_ is not None and not isinstance(status_, (bytes, str)):
            raise Exception(f"Expected status_ to be a str, received: {type(status_)}")

        self.end = end_
        self.start = start_
        self.status = status_
        self.unknown_fields = unknown_fields


class ModelParam(Type):
    _toSchema = {"model_tag": "model-tag"}
    _toPy = {"model-tag": "model_tag"}

    def __init__(self, model_tag=None, **unknown_fields):
        """model_tag : str"""
        model_tag_ = model_tag

        # Validate arguments against known Juju API types.
        if model_tag_ is not None and not isinstance(model_tag_, (bytes, str)):
            raise Exception(
                f"Expected model_tag_ to be a str, received: {type(model_tag_)}"
            )

        self.model_tag = model_tag_
        self.unknown_fields = unknown_fields


class ModelSLA(Type):
    _toSchema = {
        "creds": "creds",
        "level": "level",
        "modelslainfo": "ModelSLAInfo",
        "owner": "owner",
    }
    _toPy = {
        "ModelSLAInfo": "modelslainfo",
        "creds": "creds",
        "level": "level",
        "owner": "owner",
    }

    def __init__(
        self, modelslainfo=None, creds=None, level=None, owner=None, **unknown_fields
    ):
        """Modelslainfo : ModelSLAInfo
        creds : typing.Sequence[int]
        level : str
        owner : str
        """
        modelslainfo_ = ModelSLAInfo.from_json(modelslainfo) if modelslainfo else None
        creds_ = creds
        level_ = level
        owner_ = owner

        # Validate arguments against known Juju API types.
        if modelslainfo_ is not None and not isinstance(
            modelslainfo_, (dict, ModelSLAInfo)
        ):
            raise Exception(
                f"Expected modelslainfo_ to be a ModelSLAInfo, received: {type(modelslainfo_)}"
            )

        if creds_ is not None and not isinstance(creds_, (bytes, str, list)):
            raise Exception(
                f"Expected creds_ to be a Sequence, received: {type(creds_)}"
            )

        if level_ is not None and not isinstance(level_, (bytes, str)):
            raise Exception(f"Expected level_ to be a str, received: {type(level_)}")

        if owner_ is not None and not isinstance(owner_, (bytes, str)):
            raise Exception(f"Expected owner_ to be a str, received: {type(owner_)}")

        self.modelslainfo = modelslainfo_
        self.creds = creds_
        self.level = level_
        self.owner = owner_
        self.unknown_fields = unknown_fields


class ModelSLAInfo(Type):
    _toSchema = {"level": "level", "owner": "owner"}
    _toPy = {"level": "level", "owner": "owner"}

    def __init__(self, level=None, owner=None, **unknown_fields):
        """Level : str
        owner : str
        """
        level_ = level
        owner_ = owner

        # Validate arguments against known Juju API types.
        if level_ is not None and not isinstance(level_, (bytes, str)):
            raise Exception(f"Expected level_ to be a str, received: {type(level_)}")

        if owner_ is not None and not isinstance(owner_, (bytes, str)):
            raise Exception(f"Expected owner_ to be a str, received: {type(owner_)}")

        self.level = level_
        self.owner = owner_
        self.unknown_fields = unknown_fields


class ModelSequencesResult(Type):
    _toSchema = {"sequences": "sequences"}
    _toPy = {"sequences": "sequences"}

    def __init__(self, sequences=None, **unknown_fields):
        """Sequences : typing.Mapping[str, int]"""
        sequences_ = sequences

        # Validate arguments against known Juju API types.
        if sequences_ is not None and not isinstance(sequences_, dict):
            raise Exception(
                f"Expected sequences_ to be a Mapping, received: {type(sequences_)}"
            )

        self.sequences = sequences_
        self.unknown_fields = unknown_fields


class ModelSet(Type):
    _toSchema = {"config": "config"}
    _toPy = {"config": "config"}

    def __init__(self, config=None, **unknown_fields):
        """Config : typing.Mapping[str, typing.Any]"""
        config_ = config

        # Validate arguments against known Juju API types.
        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        self.config = config_
        self.unknown_fields = unknown_fields


class ModelStatus(Type):
    _toSchema = {
        "application_count": "application-count",
        "applications": "applications",
        "error": "error",
        "filesystems": "filesystems",
        "hosted_machine_count": "hosted-machine-count",
        "life": "life",
        "machines": "machines",
        "model_tag": "model-tag",
        "owner_tag": "owner-tag",
        "type_": "type",
        "unit_count": "unit-count",
        "volumes": "volumes",
    }
    _toPy = {
        "application-count": "application_count",
        "applications": "applications",
        "error": "error",
        "filesystems": "filesystems",
        "hosted-machine-count": "hosted_machine_count",
        "life": "life",
        "machines": "machines",
        "model-tag": "model_tag",
        "owner-tag": "owner_tag",
        "type": "type_",
        "unit-count": "unit_count",
        "volumes": "volumes",
    }

    def __init__(
        self,
        application_count=None,
        applications=None,
        error=None,
        filesystems=None,
        hosted_machine_count=None,
        life=None,
        machines=None,
        model_tag=None,
        owner_tag=None,
        type_=None,
        unit_count=None,
        volumes=None,
        **unknown_fields,
    ):
        """application_count : int
        applications : typing.Sequence[~ModelApplicationInfo]
        error : Error
        filesystems : typing.Sequence[~ModelFilesystemInfo]
        hosted_machine_count : int
        life : str
        machines : typing.Sequence[~ModelMachineInfo]
        model_tag : str
        owner_tag : str
        type_ : str
        unit_count : int
        volumes : typing.Sequence[~ModelVolumeInfo]
        """
        application_count_ = application_count
        applications_ = [ModelApplicationInfo.from_json(o) for o in applications or []]
        error_ = Error.from_json(error) if error else None
        filesystems_ = [ModelFilesystemInfo.from_json(o) for o in filesystems or []]
        hosted_machine_count_ = hosted_machine_count
        life_ = life
        machines_ = [ModelMachineInfo.from_json(o) for o in machines or []]
        model_tag_ = model_tag
        owner_tag_ = owner_tag
        type__ = type_
        unit_count_ = unit_count
        volumes_ = [ModelVolumeInfo.from_json(o) for o in volumes or []]

        # Validate arguments against known Juju API types.
        if application_count_ is not None and not isinstance(application_count_, int):
            raise Exception(
                f"Expected application_count_ to be a int, received: {type(application_count_)}"
            )

        if applications_ is not None and not isinstance(
            applications_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected applications_ to be a Sequence, received: {type(applications_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if filesystems_ is not None and not isinstance(
            filesystems_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected filesystems_ to be a Sequence, received: {type(filesystems_)}"
            )

        if hosted_machine_count_ is not None and not isinstance(
            hosted_machine_count_, int
        ):
            raise Exception(
                f"Expected hosted_machine_count_ to be a int, received: {type(hosted_machine_count_)}"
            )

        if life_ is not None and not isinstance(life_, (bytes, str)):
            raise Exception(f"Expected life_ to be a str, received: {type(life_)}")

        if machines_ is not None and not isinstance(machines_, (bytes, str, list)):
            raise Exception(
                f"Expected machines_ to be a Sequence, received: {type(machines_)}"
            )

        if model_tag_ is not None and not isinstance(model_tag_, (bytes, str)):
            raise Exception(
                f"Expected model_tag_ to be a str, received: {type(model_tag_)}"
            )

        if owner_tag_ is not None and not isinstance(owner_tag_, (bytes, str)):
            raise Exception(
                f"Expected owner_tag_ to be a str, received: {type(owner_tag_)}"
            )

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        if unit_count_ is not None and not isinstance(unit_count_, int):
            raise Exception(
                f"Expected unit_count_ to be a int, received: {type(unit_count_)}"
            )

        if volumes_ is not None and not isinstance(volumes_, (bytes, str, list)):
            raise Exception(
                f"Expected volumes_ to be a Sequence, received: {type(volumes_)}"
            )

        self.application_count = application_count_
        self.applications = applications_
        self.error = error_
        self.filesystems = filesystems_
        self.hosted_machine_count = hosted_machine_count_
        self.life = life_
        self.machines = machines_
        self.model_tag = model_tag_
        self.owner_tag = owner_tag_
        self.type_ = type__
        self.unit_count = unit_count_
        self.volumes = volumes_
        self.unknown_fields = unknown_fields


class ModelStatusInfo(Type):
    _toSchema = {
        "available_version": "available-version",
        "cloud_tag": "cloud-tag",
        "meter_status": "meter-status",
        "model_status": "model-status",
        "name": "name",
        "region": "region",
        "sla": "sla",
        "type_": "type",
        "version": "version",
    }
    _toPy = {
        "available-version": "available_version",
        "cloud-tag": "cloud_tag",
        "meter-status": "meter_status",
        "model-status": "model_status",
        "name": "name",
        "region": "region",
        "sla": "sla",
        "type": "type_",
        "version": "version",
    }

    def __init__(
        self,
        available_version=None,
        cloud_tag=None,
        meter_status=None,
        model_status=None,
        name=None,
        region=None,
        sla=None,
        type_=None,
        version=None,
        **unknown_fields,
    ):
        """available_version : str
        cloud_tag : str
        meter_status : MeterStatus
        model_status : DetailedStatus
        name : str
        region : str
        sla : str
        type_ : str
        version : str
        """
        available_version_ = available_version
        cloud_tag_ = cloud_tag
        meter_status_ = MeterStatus.from_json(meter_status) if meter_status else None
        model_status_ = DetailedStatus.from_json(model_status) if model_status else None
        name_ = name
        region_ = region
        sla_ = sla
        type__ = type_
        version_ = version

        # Validate arguments against known Juju API types.
        if available_version_ is not None and not isinstance(
            available_version_, (bytes, str)
        ):
            raise Exception(
                f"Expected available_version_ to be a str, received: {type(available_version_)}"
            )

        if cloud_tag_ is not None and not isinstance(cloud_tag_, (bytes, str)):
            raise Exception(
                f"Expected cloud_tag_ to be a str, received: {type(cloud_tag_)}"
            )

        if meter_status_ is not None and not isinstance(
            meter_status_, (dict, MeterStatus)
        ):
            raise Exception(
                f"Expected meter_status_ to be a MeterStatus, received: {type(meter_status_)}"
            )

        if model_status_ is not None and not isinstance(
            model_status_, (dict, DetailedStatus)
        ):
            raise Exception(
                f"Expected model_status_ to be a DetailedStatus, received: {type(model_status_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if region_ is not None and not isinstance(region_, (bytes, str)):
            raise Exception(f"Expected region_ to be a str, received: {type(region_)}")

        if sla_ is not None and not isinstance(sla_, (bytes, str)):
            raise Exception(f"Expected sla_ to be a str, received: {type(sla_)}")

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        if version_ is not None and not isinstance(version_, (bytes, str)):
            raise Exception(
                f"Expected version_ to be a str, received: {type(version_)}"
            )

        self.available_version = available_version_
        self.cloud_tag = cloud_tag_
        self.meter_status = meter_status_
        self.model_status = model_status_
        self.name = name_
        self.region = region_
        self.sla = sla_
        self.type_ = type__
        self.version = version_
        self.unknown_fields = unknown_fields


class ModelStatusResults(Type):
    _toSchema = {"models": "models"}
    _toPy = {"models": "models"}

    def __init__(self, models=None, **unknown_fields):
        """Models : typing.Sequence[~ModelStatus]"""
        models_ = [ModelStatus.from_json(o) for o in models or []]

        # Validate arguments against known Juju API types.
        if models_ is not None and not isinstance(models_, (bytes, str, list)):
            raise Exception(
                f"Expected models_ to be a Sequence, received: {type(models_)}"
            )

        self.models = models_
        self.unknown_fields = unknown_fields


class ModelSummariesRequest(Type):
    _toSchema = {"all_": "all", "user_tag": "user-tag"}
    _toPy = {"all": "all_", "user-tag": "user_tag"}

    def __init__(self, all_=None, user_tag=None, **unknown_fields):
        """all_ : bool
        user_tag : str
        """
        all__ = all_
        user_tag_ = user_tag

        # Validate arguments against known Juju API types.
        if all__ is not None and not isinstance(all__, bool):
            raise Exception(f"Expected all__ to be a bool, received: {type(all__)}")

        if user_tag_ is not None and not isinstance(user_tag_, (bytes, str)):
            raise Exception(
                f"Expected user_tag_ to be a str, received: {type(user_tag_)}"
            )

        self.all_ = all__
        self.user_tag = user_tag_
        self.unknown_fields = unknown_fields


class ModelSummary(Type):
    _toSchema = {
        "agent_version": "agent-version",
        "cloud_credential_tag": "cloud-credential-tag",
        "cloud_region": "cloud-region",
        "cloud_tag": "cloud-tag",
        "controller_uuid": "controller-uuid",
        "counts": "counts",
        "default_series": "default-series",
        "is_controller": "is-controller",
        "last_connection": "last-connection",
        "life": "life",
        "migration": "migration",
        "name": "name",
        "owner_tag": "owner-tag",
        "provider_type": "provider-type",
        "sla": "sla",
        "status": "status",
        "type_": "type",
        "user_access": "user-access",
        "uuid": "uuid",
    }
    _toPy = {
        "agent-version": "agent_version",
        "cloud-credential-tag": "cloud_credential_tag",
        "cloud-region": "cloud_region",
        "cloud-tag": "cloud_tag",
        "controller-uuid": "controller_uuid",
        "counts": "counts",
        "default-series": "default_series",
        "is-controller": "is_controller",
        "last-connection": "last_connection",
        "life": "life",
        "migration": "migration",
        "name": "name",
        "owner-tag": "owner_tag",
        "provider-type": "provider_type",
        "sla": "sla",
        "status": "status",
        "type": "type_",
        "user-access": "user_access",
        "uuid": "uuid",
    }

    def __init__(
        self,
        agent_version=None,
        cloud_credential_tag=None,
        cloud_region=None,
        cloud_tag=None,
        controller_uuid=None,
        counts=None,
        default_series=None,
        is_controller=None,
        last_connection=None,
        life=None,
        migration=None,
        name=None,
        owner_tag=None,
        provider_type=None,
        sla=None,
        status=None,
        type_=None,
        user_access=None,
        uuid=None,
        **unknown_fields,
    ):
        """agent_version : Number
        cloud_credential_tag : str
        cloud_region : str
        cloud_tag : str
        controller_uuid : str
        counts : typing.Sequence[~ModelEntityCount]
        default_series : str
        is_controller : bool
        last_connection : str
        life : str
        migration : ModelMigrationStatus
        name : str
        owner_tag : str
        provider_type : str
        sla : ModelSLAInfo
        status : EntityStatus
        type_ : str
        user_access : str
        uuid : str
        """
        agent_version_ = Number.from_json(agent_version) if agent_version else None
        cloud_credential_tag_ = cloud_credential_tag
        cloud_region_ = cloud_region
        cloud_tag_ = cloud_tag
        controller_uuid_ = controller_uuid
        counts_ = [ModelEntityCount.from_json(o) for o in counts or []]
        default_series_ = default_series
        is_controller_ = is_controller
        last_connection_ = last_connection
        life_ = life
        migration_ = ModelMigrationStatus.from_json(migration) if migration else None
        name_ = name
        owner_tag_ = owner_tag
        provider_type_ = provider_type
        sla_ = ModelSLAInfo.from_json(sla) if sla else None
        status_ = EntityStatus.from_json(status) if status else None
        type__ = type_
        user_access_ = user_access
        uuid_ = uuid

        # Validate arguments against known Juju API types.
        if agent_version_ is not None and not isinstance(
            agent_version_, (dict, Number)
        ):
            raise Exception(
                f"Expected agent_version_ to be a Number, received: {type(agent_version_)}"
            )

        if cloud_credential_tag_ is not None and not isinstance(
            cloud_credential_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected cloud_credential_tag_ to be a str, received: {type(cloud_credential_tag_)}"
            )

        if cloud_region_ is not None and not isinstance(cloud_region_, (bytes, str)):
            raise Exception(
                f"Expected cloud_region_ to be a str, received: {type(cloud_region_)}"
            )

        if cloud_tag_ is not None and not isinstance(cloud_tag_, (bytes, str)):
            raise Exception(
                f"Expected cloud_tag_ to be a str, received: {type(cloud_tag_)}"
            )

        if controller_uuid_ is not None and not isinstance(
            controller_uuid_, (bytes, str)
        ):
            raise Exception(
                f"Expected controller_uuid_ to be a str, received: {type(controller_uuid_)}"
            )

        if counts_ is not None and not isinstance(counts_, (bytes, str, list)):
            raise Exception(
                f"Expected counts_ to be a Sequence, received: {type(counts_)}"
            )

        if default_series_ is not None and not isinstance(
            default_series_, (bytes, str)
        ):
            raise Exception(
                f"Expected default_series_ to be a str, received: {type(default_series_)}"
            )

        if is_controller_ is not None and not isinstance(is_controller_, bool):
            raise Exception(
                f"Expected is_controller_ to be a bool, received: {type(is_controller_)}"
            )

        if last_connection_ is not None and not isinstance(
            last_connection_, (bytes, str)
        ):
            raise Exception(
                f"Expected last_connection_ to be a str, received: {type(last_connection_)}"
            )

        if life_ is not None and not isinstance(life_, (bytes, str)):
            raise Exception(f"Expected life_ to be a str, received: {type(life_)}")

        if migration_ is not None and not isinstance(
            migration_, (dict, ModelMigrationStatus)
        ):
            raise Exception(
                f"Expected migration_ to be a ModelMigrationStatus, received: {type(migration_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if owner_tag_ is not None and not isinstance(owner_tag_, (bytes, str)):
            raise Exception(
                f"Expected owner_tag_ to be a str, received: {type(owner_tag_)}"
            )

        if provider_type_ is not None and not isinstance(provider_type_, (bytes, str)):
            raise Exception(
                f"Expected provider_type_ to be a str, received: {type(provider_type_)}"
            )

        if sla_ is not None and not isinstance(sla_, (dict, ModelSLAInfo)):
            raise Exception(
                f"Expected sla_ to be a ModelSLAInfo, received: {type(sla_)}"
            )

        if status_ is not None and not isinstance(status_, (dict, EntityStatus)):
            raise Exception(
                f"Expected status_ to be a EntityStatus, received: {type(status_)}"
            )

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        if user_access_ is not None and not isinstance(user_access_, (bytes, str)):
            raise Exception(
                f"Expected user_access_ to be a str, received: {type(user_access_)}"
            )

        if uuid_ is not None and not isinstance(uuid_, (bytes, str)):
            raise Exception(f"Expected uuid_ to be a str, received: {type(uuid_)}")

        self.agent_version = agent_version_
        self.cloud_credential_tag = cloud_credential_tag_
        self.cloud_region = cloud_region_
        self.cloud_tag = cloud_tag_
        self.controller_uuid = controller_uuid_
        self.counts = counts_
        self.default_series = default_series_
        self.is_controller = is_controller_
        self.last_connection = last_connection_
        self.life = life_
        self.migration = migration_
        self.name = name_
        self.owner_tag = owner_tag_
        self.provider_type = provider_type_
        self.sla = sla_
        self.status = status_
        self.type_ = type__
        self.user_access = user_access_
        self.uuid = uuid_
        self.unknown_fields = unknown_fields


class ModelSummaryResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : ModelSummary
        """
        error_ = Error.from_json(error) if error else None
        result_ = ModelSummary.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (dict, ModelSummary)):
            raise Exception(
                f"Expected result_ to be a ModelSummary, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class ModelSummaryResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ModelSummaryResult]"""
        results_ = [ModelSummaryResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ModelTag(Type):
    _toSchema = {}
    _toPy = {}

    def __init__(self, **unknown_fields):
        """ """
        self.unknown_fields = unknown_fields


class ModelUnset(Type):
    _toSchema = {"keys": "keys"}
    _toPy = {"keys": "keys"}

    def __init__(self, keys=None, **unknown_fields):
        """Keys : typing.Sequence[str]"""
        keys_ = keys

        # Validate arguments against known Juju API types.
        if keys_ is not None and not isinstance(keys_, (bytes, str, list)):
            raise Exception(f"Expected keys_ to be a Sequence, received: {type(keys_)}")

        self.keys = keys_
        self.unknown_fields = unknown_fields


class ModelUnsetKeys(Type):
    _toSchema = {
        "cloud_region": "cloud-region",
        "cloud_tag": "cloud-tag",
        "keys": "keys",
    }
    _toPy = {"cloud-region": "cloud_region", "cloud-tag": "cloud_tag", "keys": "keys"}

    def __init__(self, cloud_region=None, cloud_tag=None, keys=None, **unknown_fields):
        """cloud_region : str
        cloud_tag : str
        keys : typing.Sequence[str]
        """
        cloud_region_ = cloud_region
        cloud_tag_ = cloud_tag
        keys_ = keys

        # Validate arguments against known Juju API types.
        if cloud_region_ is not None and not isinstance(cloud_region_, (bytes, str)):
            raise Exception(
                f"Expected cloud_region_ to be a str, received: {type(cloud_region_)}"
            )

        if cloud_tag_ is not None and not isinstance(cloud_tag_, (bytes, str)):
            raise Exception(
                f"Expected cloud_tag_ to be a str, received: {type(cloud_tag_)}"
            )

        if keys_ is not None and not isinstance(keys_, (bytes, str, list)):
            raise Exception(f"Expected keys_ to be a Sequence, received: {type(keys_)}")

        self.cloud_region = cloud_region_
        self.cloud_tag = cloud_tag_
        self.keys = keys_
        self.unknown_fields = unknown_fields


class ModelUserInfo(Type):
    _toSchema = {
        "access": "access",
        "display_name": "display-name",
        "last_connection": "last-connection",
        "model_tag": "model-tag",
        "user": "user",
    }
    _toPy = {
        "access": "access",
        "display-name": "display_name",
        "last-connection": "last_connection",
        "model-tag": "model_tag",
        "user": "user",
    }

    def __init__(
        self,
        access=None,
        display_name=None,
        last_connection=None,
        model_tag=None,
        user=None,
        **unknown_fields,
    ):
        """Access : str
        display_name : str
        last_connection : str
        model_tag : str
        user : str
        """
        access_ = access
        display_name_ = display_name
        last_connection_ = last_connection
        model_tag_ = model_tag
        user_ = user

        # Validate arguments against known Juju API types.
        if access_ is not None and not isinstance(access_, (bytes, str)):
            raise Exception(f"Expected access_ to be a str, received: {type(access_)}")

        if display_name_ is not None and not isinstance(display_name_, (bytes, str)):
            raise Exception(
                f"Expected display_name_ to be a str, received: {type(display_name_)}"
            )

        if last_connection_ is not None and not isinstance(
            last_connection_, (bytes, str)
        ):
            raise Exception(
                f"Expected last_connection_ to be a str, received: {type(last_connection_)}"
            )

        if model_tag_ is not None and not isinstance(model_tag_, (bytes, str)):
            raise Exception(
                f"Expected model_tag_ to be a str, received: {type(model_tag_)}"
            )

        if user_ is not None and not isinstance(user_, (bytes, str)):
            raise Exception(f"Expected user_ to be a str, received: {type(user_)}")

        self.access = access_
        self.display_name = display_name_
        self.last_connection = last_connection_
        self.model_tag = model_tag_
        self.user = user_
        self.unknown_fields = unknown_fields


class ModelUserInfoResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : ModelUserInfo
        """
        error_ = Error.from_json(error) if error else None
        result_ = ModelUserInfo.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (dict, ModelUserInfo)):
            raise Exception(
                f"Expected result_ to be a ModelUserInfo, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class ModelUserInfoResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ModelUserInfoResult]"""
        results_ = [ModelUserInfoResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ModelVolumeInfo(Type):
    _toSchema = {
        "detachable": "detachable",
        "id_": "id",
        "message": "message",
        "provider_id": "provider-id",
        "status": "status",
    }
    _toPy = {
        "detachable": "detachable",
        "id": "id_",
        "message": "message",
        "provider-id": "provider_id",
        "status": "status",
    }

    def __init__(
        self,
        detachable=None,
        id_=None,
        message=None,
        provider_id=None,
        status=None,
        **unknown_fields,
    ):
        """Detachable : bool
        id_ : str
        message : str
        provider_id : str
        status : str
        """
        detachable_ = detachable
        id__ = id_
        message_ = message
        provider_id_ = provider_id
        status_ = status

        # Validate arguments against known Juju API types.
        if detachable_ is not None and not isinstance(detachable_, bool):
            raise Exception(
                f"Expected detachable_ to be a bool, received: {type(detachable_)}"
            )

        if id__ is not None and not isinstance(id__, (bytes, str)):
            raise Exception(f"Expected id__ to be a str, received: {type(id__)}")

        if message_ is not None and not isinstance(message_, (bytes, str)):
            raise Exception(
                f"Expected message_ to be a str, received: {type(message_)}"
            )

        if provider_id_ is not None and not isinstance(provider_id_, (bytes, str)):
            raise Exception(
                f"Expected provider_id_ to be a str, received: {type(provider_id_)}"
            )

        if status_ is not None and not isinstance(status_, (bytes, str)):
            raise Exception(f"Expected status_ to be a str, received: {type(status_)}")

        self.detachable = detachable_
        self.id_ = id__
        self.message = message_
        self.provider_id = provider_id_
        self.status = status_
        self.unknown_fields = unknown_fields


class ModifyCloudAccess(Type):
    _toSchema = {
        "access": "access",
        "action": "action",
        "cloud_tag": "cloud-tag",
        "user_tag": "user-tag",
    }
    _toPy = {
        "access": "access",
        "action": "action",
        "cloud-tag": "cloud_tag",
        "user-tag": "user_tag",
    }

    def __init__(
        self, access=None, action=None, cloud_tag=None, user_tag=None, **unknown_fields
    ):
        """Access : str
        action : str
        cloud_tag : str
        user_tag : str
        """
        access_ = access
        action_ = action
        cloud_tag_ = cloud_tag
        user_tag_ = user_tag

        # Validate arguments against known Juju API types.
        if access_ is not None and not isinstance(access_, (bytes, str)):
            raise Exception(f"Expected access_ to be a str, received: {type(access_)}")

        if action_ is not None and not isinstance(action_, (bytes, str)):
            raise Exception(f"Expected action_ to be a str, received: {type(action_)}")

        if cloud_tag_ is not None and not isinstance(cloud_tag_, (bytes, str)):
            raise Exception(
                f"Expected cloud_tag_ to be a str, received: {type(cloud_tag_)}"
            )

        if user_tag_ is not None and not isinstance(user_tag_, (bytes, str)):
            raise Exception(
                f"Expected user_tag_ to be a str, received: {type(user_tag_)}"
            )

        self.access = access_
        self.action = action_
        self.cloud_tag = cloud_tag_
        self.user_tag = user_tag_
        self.unknown_fields = unknown_fields


class ModifyCloudAccessRequest(Type):
    _toSchema = {"changes": "changes"}
    _toPy = {"changes": "changes"}

    def __init__(self, changes=None, **unknown_fields):
        """Changes : typing.Sequence[~ModifyCloudAccess]"""
        changes_ = [ModifyCloudAccess.from_json(o) for o in changes or []]

        # Validate arguments against known Juju API types.
        if changes_ is not None and not isinstance(changes_, (bytes, str, list)):
            raise Exception(
                f"Expected changes_ to be a Sequence, received: {type(changes_)}"
            )

        self.changes = changes_
        self.unknown_fields = unknown_fields


class ModifyControllerAccess(Type):
    _toSchema = {"access": "access", "action": "action", "user_tag": "user-tag"}
    _toPy = {"access": "access", "action": "action", "user-tag": "user_tag"}

    def __init__(self, access=None, action=None, user_tag=None, **unknown_fields):
        """Access : str
        action : str
        user_tag : str
        """
        access_ = access
        action_ = action
        user_tag_ = user_tag

        # Validate arguments against known Juju API types.
        if access_ is not None and not isinstance(access_, (bytes, str)):
            raise Exception(f"Expected access_ to be a str, received: {type(access_)}")

        if action_ is not None and not isinstance(action_, (bytes, str)):
            raise Exception(f"Expected action_ to be a str, received: {type(action_)}")

        if user_tag_ is not None and not isinstance(user_tag_, (bytes, str)):
            raise Exception(
                f"Expected user_tag_ to be a str, received: {type(user_tag_)}"
            )

        self.access = access_
        self.action = action_
        self.user_tag = user_tag_
        self.unknown_fields = unknown_fields


class ModifyControllerAccessRequest(Type):
    _toSchema = {"changes": "changes"}
    _toPy = {"changes": "changes"}

    def __init__(self, changes=None, **unknown_fields):
        """Changes : typing.Sequence[~ModifyControllerAccess]"""
        changes_ = [ModifyControllerAccess.from_json(o) for o in changes or []]

        # Validate arguments against known Juju API types.
        if changes_ is not None and not isinstance(changes_, (bytes, str, list)):
            raise Exception(
                f"Expected changes_ to be a Sequence, received: {type(changes_)}"
            )

        self.changes = changes_
        self.unknown_fields = unknown_fields


class ModifyModelAccess(Type):
    _toSchema = {
        "access": "access",
        "action": "action",
        "model_tag": "model-tag",
        "user_tag": "user-tag",
    }
    _toPy = {
        "access": "access",
        "action": "action",
        "model-tag": "model_tag",
        "user-tag": "user_tag",
    }

    def __init__(
        self, access=None, action=None, model_tag=None, user_tag=None, **unknown_fields
    ):
        """Access : str
        action : str
        model_tag : str
        user_tag : str
        """
        access_ = access
        action_ = action
        model_tag_ = model_tag
        user_tag_ = user_tag

        # Validate arguments against known Juju API types.
        if access_ is not None and not isinstance(access_, (bytes, str)):
            raise Exception(f"Expected access_ to be a str, received: {type(access_)}")

        if action_ is not None and not isinstance(action_, (bytes, str)):
            raise Exception(f"Expected action_ to be a str, received: {type(action_)}")

        if model_tag_ is not None and not isinstance(model_tag_, (bytes, str)):
            raise Exception(
                f"Expected model_tag_ to be a str, received: {type(model_tag_)}"
            )

        if user_tag_ is not None and not isinstance(user_tag_, (bytes, str)):
            raise Exception(
                f"Expected user_tag_ to be a str, received: {type(user_tag_)}"
            )

        self.access = access_
        self.action = action_
        self.model_tag = model_tag_
        self.user_tag = user_tag_
        self.unknown_fields = unknown_fields


class ModifyModelAccessRequest(Type):
    _toSchema = {"changes": "changes"}
    _toPy = {"changes": "changes"}

    def __init__(self, changes=None, **unknown_fields):
        """Changes : typing.Sequence[~ModifyModelAccess]"""
        changes_ = [ModifyModelAccess.from_json(o) for o in changes or []]

        # Validate arguments against known Juju API types.
        if changes_ is not None and not isinstance(changes_, (bytes, str, list)):
            raise Exception(
                f"Expected changes_ to be a Sequence, received: {type(changes_)}"
            )

        self.changes = changes_
        self.unknown_fields = unknown_fields


class ModifyOfferAccess(Type):
    _toSchema = {
        "access": "access",
        "action": "action",
        "offer_url": "offer-url",
        "user_tag": "user-tag",
    }
    _toPy = {
        "access": "access",
        "action": "action",
        "offer-url": "offer_url",
        "user-tag": "user_tag",
    }

    def __init__(
        self, access=None, action=None, offer_url=None, user_tag=None, **unknown_fields
    ):
        """Access : str
        action : str
        offer_url : str
        user_tag : str
        """
        access_ = access
        action_ = action
        offer_url_ = offer_url
        user_tag_ = user_tag

        # Validate arguments against known Juju API types.
        if access_ is not None and not isinstance(access_, (bytes, str)):
            raise Exception(f"Expected access_ to be a str, received: {type(access_)}")

        if action_ is not None and not isinstance(action_, (bytes, str)):
            raise Exception(f"Expected action_ to be a str, received: {type(action_)}")

        if offer_url_ is not None and not isinstance(offer_url_, (bytes, str)):
            raise Exception(
                f"Expected offer_url_ to be a str, received: {type(offer_url_)}"
            )

        if user_tag_ is not None and not isinstance(user_tag_, (bytes, str)):
            raise Exception(
                f"Expected user_tag_ to be a str, received: {type(user_tag_)}"
            )

        self.access = access_
        self.action = action_
        self.offer_url = offer_url_
        self.user_tag = user_tag_
        self.unknown_fields = unknown_fields


class ModifyOfferAccessRequest(Type):
    _toSchema = {"changes": "changes"}
    _toPy = {"changes": "changes"}

    def __init__(self, changes=None, **unknown_fields):
        """Changes : typing.Sequence[~ModifyOfferAccess]"""
        changes_ = [ModifyOfferAccess.from_json(o) for o in changes or []]

        # Validate arguments against known Juju API types.
        if changes_ is not None and not isinstance(changes_, (bytes, str, list)):
            raise Exception(
                f"Expected changes_ to be a Sequence, received: {type(changes_)}"
            )

        self.changes = changes_
        self.unknown_fields = unknown_fields


class ModifyUserSSHKeys(Type):
    _toSchema = {"ssh_keys": "ssh-keys", "user": "user"}
    _toPy = {"ssh-keys": "ssh_keys", "user": "user"}

    def __init__(self, ssh_keys=None, user=None, **unknown_fields):
        """ssh_keys : typing.Sequence[str]
        user : str
        """
        ssh_keys_ = ssh_keys
        user_ = user

        # Validate arguments against known Juju API types.
        if ssh_keys_ is not None and not isinstance(ssh_keys_, (bytes, str, list)):
            raise Exception(
                f"Expected ssh_keys_ to be a Sequence, received: {type(ssh_keys_)}"
            )

        if user_ is not None and not isinstance(user_, (bytes, str)):
            raise Exception(f"Expected user_ to be a str, received: {type(user_)}")

        self.ssh_keys = ssh_keys_
        self.user = user_
        self.unknown_fields = unknown_fields


class MoveSubnetsParam(Type):
    _toSchema = {"force": "force", "space_tag": "space-tag", "subnets": "subnets"}
    _toPy = {"force": "force", "space-tag": "space_tag", "subnets": "subnets"}

    def __init__(self, force=None, space_tag=None, subnets=None, **unknown_fields):
        """Force : bool
        space_tag : str
        subnets : typing.Sequence[str]
        """
        force_ = force
        space_tag_ = space_tag
        subnets_ = subnets

        # Validate arguments against known Juju API types.
        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if space_tag_ is not None and not isinstance(space_tag_, (bytes, str)):
            raise Exception(
                f"Expected space_tag_ to be a str, received: {type(space_tag_)}"
            )

        if subnets_ is not None and not isinstance(subnets_, (bytes, str, list)):
            raise Exception(
                f"Expected subnets_ to be a Sequence, received: {type(subnets_)}"
            )

        self.force = force_
        self.space_tag = space_tag_
        self.subnets = subnets_
        self.unknown_fields = unknown_fields


class MoveSubnetsParams(Type):
    _toSchema = {"args": "args"}
    _toPy = {"args": "args"}

    def __init__(self, args=None, **unknown_fields):
        """Args : typing.Sequence[~MoveSubnetsParam]"""
        args_ = [MoveSubnetsParam.from_json(o) for o in args or []]

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, (bytes, str, list)):
            raise Exception(f"Expected args_ to be a Sequence, received: {type(args_)}")

        self.args = args_
        self.unknown_fields = unknown_fields


class MoveSubnetsResult(Type):
    _toSchema = {
        "error": "error",
        "moved_subnets": "moved-subnets",
        "new_space": "new-space",
    }
    _toPy = {
        "error": "error",
        "moved-subnets": "moved_subnets",
        "new-space": "new_space",
    }

    def __init__(
        self, error=None, moved_subnets=None, new_space=None, **unknown_fields
    ):
        """Error : Error
        moved_subnets : typing.Sequence[~MovedSubnet]
        new_space : str
        """
        error_ = Error.from_json(error) if error else None
        moved_subnets_ = [MovedSubnet.from_json(o) for o in moved_subnets or []]
        new_space_ = new_space

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if moved_subnets_ is not None and not isinstance(
            moved_subnets_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected moved_subnets_ to be a Sequence, received: {type(moved_subnets_)}"
            )

        if new_space_ is not None and not isinstance(new_space_, (bytes, str)):
            raise Exception(
                f"Expected new_space_ to be a str, received: {type(new_space_)}"
            )

        self.error = error_
        self.moved_subnets = moved_subnets_
        self.new_space = new_space_
        self.unknown_fields = unknown_fields


class MoveSubnetsResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~MoveSubnetsResult]"""
        results_ = [MoveSubnetsResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class MovedSubnet(Type):
    _toSchema = {"cidr": "cidr", "old_space": "old-space", "subnet": "subnet"}
    _toPy = {"cidr": "cidr", "old-space": "old_space", "subnet": "subnet"}

    def __init__(self, cidr=None, old_space=None, subnet=None, **unknown_fields):
        """Cidr : str
        old_space : str
        subnet : str
        """
        cidr_ = cidr
        old_space_ = old_space
        subnet_ = subnet

        # Validate arguments against known Juju API types.
        if cidr_ is not None and not isinstance(cidr_, (bytes, str)):
            raise Exception(f"Expected cidr_ to be a str, received: {type(cidr_)}")

        if old_space_ is not None and not isinstance(old_space_, (bytes, str)):
            raise Exception(
                f"Expected old_space_ to be a str, received: {type(old_space_)}"
            )

        if subnet_ is not None and not isinstance(subnet_, (bytes, str)):
            raise Exception(f"Expected subnet_ to be a str, received: {type(subnet_)}")

        self.cidr = cidr_
        self.old_space = old_space_
        self.subnet = subnet_
        self.unknown_fields = unknown_fields


class NetworkInterface(Type):
    _toSchema = {
        "dns_nameservers": "dns-nameservers",
        "gateway": "gateway",
        "ip_addresses": "ip-addresses",
        "is_up": "is-up",
        "mac_address": "mac-address",
        "space": "space",
    }
    _toPy = {
        "dns-nameservers": "dns_nameservers",
        "gateway": "gateway",
        "ip-addresses": "ip_addresses",
        "is-up": "is_up",
        "mac-address": "mac_address",
        "space": "space",
    }

    def __init__(
        self,
        dns_nameservers=None,
        gateway=None,
        ip_addresses=None,
        is_up=None,
        mac_address=None,
        space=None,
        **unknown_fields,
    ):
        """dns_nameservers : typing.Sequence[str]
        gateway : str
        ip_addresses : typing.Sequence[str]
        is_up : bool
        mac_address : str
        space : str
        """
        dns_nameservers_ = dns_nameservers
        gateway_ = gateway
        ip_addresses_ = ip_addresses
        is_up_ = is_up
        mac_address_ = mac_address
        space_ = space

        # Validate arguments against known Juju API types.
        if dns_nameservers_ is not None and not isinstance(
            dns_nameservers_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected dns_nameservers_ to be a Sequence, received: {type(dns_nameservers_)}"
            )

        if gateway_ is not None and not isinstance(gateway_, (bytes, str)):
            raise Exception(
                f"Expected gateway_ to be a str, received: {type(gateway_)}"
            )

        if ip_addresses_ is not None and not isinstance(
            ip_addresses_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected ip_addresses_ to be a Sequence, received: {type(ip_addresses_)}"
            )

        if is_up_ is not None and not isinstance(is_up_, bool):
            raise Exception(f"Expected is_up_ to be a bool, received: {type(is_up_)}")

        if mac_address_ is not None and not isinstance(mac_address_, (bytes, str)):
            raise Exception(
                f"Expected mac_address_ to be a str, received: {type(mac_address_)}"
            )

        if space_ is not None and not isinstance(space_, (bytes, str)):
            raise Exception(f"Expected space_ to be a str, received: {type(space_)}")

        self.dns_nameservers = dns_nameservers_
        self.gateway = gateway_
        self.ip_addresses = ip_addresses_
        self.is_up = is_up_
        self.mac_address = mac_address_
        self.space = space_
        self.unknown_fields = unknown_fields


class NotifyWatchResult(Type):
    _toSchema = {"error": "error", "notifywatcherid": "NotifyWatcherId"}
    _toPy = {"NotifyWatcherId": "notifywatcherid", "error": "error"}

    def __init__(self, notifywatcherid=None, error=None, **unknown_fields):
        """Notifywatcherid : str
        error : Error
        """
        notifywatcherid_ = notifywatcherid
        error_ = Error.from_json(error) if error else None

        # Validate arguments against known Juju API types.
        if notifywatcherid_ is not None and not isinstance(
            notifywatcherid_, (bytes, str)
        ):
            raise Exception(
                f"Expected notifywatcherid_ to be a str, received: {type(notifywatcherid_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        self.notifywatcherid = notifywatcherid_
        self.error = error_
        self.unknown_fields = unknown_fields


class NotifyWatchResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~NotifyWatchResult]"""
        results_ = [NotifyWatchResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class Number(Type):
    _toSchema = {
        "build": "Build",
        "major": "Major",
        "minor": "Minor",
        "patch": "Patch",
        "tag": "Tag",
    }
    _toPy = {
        "Build": "build",
        "Major": "major",
        "Minor": "minor",
        "Patch": "patch",
        "Tag": "tag",
    }

    def __init__(
        self, build=None, major=None, minor=None, patch=None, tag=None, **unknown_fields
    ):
        """Build : int
        major : int
        minor : int
        patch : int
        tag : str
        """
        build_ = build
        major_ = major
        minor_ = minor
        patch_ = patch
        tag_ = tag

        # Validate arguments against known Juju API types.
        if build_ is not None and not isinstance(build_, int):
            raise Exception(f"Expected build_ to be a int, received: {type(build_)}")

        if major_ is not None and not isinstance(major_, int):
            raise Exception(f"Expected major_ to be a int, received: {type(major_)}")

        if minor_ is not None and not isinstance(minor_, int):
            raise Exception(f"Expected minor_ to be a int, received: {type(minor_)}")

        if patch_ is not None and not isinstance(patch_, int):
            raise Exception(f"Expected patch_ to be a int, received: {type(patch_)}")

        if tag_ is not None and not isinstance(tag_, (bytes, str)):
            raise Exception(f"Expected tag_ to be a str, received: {type(tag_)}")

        self.build = build_
        self.major = major_
        self.minor = minor_
        self.patch = patch_
        self.tag = tag_
        self.unknown_fields = unknown_fields


class OfferConnection(Type):
    _toSchema = {
        "endpoint": "endpoint",
        "ingress_subnets": "ingress-subnets",
        "relation_id": "relation-id",
        "source_model_tag": "source-model-tag",
        "status": "status",
        "username": "username",
    }
    _toPy = {
        "endpoint": "endpoint",
        "ingress-subnets": "ingress_subnets",
        "relation-id": "relation_id",
        "source-model-tag": "source_model_tag",
        "status": "status",
        "username": "username",
    }

    def __init__(
        self,
        endpoint=None,
        ingress_subnets=None,
        relation_id=None,
        source_model_tag=None,
        status=None,
        username=None,
        **unknown_fields,
    ):
        """Endpoint : str
        ingress_subnets : typing.Sequence[str]
        relation_id : int
        source_model_tag : str
        status : EntityStatus
        username : str
        """
        endpoint_ = endpoint
        ingress_subnets_ = ingress_subnets
        relation_id_ = relation_id
        source_model_tag_ = source_model_tag
        status_ = EntityStatus.from_json(status) if status else None
        username_ = username

        # Validate arguments against known Juju API types.
        if endpoint_ is not None and not isinstance(endpoint_, (bytes, str)):
            raise Exception(
                f"Expected endpoint_ to be a str, received: {type(endpoint_)}"
            )

        if ingress_subnets_ is not None and not isinstance(
            ingress_subnets_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected ingress_subnets_ to be a Sequence, received: {type(ingress_subnets_)}"
            )

        if relation_id_ is not None and not isinstance(relation_id_, int):
            raise Exception(
                f"Expected relation_id_ to be a int, received: {type(relation_id_)}"
            )

        if source_model_tag_ is not None and not isinstance(
            source_model_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected source_model_tag_ to be a str, received: {type(source_model_tag_)}"
            )

        if status_ is not None and not isinstance(status_, (dict, EntityStatus)):
            raise Exception(
                f"Expected status_ to be a EntityStatus, received: {type(status_)}"
            )

        if username_ is not None and not isinstance(username_, (bytes, str)):
            raise Exception(
                f"Expected username_ to be a str, received: {type(username_)}"
            )

        self.endpoint = endpoint_
        self.ingress_subnets = ingress_subnets_
        self.relation_id = relation_id_
        self.source_model_tag = source_model_tag_
        self.status = status_
        self.username = username_
        self.unknown_fields = unknown_fields


class OfferFilter(Type):
    _toSchema = {
        "allowed_users": "allowed-users",
        "application_description": "application-description",
        "application_name": "application-name",
        "application_user": "application-user",
        "connected_users": "connected-users",
        "endpoints": "endpoints",
        "model_name": "model-name",
        "offer_name": "offer-name",
        "owner_name": "owner-name",
    }
    _toPy = {
        "allowed-users": "allowed_users",
        "application-description": "application_description",
        "application-name": "application_name",
        "application-user": "application_user",
        "connected-users": "connected_users",
        "endpoints": "endpoints",
        "model-name": "model_name",
        "offer-name": "offer_name",
        "owner-name": "owner_name",
    }

    def __init__(
        self,
        allowed_users=None,
        application_description=None,
        application_name=None,
        application_user=None,
        connected_users=None,
        endpoints=None,
        model_name=None,
        offer_name=None,
        owner_name=None,
        **unknown_fields,
    ):
        """allowed_users : typing.Sequence[str]
        application_description : str
        application_name : str
        application_user : str
        connected_users : typing.Sequence[str]
        endpoints : typing.Sequence[~EndpointFilterAttributes]
        model_name : str
        offer_name : str
        owner_name : str
        """
        allowed_users_ = allowed_users
        application_description_ = application_description
        application_name_ = application_name
        application_user_ = application_user
        connected_users_ = connected_users
        endpoints_ = [EndpointFilterAttributes.from_json(o) for o in endpoints or []]
        model_name_ = model_name
        offer_name_ = offer_name
        owner_name_ = owner_name

        # Validate arguments against known Juju API types.
        if allowed_users_ is not None and not isinstance(
            allowed_users_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected allowed_users_ to be a Sequence, received: {type(allowed_users_)}"
            )

        if application_description_ is not None and not isinstance(
            application_description_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_description_ to be a str, received: {type(application_description_)}"
            )

        if application_name_ is not None and not isinstance(
            application_name_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_name_ to be a str, received: {type(application_name_)}"
            )

        if application_user_ is not None and not isinstance(
            application_user_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_user_ to be a str, received: {type(application_user_)}"
            )

        if connected_users_ is not None and not isinstance(
            connected_users_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected connected_users_ to be a Sequence, received: {type(connected_users_)}"
            )

        if endpoints_ is not None and not isinstance(endpoints_, (bytes, str, list)):
            raise Exception(
                f"Expected endpoints_ to be a Sequence, received: {type(endpoints_)}"
            )

        if model_name_ is not None and not isinstance(model_name_, (bytes, str)):
            raise Exception(
                f"Expected model_name_ to be a str, received: {type(model_name_)}"
            )

        if offer_name_ is not None and not isinstance(offer_name_, (bytes, str)):
            raise Exception(
                f"Expected offer_name_ to be a str, received: {type(offer_name_)}"
            )

        if owner_name_ is not None and not isinstance(owner_name_, (bytes, str)):
            raise Exception(
                f"Expected owner_name_ to be a str, received: {type(owner_name_)}"
            )

        self.allowed_users = allowed_users_
        self.application_description = application_description_
        self.application_name = application_name_
        self.application_user = application_user_
        self.connected_users = connected_users_
        self.endpoints = endpoints_
        self.model_name = model_name_
        self.offer_name = offer_name_
        self.owner_name = owner_name_
        self.unknown_fields = unknown_fields


class OfferFilters(Type):
    _toSchema = {"filters": "Filters"}
    _toPy = {"Filters": "filters"}

    def __init__(self, filters=None, **unknown_fields):
        """Filters : typing.Sequence[~OfferFilter]"""
        filters_ = [OfferFilter.from_json(o) for o in filters or []]

        # Validate arguments against known Juju API types.
        if filters_ is not None and not isinstance(filters_, (bytes, str, list)):
            raise Exception(
                f"Expected filters_ to be a Sequence, received: {type(filters_)}"
            )

        self.filters = filters_
        self.unknown_fields = unknown_fields


class OfferURLs(Type):
    _toSchema = {"bakery_version": "bakery-version", "offer_urls": "offer-urls"}
    _toPy = {"bakery-version": "bakery_version", "offer-urls": "offer_urls"}

    def __init__(self, bakery_version=None, offer_urls=None, **unknown_fields):
        """bakery_version : int
        offer_urls : typing.Sequence[str]
        """
        bakery_version_ = bakery_version
        offer_urls_ = offer_urls

        # Validate arguments against known Juju API types.
        if bakery_version_ is not None and not isinstance(bakery_version_, int):
            raise Exception(
                f"Expected bakery_version_ to be a int, received: {type(bakery_version_)}"
            )

        if offer_urls_ is not None and not isinstance(offer_urls_, (bytes, str, list)):
            raise Exception(
                f"Expected offer_urls_ to be a Sequence, received: {type(offer_urls_)}"
            )

        self.bakery_version = bakery_version_
        self.offer_urls = offer_urls_
        self.unknown_fields = unknown_fields


class OfferUserDetails(Type):
    _toSchema = {"access": "access", "display_name": "display-name", "user": "user"}
    _toPy = {"access": "access", "display-name": "display_name", "user": "user"}

    def __init__(self, access=None, display_name=None, user=None, **unknown_fields):
        """Access : str
        display_name : str
        user : str
        """
        access_ = access
        display_name_ = display_name
        user_ = user

        # Validate arguments against known Juju API types.
        if access_ is not None and not isinstance(access_, (bytes, str)):
            raise Exception(f"Expected access_ to be a str, received: {type(access_)}")

        if display_name_ is not None and not isinstance(display_name_, (bytes, str)):
            raise Exception(
                f"Expected display_name_ to be a str, received: {type(display_name_)}"
            )

        if user_ is not None and not isinstance(user_, (bytes, str)):
            raise Exception(f"Expected user_ to be a str, received: {type(user_)}")

        self.access = access_
        self.display_name = display_name_
        self.user = user_
        self.unknown_fields = unknown_fields


class OperationQueryArgs(Type):
    _toSchema = {
        "actions": "actions",
        "applications": "applications",
        "limit": "limit",
        "machines": "machines",
        "offset": "offset",
        "status": "status",
        "units": "units",
    }
    _toPy = {
        "actions": "actions",
        "applications": "applications",
        "limit": "limit",
        "machines": "machines",
        "offset": "offset",
        "status": "status",
        "units": "units",
    }

    def __init__(
        self,
        actions=None,
        applications=None,
        limit=None,
        machines=None,
        offset=None,
        status=None,
        units=None,
        **unknown_fields,
    ):
        """Actions : typing.Sequence[str]
        applications : typing.Sequence[str]
        limit : int
        machines : typing.Sequence[str]
        offset : int
        status : typing.Sequence[str]
        units : typing.Sequence[str]
        """
        actions_ = actions
        applications_ = applications
        limit_ = limit
        machines_ = machines
        offset_ = offset
        status_ = status
        units_ = units

        # Validate arguments against known Juju API types.
        if actions_ is not None and not isinstance(actions_, (bytes, str, list)):
            raise Exception(
                f"Expected actions_ to be a Sequence, received: {type(actions_)}"
            )

        if applications_ is not None and not isinstance(
            applications_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected applications_ to be a Sequence, received: {type(applications_)}"
            )

        if limit_ is not None and not isinstance(limit_, int):
            raise Exception(f"Expected limit_ to be a int, received: {type(limit_)}")

        if machines_ is not None and not isinstance(machines_, (bytes, str, list)):
            raise Exception(
                f"Expected machines_ to be a Sequence, received: {type(machines_)}"
            )

        if offset_ is not None and not isinstance(offset_, int):
            raise Exception(f"Expected offset_ to be a int, received: {type(offset_)}")

        if status_ is not None and not isinstance(status_, (bytes, str, list)):
            raise Exception(
                f"Expected status_ to be a Sequence, received: {type(status_)}"
            )

        if units_ is not None and not isinstance(units_, (bytes, str, list)):
            raise Exception(
                f"Expected units_ to be a Sequence, received: {type(units_)}"
            )

        self.actions = actions_
        self.applications = applications_
        self.limit = limit_
        self.machines = machines_
        self.offset = offset_
        self.status = status_
        self.units = units_
        self.unknown_fields = unknown_fields


class OperationResult(Type):
    _toSchema = {
        "actions": "actions",
        "completed": "completed",
        "enqueued": "enqueued",
        "error": "error",
        "fail": "fail",
        "operation": "operation",
        "started": "started",
        "status": "status",
        "summary": "summary",
    }
    _toPy = {
        "actions": "actions",
        "completed": "completed",
        "enqueued": "enqueued",
        "error": "error",
        "fail": "fail",
        "operation": "operation",
        "started": "started",
        "status": "status",
        "summary": "summary",
    }

    def __init__(
        self,
        actions=None,
        completed=None,
        enqueued=None,
        error=None,
        fail=None,
        operation=None,
        started=None,
        status=None,
        summary=None,
        **unknown_fields,
    ):
        """Actions : typing.Sequence[~ActionResult]
        completed : str
        enqueued : str
        error : Error
        fail : str
        operation : str
        started : str
        status : str
        summary : str
        """
        actions_ = [ActionResult.from_json(o) for o in actions or []]
        completed_ = completed
        enqueued_ = enqueued
        error_ = Error.from_json(error) if error else None
        fail_ = fail
        operation_ = operation
        started_ = started
        status_ = status
        summary_ = summary

        # Validate arguments against known Juju API types.
        if actions_ is not None and not isinstance(actions_, (bytes, str, list)):
            raise Exception(
                f"Expected actions_ to be a Sequence, received: {type(actions_)}"
            )

        if completed_ is not None and not isinstance(completed_, (bytes, str)):
            raise Exception(
                f"Expected completed_ to be a str, received: {type(completed_)}"
            )

        if enqueued_ is not None and not isinstance(enqueued_, (bytes, str)):
            raise Exception(
                f"Expected enqueued_ to be a str, received: {type(enqueued_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if fail_ is not None and not isinstance(fail_, (bytes, str)):
            raise Exception(f"Expected fail_ to be a str, received: {type(fail_)}")

        if operation_ is not None and not isinstance(operation_, (bytes, str)):
            raise Exception(
                f"Expected operation_ to be a str, received: {type(operation_)}"
            )

        if started_ is not None and not isinstance(started_, (bytes, str)):
            raise Exception(
                f"Expected started_ to be a str, received: {type(started_)}"
            )

        if status_ is not None and not isinstance(status_, (bytes, str)):
            raise Exception(f"Expected status_ to be a str, received: {type(status_)}")

        if summary_ is not None and not isinstance(summary_, (bytes, str)):
            raise Exception(
                f"Expected summary_ to be a str, received: {type(summary_)}"
            )

        self.actions = actions_
        self.completed = completed_
        self.enqueued = enqueued_
        self.error = error_
        self.fail = fail_
        self.operation = operation_
        self.started = started_
        self.status = status_
        self.summary = summary_
        self.unknown_fields = unknown_fields


class OperationResults(Type):
    _toSchema = {"results": "results", "truncated": "truncated"}
    _toPy = {"results": "results", "truncated": "truncated"}

    def __init__(self, results=None, truncated=None, **unknown_fields):
        """Results : typing.Sequence[~OperationResult]
        truncated : bool
        """
        results_ = [OperationResult.from_json(o) for o in results or []]
        truncated_ = truncated

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        if truncated_ is not None and not isinstance(truncated_, bool):
            raise Exception(
                f"Expected truncated_ to be a bool, received: {type(truncated_)}"
            )

        self.results = results_
        self.truncated = truncated_
        self.unknown_fields = unknown_fields


class Payload(Type):
    _toSchema = {
        "class_": "class",
        "id_": "id",
        "labels": "labels",
        "machine": "machine",
        "status": "status",
        "type_": "type",
        "unit": "unit",
    }
    _toPy = {
        "class": "class_",
        "id": "id_",
        "labels": "labels",
        "machine": "machine",
        "status": "status",
        "type": "type_",
        "unit": "unit",
    }

    def __init__(
        self,
        class_=None,
        id_=None,
        labels=None,
        machine=None,
        status=None,
        type_=None,
        unit=None,
        **unknown_fields,
    ):
        """class_ : str
        id_ : str
        labels : typing.Sequence[str]
        machine : str
        status : str
        type_ : str
        unit : str
        """
        class__ = class_
        id__ = id_
        labels_ = labels
        machine_ = machine
        status_ = status
        type__ = type_
        unit_ = unit

        # Validate arguments against known Juju API types.
        if class__ is not None and not isinstance(class__, (bytes, str)):
            raise Exception(f"Expected class__ to be a str, received: {type(class__)}")

        if id__ is not None and not isinstance(id__, (bytes, str)):
            raise Exception(f"Expected id__ to be a str, received: {type(id__)}")

        if labels_ is not None and not isinstance(labels_, (bytes, str, list)):
            raise Exception(
                f"Expected labels_ to be a Sequence, received: {type(labels_)}"
            )

        if machine_ is not None and not isinstance(machine_, (bytes, str)):
            raise Exception(
                f"Expected machine_ to be a str, received: {type(machine_)}"
            )

        if status_ is not None and not isinstance(status_, (bytes, str)):
            raise Exception(f"Expected status_ to be a str, received: {type(status_)}")

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        if unit_ is not None and not isinstance(unit_, (bytes, str)):
            raise Exception(f"Expected unit_ to be a str, received: {type(unit_)}")

        self.class_ = class__
        self.id_ = id__
        self.labels = labels_
        self.machine = machine_
        self.status = status_
        self.type_ = type__
        self.unit = unit_
        self.unknown_fields = unknown_fields


class PayloadListArgs(Type):
    _toSchema = {"patterns": "patterns"}
    _toPy = {"patterns": "patterns"}

    def __init__(self, patterns=None, **unknown_fields):
        """Patterns : typing.Sequence[str]"""
        patterns_ = patterns

        # Validate arguments against known Juju API types.
        if patterns_ is not None and not isinstance(patterns_, (bytes, str, list)):
            raise Exception(
                f"Expected patterns_ to be a Sequence, received: {type(patterns_)}"
            )

        self.patterns = patterns_
        self.unknown_fields = unknown_fields


class PayloadListResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~Payload]"""
        results_ = [Payload.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class PendingResourceUpload(Type):
    _toSchema = {"filename": "Filename", "name": "Name", "type_": "Type"}
    _toPy = {"Filename": "filename", "Name": "name", "Type": "type_"}

    def __init__(self, filename=None, name=None, type_=None, **unknown_fields):
        """Filename : str
        name : str
        type_ : str
        """
        filename_ = filename
        name_ = name
        type__ = type_

        # Validate arguments against known Juju API types.
        if filename_ is not None and not isinstance(filename_, (bytes, str)):
            raise Exception(
                f"Expected filename_ to be a str, received: {type(filename_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        self.filename = filename_
        self.name = name_
        self.type_ = type__
        self.unknown_fields = unknown_fields


class Placement(Type):
    _toSchema = {"directive": "directive", "scope": "scope"}
    _toPy = {"directive": "directive", "scope": "scope"}

    def __init__(self, directive=None, scope=None, **unknown_fields):
        """Directive : str
        scope : str
        """
        directive_ = directive
        scope_ = scope

        # Validate arguments against known Juju API types.
        if directive_ is not None and not isinstance(directive_, (bytes, str)):
            raise Exception(
                f"Expected directive_ to be a str, received: {type(directive_)}"
            )

        if scope_ is not None and not isinstance(scope_, (bytes, str)):
            raise Exception(f"Expected scope_ to be a str, received: {type(scope_)}")

        self.directive = directive_
        self.scope = scope_
        self.unknown_fields = unknown_fields


class ProvisioningScriptParams(Type):
    _toSchema = {
        "data_dir": "data-dir",
        "disable_package_commands": "disable-package-commands",
        "machine_id": "machine-id",
        "nonce": "nonce",
    }
    _toPy = {
        "data-dir": "data_dir",
        "disable-package-commands": "disable_package_commands",
        "machine-id": "machine_id",
        "nonce": "nonce",
    }

    def __init__(
        self,
        data_dir=None,
        disable_package_commands=None,
        machine_id=None,
        nonce=None,
        **unknown_fields,
    ):
        """data_dir : str
        disable_package_commands : bool
        machine_id : str
        nonce : str
        """
        data_dir_ = data_dir
        disable_package_commands_ = disable_package_commands
        machine_id_ = machine_id
        nonce_ = nonce

        # Validate arguments against known Juju API types.
        if data_dir_ is not None and not isinstance(data_dir_, (bytes, str)):
            raise Exception(
                f"Expected data_dir_ to be a str, received: {type(data_dir_)}"
            )

        if disable_package_commands_ is not None and not isinstance(
            disable_package_commands_, bool
        ):
            raise Exception(
                f"Expected disable_package_commands_ to be a bool, received: {type(disable_package_commands_)}"
            )

        if machine_id_ is not None and not isinstance(machine_id_, (bytes, str)):
            raise Exception(
                f"Expected machine_id_ to be a str, received: {type(machine_id_)}"
            )

        if nonce_ is not None and not isinstance(nonce_, (bytes, str)):
            raise Exception(f"Expected nonce_ to be a str, received: {type(nonce_)}")

        self.data_dir = data_dir_
        self.disable_package_commands = disable_package_commands_
        self.machine_id = machine_id_
        self.nonce = nonce_
        self.unknown_fields = unknown_fields


class ProvisioningScriptResult(Type):
    _toSchema = {"script": "script"}
    _toPy = {"script": "script"}

    def __init__(self, script=None, **unknown_fields):
        """Script : str"""
        script_ = script

        # Validate arguments against known Juju API types.
        if script_ is not None and not isinstance(script_, (bytes, str)):
            raise Exception(f"Expected script_ to be a str, received: {type(script_)}")

        self.script = script_
        self.unknown_fields = unknown_fields


class Proxy(Type):
    _toSchema = {"config": "config", "type_": "type"}
    _toPy = {"config": "config", "type": "type_"}

    def __init__(self, config=None, type_=None, **unknown_fields):
        """Config : typing.Mapping[str, typing.Any]
        type_ : str
        """
        config_ = config
        type__ = type_

        # Validate arguments against known Juju API types.
        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        self.config = config_
        self.type_ = type__
        self.unknown_fields = unknown_fields


class QueryApplicationOffersResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ApplicationOfferAdminDetails]"""
        results_ = [ApplicationOfferAdminDetails.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class QueryApplicationOffersResultsV5(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ApplicationOfferAdminDetailsV5]"""
        results_ = [ApplicationOfferAdminDetailsV5.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class RedirectInfoResult(Type):
    _toSchema = {"ca_cert": "ca-cert", "servers": "servers"}
    _toPy = {"ca-cert": "ca_cert", "servers": "servers"}

    def __init__(self, ca_cert=None, servers=None, **unknown_fields):
        """ca_cert : str
        servers : typing.Sequence[~HostPort]
        """
        ca_cert_ = ca_cert
        servers_ = [HostPort.from_json(o) for o in servers or []]

        # Validate arguments against known Juju API types.
        if ca_cert_ is not None and not isinstance(ca_cert_, (bytes, str)):
            raise Exception(
                f"Expected ca_cert_ to be a str, received: {type(ca_cert_)}"
            )

        if servers_ is not None and not isinstance(servers_, (bytes, str, list)):
            raise Exception(
                f"Expected servers_ to be a Sequence, received: {type(servers_)}"
            )

        self.ca_cert = ca_cert_
        self.servers = servers_
        self.unknown_fields = unknown_fields


class RegionDefaults(Type):
    _toSchema = {"region_name": "region-name", "value": "value"}
    _toPy = {"region-name": "region_name", "value": "value"}

    def __init__(self, region_name=None, value=None, **unknown_fields):
        """region_name : str
        value : Any
        """
        region_name_ = region_name
        value_ = value

        # Validate arguments against known Juju API types.
        if region_name_ is not None and not isinstance(region_name_, (bytes, str)):
            raise Exception(
                f"Expected region_name_ to be a str, received: {type(region_name_)}"
            )

        self.region_name = region_name_
        self.value = value_
        self.unknown_fields = unknown_fields


class RelationData(Type):
    _toSchema = {"inscope": "InScope", "unitdata": "UnitData"}
    _toPy = {"InScope": "inscope", "UnitData": "unitdata"}

    def __init__(self, inscope=None, unitdata=None, **unknown_fields):
        """Inscope : bool
        unitdata : typing.Mapping[str, typing.Any]
        """
        inscope_ = inscope
        unitdata_ = unitdata

        # Validate arguments against known Juju API types.
        if inscope_ is not None and not isinstance(inscope_, bool):
            raise Exception(
                f"Expected inscope_ to be a bool, received: {type(inscope_)}"
            )

        if unitdata_ is not None and not isinstance(unitdata_, dict):
            raise Exception(
                f"Expected unitdata_ to be a Mapping, received: {type(unitdata_)}"
            )

        self.inscope = inscope_
        self.unitdata = unitdata_
        self.unknown_fields = unknown_fields


class RelationStatus(Type):
    _toSchema = {
        "endpoints": "endpoints",
        "id_": "id",
        "interface": "interface",
        "key": "key",
        "scope": "scope",
        "status": "status",
    }
    _toPy = {
        "endpoints": "endpoints",
        "id": "id_",
        "interface": "interface",
        "key": "key",
        "scope": "scope",
        "status": "status",
    }

    def __init__(
        self,
        endpoints=None,
        id_=None,
        interface=None,
        key=None,
        scope=None,
        status=None,
        **unknown_fields,
    ):
        """Endpoints : typing.Sequence[~EndpointStatus]
        id_ : int
        interface : str
        key : str
        scope : str
        status : DetailedStatus
        """
        endpoints_ = [EndpointStatus.from_json(o) for o in endpoints or []]
        id__ = id_
        interface_ = interface
        key_ = key
        scope_ = scope
        status_ = DetailedStatus.from_json(status) if status else None

        # Validate arguments against known Juju API types.
        if endpoints_ is not None and not isinstance(endpoints_, (bytes, str, list)):
            raise Exception(
                f"Expected endpoints_ to be a Sequence, received: {type(endpoints_)}"
            )

        if id__ is not None and not isinstance(id__, int):
            raise Exception(f"Expected id__ to be a int, received: {type(id__)}")

        if interface_ is not None and not isinstance(interface_, (bytes, str)):
            raise Exception(
                f"Expected interface_ to be a str, received: {type(interface_)}"
            )

        if key_ is not None and not isinstance(key_, (bytes, str)):
            raise Exception(f"Expected key_ to be a str, received: {type(key_)}")

        if scope_ is not None and not isinstance(scope_, (bytes, str)):
            raise Exception(f"Expected scope_ to be a str, received: {type(scope_)}")

        if status_ is not None and not isinstance(status_, (dict, DetailedStatus)):
            raise Exception(
                f"Expected status_ to be a DetailedStatus, received: {type(status_)}"
            )

        self.endpoints = endpoints_
        self.id_ = id__
        self.interface = interface_
        self.key = key_
        self.scope = scope_
        self.status = status_
        self.unknown_fields = unknown_fields


class RelationSuspendedArg(Type):
    _toSchema = {
        "message": "message",
        "relation_id": "relation-id",
        "suspended": "suspended",
    }
    _toPy = {
        "message": "message",
        "relation-id": "relation_id",
        "suspended": "suspended",
    }

    def __init__(
        self, message=None, relation_id=None, suspended=None, **unknown_fields
    ):
        """Message : str
        relation_id : int
        suspended : bool
        """
        message_ = message
        relation_id_ = relation_id
        suspended_ = suspended

        # Validate arguments against known Juju API types.
        if message_ is not None and not isinstance(message_, (bytes, str)):
            raise Exception(
                f"Expected message_ to be a str, received: {type(message_)}"
            )

        if relation_id_ is not None and not isinstance(relation_id_, int):
            raise Exception(
                f"Expected relation_id_ to be a int, received: {type(relation_id_)}"
            )

        if suspended_ is not None and not isinstance(suspended_, bool):
            raise Exception(
                f"Expected suspended_ to be a bool, received: {type(suspended_)}"
            )

        self.message = message_
        self.relation_id = relation_id_
        self.suspended = suspended_
        self.unknown_fields = unknown_fields


class RelationSuspendedArgs(Type):
    _toSchema = {"args": "args"}
    _toPy = {"args": "args"}

    def __init__(self, args=None, **unknown_fields):
        """Args : typing.Sequence[~RelationSuspendedArg]"""
        args_ = [RelationSuspendedArg.from_json(o) for o in args or []]

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, (bytes, str, list)):
            raise Exception(f"Expected args_ to be a Sequence, received: {type(args_)}")

        self.args = args_
        self.unknown_fields = unknown_fields


class RemoteApplicationInfo(Type):
    _toSchema = {
        "description": "description",
        "endpoints": "endpoints",
        "icon_url_path": "icon-url-path",
        "model_tag": "model-tag",
        "name": "name",
        "offer_url": "offer-url",
        "source_model_label": "source-model-label",
    }
    _toPy = {
        "description": "description",
        "endpoints": "endpoints",
        "icon-url-path": "icon_url_path",
        "model-tag": "model_tag",
        "name": "name",
        "offer-url": "offer_url",
        "source-model-label": "source_model_label",
    }

    def __init__(
        self,
        description=None,
        endpoints=None,
        icon_url_path=None,
        model_tag=None,
        name=None,
        offer_url=None,
        source_model_label=None,
        **unknown_fields,
    ):
        """Description : str
        endpoints : typing.Sequence[~RemoteEndpoint]
        icon_url_path : str
        model_tag : str
        name : str
        offer_url : str
        source_model_label : str
        """
        description_ = description
        endpoints_ = [RemoteEndpoint.from_json(o) for o in endpoints or []]
        icon_url_path_ = icon_url_path
        model_tag_ = model_tag
        name_ = name
        offer_url_ = offer_url
        source_model_label_ = source_model_label

        # Validate arguments against known Juju API types.
        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if endpoints_ is not None and not isinstance(endpoints_, (bytes, str, list)):
            raise Exception(
                f"Expected endpoints_ to be a Sequence, received: {type(endpoints_)}"
            )

        if icon_url_path_ is not None and not isinstance(icon_url_path_, (bytes, str)):
            raise Exception(
                f"Expected icon_url_path_ to be a str, received: {type(icon_url_path_)}"
            )

        if model_tag_ is not None and not isinstance(model_tag_, (bytes, str)):
            raise Exception(
                f"Expected model_tag_ to be a str, received: {type(model_tag_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if offer_url_ is not None and not isinstance(offer_url_, (bytes, str)):
            raise Exception(
                f"Expected offer_url_ to be a str, received: {type(offer_url_)}"
            )

        if source_model_label_ is not None and not isinstance(
            source_model_label_, (bytes, str)
        ):
            raise Exception(
                f"Expected source_model_label_ to be a str, received: {type(source_model_label_)}"
            )

        self.description = description_
        self.endpoints = endpoints_
        self.icon_url_path = icon_url_path_
        self.model_tag = model_tag_
        self.name = name_
        self.offer_url = offer_url_
        self.source_model_label = source_model_label_
        self.unknown_fields = unknown_fields


class RemoteApplicationInfoResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : RemoteApplicationInfo
        """
        error_ = Error.from_json(error) if error else None
        result_ = RemoteApplicationInfo.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(
            result_, (dict, RemoteApplicationInfo)
        ):
            raise Exception(
                f"Expected result_ to be a RemoteApplicationInfo, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class RemoteApplicationInfoResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~RemoteApplicationInfoResult]"""
        results_ = [RemoteApplicationInfoResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class RemoteApplicationStatus(Type):
    _toSchema = {
        "endpoints": "endpoints",
        "err": "err",
        "life": "life",
        "offer_name": "offer-name",
        "offer_url": "offer-url",
        "relations": "relations",
        "status": "status",
    }
    _toPy = {
        "endpoints": "endpoints",
        "err": "err",
        "life": "life",
        "offer-name": "offer_name",
        "offer-url": "offer_url",
        "relations": "relations",
        "status": "status",
    }

    def __init__(
        self,
        endpoints=None,
        err=None,
        life=None,
        offer_name=None,
        offer_url=None,
        relations=None,
        status=None,
        **unknown_fields,
    ):
        """Endpoints : typing.Sequence[~RemoteEndpoint]
        err : Error
        life : str
        offer_name : str
        offer_url : str
        relations : typing.Mapping[str, typing.Sequence[str]]
        status : DetailedStatus
        """
        endpoints_ = [RemoteEndpoint.from_json(o) for o in endpoints or []]
        err_ = Error.from_json(err) if err else None
        life_ = life
        offer_name_ = offer_name
        offer_url_ = offer_url
        relations_ = relations
        status_ = DetailedStatus.from_json(status) if status else None

        # Validate arguments against known Juju API types.
        if endpoints_ is not None and not isinstance(endpoints_, (bytes, str, list)):
            raise Exception(
                f"Expected endpoints_ to be a Sequence, received: {type(endpoints_)}"
            )

        if err_ is not None and not isinstance(err_, (dict, Error)):
            raise Exception(f"Expected err_ to be a Error, received: {type(err_)}")

        if life_ is not None and not isinstance(life_, (bytes, str)):
            raise Exception(f"Expected life_ to be a str, received: {type(life_)}")

        if offer_name_ is not None and not isinstance(offer_name_, (bytes, str)):
            raise Exception(
                f"Expected offer_name_ to be a str, received: {type(offer_name_)}"
            )

        if offer_url_ is not None and not isinstance(offer_url_, (bytes, str)):
            raise Exception(
                f"Expected offer_url_ to be a str, received: {type(offer_url_)}"
            )

        if relations_ is not None and not isinstance(relations_, dict):
            raise Exception(
                f"Expected relations_ to be a Mapping, received: {type(relations_)}"
            )

        if status_ is not None and not isinstance(status_, (dict, DetailedStatus)):
            raise Exception(
                f"Expected status_ to be a DetailedStatus, received: {type(status_)}"
            )

        self.endpoints = endpoints_
        self.err = err_
        self.life = life_
        self.offer_name = offer_name_
        self.offer_url = offer_url_
        self.relations = relations_
        self.status = status_
        self.unknown_fields = unknown_fields


class RemoteEndpoint(Type):
    _toSchema = {
        "interface": "interface",
        "limit": "limit",
        "name": "name",
        "role": "role",
    }
    _toPy = {"interface": "interface", "limit": "limit", "name": "name", "role": "role"}

    def __init__(
        self, interface=None, limit=None, name=None, role=None, **unknown_fields
    ):
        """Interface : str
        limit : int
        name : str
        role : str
        """
        interface_ = interface
        limit_ = limit
        name_ = name
        role_ = role

        # Validate arguments against known Juju API types.
        if interface_ is not None and not isinstance(interface_, (bytes, str)):
            raise Exception(
                f"Expected interface_ to be a str, received: {type(interface_)}"
            )

        if limit_ is not None and not isinstance(limit_, int):
            raise Exception(f"Expected limit_ to be a int, received: {type(limit_)}")

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if role_ is not None and not isinstance(role_, (bytes, str)):
            raise Exception(f"Expected role_ to be a str, received: {type(role_)}")

        self.interface = interface_
        self.limit = limit_
        self.name = name_
        self.role = role_
        self.unknown_fields = unknown_fields


class RemoteSpace(Type):
    _toSchema = {
        "cloud_type": "cloud-type",
        "name": "name",
        "provider_attributes": "provider-attributes",
        "provider_id": "provider-id",
        "subnets": "subnets",
    }
    _toPy = {
        "cloud-type": "cloud_type",
        "name": "name",
        "provider-attributes": "provider_attributes",
        "provider-id": "provider_id",
        "subnets": "subnets",
    }

    def __init__(
        self,
        cloud_type=None,
        name=None,
        provider_attributes=None,
        provider_id=None,
        subnets=None,
        **unknown_fields,
    ):
        """cloud_type : str
        name : str
        provider_attributes : typing.Mapping[str, typing.Any]
        provider_id : str
        subnets : typing.Sequence[~Subnet]
        """
        cloud_type_ = cloud_type
        name_ = name
        provider_attributes_ = provider_attributes
        provider_id_ = provider_id
        subnets_ = [Subnet.from_json(o) for o in subnets or []]

        # Validate arguments against known Juju API types.
        if cloud_type_ is not None and not isinstance(cloud_type_, (bytes, str)):
            raise Exception(
                f"Expected cloud_type_ to be a str, received: {type(cloud_type_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if provider_attributes_ is not None and not isinstance(
            provider_attributes_, dict
        ):
            raise Exception(
                f"Expected provider_attributes_ to be a Mapping, received: {type(provider_attributes_)}"
            )

        if provider_id_ is not None and not isinstance(provider_id_, (bytes, str)):
            raise Exception(
                f"Expected provider_id_ to be a str, received: {type(provider_id_)}"
            )

        if subnets_ is not None and not isinstance(subnets_, (bytes, str, list)):
            raise Exception(
                f"Expected subnets_ to be a Sequence, received: {type(subnets_)}"
            )

        self.cloud_type = cloud_type_
        self.name = name_
        self.provider_attributes = provider_attributes_
        self.provider_id = provider_id_
        self.subnets = subnets_
        self.unknown_fields = unknown_fields


class RemoveBlocksArgs(Type):
    _toSchema = {"all_": "all"}
    _toPy = {"all": "all_"}

    def __init__(self, all_=None, **unknown_fields):
        """all_ : bool"""
        all__ = all_

        # Validate arguments against known Juju API types.
        if all__ is not None and not isinstance(all__, bool):
            raise Exception(f"Expected all__ to be a bool, received: {type(all__)}")

        self.all_ = all__
        self.unknown_fields = unknown_fields


class RemoveSecretBackendArg(Type):
    _toSchema = {"force": "force", "name": "name"}
    _toPy = {"force": "force", "name": "name"}

    def __init__(self, force=None, name=None, **unknown_fields):
        """Force : bool
        name : str
        """
        force_ = force
        name_ = name

        # Validate arguments against known Juju API types.
        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        self.force = force_
        self.name = name_
        self.unknown_fields = unknown_fields


class RemoveSecretBackendArgs(Type):
    _toSchema = {"args": "args"}
    _toPy = {"args": "args"}

    def __init__(self, args=None, **unknown_fields):
        """Args : typing.Sequence[~RemoveSecretBackendArg]"""
        args_ = [RemoveSecretBackendArg.from_json(o) for o in args or []]

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, (bytes, str, list)):
            raise Exception(f"Expected args_ to be a Sequence, received: {type(args_)}")

        self.args = args_
        self.unknown_fields = unknown_fields


class RemoveSpaceParam(Type):
    _toSchema = {"dry_run": "dry-run", "force": "force", "space": "space"}
    _toPy = {"dry-run": "dry_run", "force": "force", "space": "space"}

    def __init__(self, dry_run=None, force=None, space=None, **unknown_fields):
        """dry_run : bool
        force : bool
        space : Entity
        """
        dry_run_ = dry_run
        force_ = force
        space_ = Entity.from_json(space) if space else None

        # Validate arguments against known Juju API types.
        if dry_run_ is not None and not isinstance(dry_run_, bool):
            raise Exception(
                f"Expected dry_run_ to be a bool, received: {type(dry_run_)}"
            )

        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if space_ is not None and not isinstance(space_, (dict, Entity)):
            raise Exception(f"Expected space_ to be a Entity, received: {type(space_)}")

        self.dry_run = dry_run_
        self.force = force_
        self.space = space_
        self.unknown_fields = unknown_fields


class RemoveSpaceParams(Type):
    _toSchema = {"space_param": "space-param"}
    _toPy = {"space-param": "space_param"}

    def __init__(self, space_param=None, **unknown_fields):
        """space_param : typing.Sequence[~RemoveSpaceParam]"""
        space_param_ = [RemoveSpaceParam.from_json(o) for o in space_param or []]

        # Validate arguments against known Juju API types.
        if space_param_ is not None and not isinstance(
            space_param_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected space_param_ to be a Sequence, received: {type(space_param_)}"
            )

        self.space_param = space_param_
        self.unknown_fields = unknown_fields


class RemoveSpaceResult(Type):
    _toSchema = {
        "bindings": "bindings",
        "constraints": "constraints",
        "controller_settings": "controller-settings",
        "error": "error",
    }
    _toPy = {
        "bindings": "bindings",
        "constraints": "constraints",
        "controller-settings": "controller_settings",
        "error": "error",
    }

    def __init__(
        self,
        bindings=None,
        constraints=None,
        controller_settings=None,
        error=None,
        **unknown_fields,
    ):
        """Bindings : typing.Sequence[~Entity]
        constraints : typing.Sequence[~Entity]
        controller_settings : typing.Sequence[str]
        error : Error
        """
        bindings_ = [Entity.from_json(o) for o in bindings or []]
        constraints_ = [Entity.from_json(o) for o in constraints or []]
        controller_settings_ = controller_settings
        error_ = Error.from_json(error) if error else None

        # Validate arguments against known Juju API types.
        if bindings_ is not None and not isinstance(bindings_, (bytes, str, list)):
            raise Exception(
                f"Expected bindings_ to be a Sequence, received: {type(bindings_)}"
            )

        if constraints_ is not None and not isinstance(
            constraints_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected constraints_ to be a Sequence, received: {type(constraints_)}"
            )

        if controller_settings_ is not None and not isinstance(
            controller_settings_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected controller_settings_ to be a Sequence, received: {type(controller_settings_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        self.bindings = bindings_
        self.constraints = constraints_
        self.controller_settings = controller_settings_
        self.error = error_
        self.unknown_fields = unknown_fields


class RemoveSpaceResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~RemoveSpaceResult]"""
        results_ = [RemoveSpaceResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class RemoveStorage(Type):
    _toSchema = {"storage": "storage"}
    _toPy = {"storage": "storage"}

    def __init__(self, storage=None, **unknown_fields):
        """Storage : typing.Sequence[~RemoveStorageInstance]"""
        storage_ = [RemoveStorageInstance.from_json(o) for o in storage or []]

        # Validate arguments against known Juju API types.
        if storage_ is not None and not isinstance(storage_, (bytes, str, list)):
            raise Exception(
                f"Expected storage_ to be a Sequence, received: {type(storage_)}"
            )

        self.storage = storage_
        self.unknown_fields = unknown_fields


class RemoveStorageInstance(Type):
    _toSchema = {
        "destroy_attachments": "destroy-attachments",
        "destroy_storage": "destroy-storage",
        "force": "force",
        "max_wait": "max-wait",
        "tag": "tag",
    }
    _toPy = {
        "destroy-attachments": "destroy_attachments",
        "destroy-storage": "destroy_storage",
        "force": "force",
        "max-wait": "max_wait",
        "tag": "tag",
    }

    def __init__(
        self,
        destroy_attachments=None,
        destroy_storage=None,
        force=None,
        max_wait=None,
        tag=None,
        **unknown_fields,
    ):
        """destroy_attachments : bool
        destroy_storage : bool
        force : bool
        max_wait : int
        tag : str
        """
        destroy_attachments_ = destroy_attachments
        destroy_storage_ = destroy_storage
        force_ = force
        max_wait_ = max_wait
        tag_ = tag

        # Validate arguments against known Juju API types.
        if destroy_attachments_ is not None and not isinstance(
            destroy_attachments_, bool
        ):
            raise Exception(
                f"Expected destroy_attachments_ to be a bool, received: {type(destroy_attachments_)}"
            )

        if destroy_storage_ is not None and not isinstance(destroy_storage_, bool):
            raise Exception(
                f"Expected destroy_storage_ to be a bool, received: {type(destroy_storage_)}"
            )

        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if max_wait_ is not None and not isinstance(max_wait_, int):
            raise Exception(
                f"Expected max_wait_ to be a int, received: {type(max_wait_)}"
            )

        if tag_ is not None and not isinstance(tag_, (bytes, str)):
            raise Exception(f"Expected tag_ to be a str, received: {type(tag_)}")

        self.destroy_attachments = destroy_attachments_
        self.destroy_storage = destroy_storage_
        self.force = force_
        self.max_wait = max_wait_
        self.tag = tag_
        self.unknown_fields = unknown_fields


class RenameSpaceParams(Type):
    _toSchema = {"from_space_tag": "from-space-tag", "to_space_tag": "to-space-tag"}
    _toPy = {"from-space-tag": "from_space_tag", "to-space-tag": "to_space_tag"}

    def __init__(self, from_space_tag=None, to_space_tag=None, **unknown_fields):
        """from_space_tag : str
        to_space_tag : str
        """
        from_space_tag_ = from_space_tag
        to_space_tag_ = to_space_tag

        # Validate arguments against known Juju API types.
        if from_space_tag_ is not None and not isinstance(
            from_space_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected from_space_tag_ to be a str, received: {type(from_space_tag_)}"
            )

        if to_space_tag_ is not None and not isinstance(to_space_tag_, (bytes, str)):
            raise Exception(
                f"Expected to_space_tag_ to be a str, received: {type(to_space_tag_)}"
            )

        self.from_space_tag = from_space_tag_
        self.to_space_tag = to_space_tag_
        self.unknown_fields = unknown_fields


class RenameSpacesParams(Type):
    _toSchema = {"changes": "changes"}
    _toPy = {"changes": "changes"}

    def __init__(self, changes=None, **unknown_fields):
        """Changes : typing.Sequence[~RenameSpaceParams]"""
        changes_ = [RenameSpaceParams.from_json(o) for o in changes or []]

        # Validate arguments against known Juju API types.
        if changes_ is not None and not isinstance(changes_, (bytes, str, list)):
            raise Exception(
                f"Expected changes_ to be a Sequence, received: {type(changes_)}"
            )

        self.changes = changes_
        self.unknown_fields = unknown_fields


class ResolveCharmWithChannel(Type):
    _toSchema = {
        "charm_origin": "charm-origin",
        "reference": "reference",
        "switch_charm": "switch-charm",
    }
    _toPy = {
        "charm-origin": "charm_origin",
        "reference": "reference",
        "switch-charm": "switch_charm",
    }

    def __init__(
        self, charm_origin=None, reference=None, switch_charm=None, **unknown_fields
    ):
        """charm_origin : CharmOrigin
        reference : str
        switch_charm : bool
        """
        charm_origin_ = CharmOrigin.from_json(charm_origin) if charm_origin else None
        reference_ = reference
        switch_charm_ = switch_charm

        # Validate arguments against known Juju API types.
        if charm_origin_ is not None and not isinstance(
            charm_origin_, (dict, CharmOrigin)
        ):
            raise Exception(
                f"Expected charm_origin_ to be a CharmOrigin, received: {type(charm_origin_)}"
            )

        if reference_ is not None and not isinstance(reference_, (bytes, str)):
            raise Exception(
                f"Expected reference_ to be a str, received: {type(reference_)}"
            )

        if switch_charm_ is not None and not isinstance(switch_charm_, bool):
            raise Exception(
                f"Expected switch_charm_ to be a bool, received: {type(switch_charm_)}"
            )

        self.charm_origin = charm_origin_
        self.reference = reference_
        self.switch_charm = switch_charm_
        self.unknown_fields = unknown_fields


class ResolveCharmWithChannelResult(Type):
    _toSchema = {
        "charm_origin": "charm-origin",
        "error": "error",
        "supported_bases": "supported-bases",
        "url": "url",
    }
    _toPy = {
        "charm-origin": "charm_origin",
        "error": "error",
        "supported-bases": "supported_bases",
        "url": "url",
    }

    def __init__(
        self,
        charm_origin=None,
        error=None,
        supported_bases=None,
        url=None,
        **unknown_fields,
    ):
        """charm_origin : CharmOrigin
        error : Error
        supported_bases : typing.Sequence[~Base]
        url : str
        """
        charm_origin_ = CharmOrigin.from_json(charm_origin) if charm_origin else None
        error_ = Error.from_json(error) if error else None
        supported_bases_ = [Base.from_json(o) for o in supported_bases or []]
        url_ = url

        # Validate arguments against known Juju API types.
        if charm_origin_ is not None and not isinstance(
            charm_origin_, (dict, CharmOrigin)
        ):
            raise Exception(
                f"Expected charm_origin_ to be a CharmOrigin, received: {type(charm_origin_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if supported_bases_ is not None and not isinstance(
            supported_bases_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected supported_bases_ to be a Sequence, received: {type(supported_bases_)}"
            )

        if url_ is not None and not isinstance(url_, (bytes, str)):
            raise Exception(f"Expected url_ to be a str, received: {type(url_)}")

        self.charm_origin = charm_origin_
        self.error = error_
        self.supported_bases = supported_bases_
        self.url = url_
        self.unknown_fields = unknown_fields


class ResolveCharmWithChannelResults(Type):
    _toSchema = {"results": "Results"}
    _toPy = {"Results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ResolveCharmWithChannelResult]"""
        results_ = [ResolveCharmWithChannelResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ResolveCharmsWithChannel(Type):
    _toSchema = {"macaroon": "macaroon", "resolve": "resolve"}
    _toPy = {"macaroon": "macaroon", "resolve": "resolve"}

    def __init__(self, macaroon=None, resolve=None, **unknown_fields):
        """Macaroon : Macaroon
        resolve : typing.Sequence[~ResolveCharmWithChannel]
        """
        macaroon_ = Macaroon.from_json(macaroon) if macaroon else None
        resolve_ = [ResolveCharmWithChannel.from_json(o) for o in resolve or []]

        # Validate arguments against known Juju API types.
        if macaroon_ is not None and not isinstance(macaroon_, (dict, Macaroon)):
            raise Exception(
                f"Expected macaroon_ to be a Macaroon, received: {type(macaroon_)}"
            )

        if resolve_ is not None and not isinstance(resolve_, (bytes, str, list)):
            raise Exception(
                f"Expected resolve_ to be a Sequence, received: {type(resolve_)}"
            )

        self.macaroon = macaroon_
        self.resolve = resolve_
        self.unknown_fields = unknown_fields


class Resource(Type):
    _toSchema = {
        "application": "application",
        "charmresource": "CharmResource",
        "description": "description",
        "fingerprint": "fingerprint",
        "id_": "id",
        "name": "name",
        "origin": "origin",
        "path": "path",
        "pending_id": "pending-id",
        "revision": "revision",
        "size": "size",
        "timestamp": "timestamp",
        "type_": "type",
        "username": "username",
    }
    _toPy = {
        "CharmResource": "charmresource",
        "application": "application",
        "description": "description",
        "fingerprint": "fingerprint",
        "id": "id_",
        "name": "name",
        "origin": "origin",
        "path": "path",
        "pending-id": "pending_id",
        "revision": "revision",
        "size": "size",
        "timestamp": "timestamp",
        "type": "type_",
        "username": "username",
    }

    def __init__(
        self,
        charmresource=None,
        application=None,
        description=None,
        fingerprint=None,
        id_=None,
        name=None,
        origin=None,
        path=None,
        pending_id=None,
        revision=None,
        size=None,
        timestamp=None,
        type_=None,
        username=None,
        **unknown_fields,
    ):
        """Charmresource : CharmResource
        application : str
        description : str
        fingerprint : typing.Sequence[int]
        id_ : str
        name : str
        origin : str
        path : str
        pending_id : str
        revision : int
        size : int
        timestamp : str
        type_ : str
        username : str
        """
        charmresource_ = (
            CharmResource.from_json(charmresource) if charmresource else None
        )
        application_ = application
        description_ = description
        fingerprint_ = fingerprint
        id__ = id_
        name_ = name
        origin_ = origin
        path_ = path
        pending_id_ = pending_id
        revision_ = revision
        size_ = size
        timestamp_ = timestamp
        type__ = type_
        username_ = username

        # Validate arguments against known Juju API types.
        if charmresource_ is not None and not isinstance(
            charmresource_, (dict, CharmResource)
        ):
            raise Exception(
                f"Expected charmresource_ to be a CharmResource, received: {type(charmresource_)}"
            )

        if application_ is not None and not isinstance(application_, (bytes, str)):
            raise Exception(
                f"Expected application_ to be a str, received: {type(application_)}"
            )

        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if fingerprint_ is not None and not isinstance(
            fingerprint_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected fingerprint_ to be a Sequence, received: {type(fingerprint_)}"
            )

        if id__ is not None and not isinstance(id__, (bytes, str)):
            raise Exception(f"Expected id__ to be a str, received: {type(id__)}")

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if origin_ is not None and not isinstance(origin_, (bytes, str)):
            raise Exception(f"Expected origin_ to be a str, received: {type(origin_)}")

        if path_ is not None and not isinstance(path_, (bytes, str)):
            raise Exception(f"Expected path_ to be a str, received: {type(path_)}")

        if pending_id_ is not None and not isinstance(pending_id_, (bytes, str)):
            raise Exception(
                f"Expected pending_id_ to be a str, received: {type(pending_id_)}"
            )

        if revision_ is not None and not isinstance(revision_, int):
            raise Exception(
                f"Expected revision_ to be a int, received: {type(revision_)}"
            )

        if size_ is not None and not isinstance(size_, int):
            raise Exception(f"Expected size_ to be a int, received: {type(size_)}")

        if timestamp_ is not None and not isinstance(timestamp_, (bytes, str)):
            raise Exception(
                f"Expected timestamp_ to be a str, received: {type(timestamp_)}"
            )

        if type__ is not None and not isinstance(type__, (bytes, str)):
            raise Exception(f"Expected type__ to be a str, received: {type(type__)}")

        if username_ is not None and not isinstance(username_, (bytes, str)):
            raise Exception(
                f"Expected username_ to be a str, received: {type(username_)}"
            )

        self.charmresource = charmresource_
        self.application = application_
        self.description = description_
        self.fingerprint = fingerprint_
        self.id_ = id__
        self.name = name_
        self.origin = origin_
        self.path = path_
        self.pending_id = pending_id_
        self.revision = revision_
        self.size = size_
        self.timestamp = timestamp_
        self.type_ = type__
        self.username = username_
        self.unknown_fields = unknown_fields


class ResourcesResult(Type):
    _toSchema = {
        "charm_store_resources": "charm-store-resources",
        "error": "error",
        "errorresult": "ErrorResult",
        "resources": "resources",
        "unit_resources": "unit-resources",
    }
    _toPy = {
        "ErrorResult": "errorresult",
        "charm-store-resources": "charm_store_resources",
        "error": "error",
        "resources": "resources",
        "unit-resources": "unit_resources",
    }

    def __init__(
        self,
        errorresult=None,
        charm_store_resources=None,
        error=None,
        resources=None,
        unit_resources=None,
        **unknown_fields,
    ):
        """Errorresult : ErrorResult
        charm_store_resources : typing.Sequence[~CharmResource]
        error : Error
        resources : typing.Sequence[~Resource]
        unit_resources : typing.Sequence[~UnitResources]
        """
        errorresult_ = ErrorResult.from_json(errorresult) if errorresult else None
        charm_store_resources_ = [
            CharmResource.from_json(o) for o in charm_store_resources or []
        ]
        error_ = Error.from_json(error) if error else None
        resources_ = [Resource.from_json(o) for o in resources or []]
        unit_resources_ = [UnitResources.from_json(o) for o in unit_resources or []]

        # Validate arguments against known Juju API types.
        if errorresult_ is not None and not isinstance(
            errorresult_, (dict, ErrorResult)
        ):
            raise Exception(
                f"Expected errorresult_ to be a ErrorResult, received: {type(errorresult_)}"
            )

        if charm_store_resources_ is not None and not isinstance(
            charm_store_resources_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected charm_store_resources_ to be a Sequence, received: {type(charm_store_resources_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if resources_ is not None and not isinstance(resources_, (bytes, str, list)):
            raise Exception(
                f"Expected resources_ to be a Sequence, received: {type(resources_)}"
            )

        if unit_resources_ is not None and not isinstance(
            unit_resources_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected unit_resources_ to be a Sequence, received: {type(unit_resources_)}"
            )

        self.errorresult = errorresult_
        self.charm_store_resources = charm_store_resources_
        self.error = error_
        self.resources = resources_
        self.unit_resources = unit_resources_
        self.unknown_fields = unknown_fields


class ResourcesResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ResourcesResult]"""
        results_ = [ResourcesResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class RetryProvisioningArgs(Type):
    _toSchema = {"all_": "all", "machines": "machines"}
    _toPy = {"all": "all_", "machines": "machines"}

    def __init__(self, all_=None, machines=None, **unknown_fields):
        """all_ : bool
        machines : typing.Sequence[str]
        """
        all__ = all_
        machines_ = machines

        # Validate arguments against known Juju API types.
        if all__ is not None and not isinstance(all__, bool):
            raise Exception(f"Expected all__ to be a bool, received: {type(all__)}")

        if machines_ is not None and not isinstance(machines_, (bytes, str, list)):
            raise Exception(
                f"Expected machines_ to be a Sequence, received: {type(machines_)}"
            )

        self.all_ = all__
        self.machines = machines_
        self.unknown_fields = unknown_fields


class RevokeCredentialArg(Type):
    _toSchema = {"force": "force", "tag": "tag"}
    _toPy = {"force": "force", "tag": "tag"}

    def __init__(self, force=None, tag=None, **unknown_fields):
        """Force : bool
        tag : str
        """
        force_ = force
        tag_ = tag

        # Validate arguments against known Juju API types.
        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if tag_ is not None and not isinstance(tag_, (bytes, str)):
            raise Exception(f"Expected tag_ to be a str, received: {type(tag_)}")

        self.force = force_
        self.tag = tag_
        self.unknown_fields = unknown_fields


class RevokeCredentialArgs(Type):
    _toSchema = {"credentials": "credentials"}
    _toPy = {"credentials": "credentials"}

    def __init__(self, credentials=None, **unknown_fields):
        """Credentials : typing.Sequence[~RevokeCredentialArg]"""
        credentials_ = [RevokeCredentialArg.from_json(o) for o in credentials or []]

        # Validate arguments against known Juju API types.
        if credentials_ is not None and not isinstance(
            credentials_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected credentials_ to be a Sequence, received: {type(credentials_)}"
            )

        self.credentials = credentials_
        self.unknown_fields = unknown_fields


class RunParams(Type):
    _toSchema = {
        "applications": "applications",
        "commands": "commands",
        "execution_group": "execution-group",
        "machines": "machines",
        "parallel": "parallel",
        "timeout": "timeout",
        "units": "units",
        "workload_context": "workload-context",
    }
    _toPy = {
        "applications": "applications",
        "commands": "commands",
        "execution-group": "execution_group",
        "machines": "machines",
        "parallel": "parallel",
        "timeout": "timeout",
        "units": "units",
        "workload-context": "workload_context",
    }

    def __init__(
        self,
        applications=None,
        commands=None,
        execution_group=None,
        machines=None,
        parallel=None,
        timeout=None,
        units=None,
        workload_context=None,
        **unknown_fields,
    ):
        """Applications : typing.Sequence[str]
        commands : str
        execution_group : str
        machines : typing.Sequence[str]
        parallel : bool
        timeout : int
        units : typing.Sequence[str]
        workload_context : bool
        """
        applications_ = applications
        commands_ = commands
        execution_group_ = execution_group
        machines_ = machines
        parallel_ = parallel
        timeout_ = timeout
        units_ = units
        workload_context_ = workload_context

        # Validate arguments against known Juju API types.
        if applications_ is not None and not isinstance(
            applications_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected applications_ to be a Sequence, received: {type(applications_)}"
            )

        if commands_ is not None and not isinstance(commands_, (bytes, str)):
            raise Exception(
                f"Expected commands_ to be a str, received: {type(commands_)}"
            )

        if execution_group_ is not None and not isinstance(
            execution_group_, (bytes, str)
        ):
            raise Exception(
                f"Expected execution_group_ to be a str, received: {type(execution_group_)}"
            )

        if machines_ is not None and not isinstance(machines_, (bytes, str, list)):
            raise Exception(
                f"Expected machines_ to be a Sequence, received: {type(machines_)}"
            )

        if parallel_ is not None and not isinstance(parallel_, bool):
            raise Exception(
                f"Expected parallel_ to be a bool, received: {type(parallel_)}"
            )

        if timeout_ is not None and not isinstance(timeout_, int):
            raise Exception(
                f"Expected timeout_ to be a int, received: {type(timeout_)}"
            )

        if units_ is not None and not isinstance(units_, (bytes, str, list)):
            raise Exception(
                f"Expected units_ to be a Sequence, received: {type(units_)}"
            )

        if workload_context_ is not None and not isinstance(workload_context_, bool):
            raise Exception(
                f"Expected workload_context_ to be a bool, received: {type(workload_context_)}"
            )

        self.applications = applications_
        self.commands = commands_
        self.execution_group = execution_group_
        self.machines = machines_
        self.parallel = parallel_
        self.timeout = timeout_
        self.units = units_
        self.workload_context = workload_context_
        self.unknown_fields = unknown_fields


class SSHAddressResult(Type):
    _toSchema = {"address": "address", "error": "error"}
    _toPy = {"address": "address", "error": "error"}

    def __init__(self, address=None, error=None, **unknown_fields):
        """Address : str
        error : Error
        """
        address_ = address
        error_ = Error.from_json(error) if error else None

        # Validate arguments against known Juju API types.
        if address_ is not None and not isinstance(address_, (bytes, str)):
            raise Exception(
                f"Expected address_ to be a str, received: {type(address_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        self.address = address_
        self.error = error_
        self.unknown_fields = unknown_fields


class SSHAddressResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~SSHAddressResult]"""
        results_ = [SSHAddressResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class SSHAddressesResult(Type):
    _toSchema = {"addresses": "addresses", "error": "error"}
    _toPy = {"addresses": "addresses", "error": "error"}

    def __init__(self, addresses=None, error=None, **unknown_fields):
        """Addresses : typing.Sequence[str]
        error : Error
        """
        addresses_ = addresses
        error_ = Error.from_json(error) if error else None

        # Validate arguments against known Juju API types.
        if addresses_ is not None and not isinstance(addresses_, (bytes, str, list)):
            raise Exception(
                f"Expected addresses_ to be a Sequence, received: {type(addresses_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        self.addresses = addresses_
        self.error = error_
        self.unknown_fields = unknown_fields


class SSHAddressesResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~SSHAddressesResult]"""
        results_ = [SSHAddressesResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class SSHProxyResult(Type):
    _toSchema = {"use_proxy": "use-proxy"}
    _toPy = {"use-proxy": "use_proxy"}

    def __init__(self, use_proxy=None, **unknown_fields):
        """use_proxy : bool"""
        use_proxy_ = use_proxy

        # Validate arguments against known Juju API types.
        if use_proxy_ is not None and not isinstance(use_proxy_, bool):
            raise Exception(
                f"Expected use_proxy_ to be a bool, received: {type(use_proxy_)}"
            )

        self.use_proxy = use_proxy_
        self.unknown_fields = unknown_fields


class SSHPublicKeysResult(Type):
    _toSchema = {"error": "error", "public_keys": "public-keys"}
    _toPy = {"error": "error", "public-keys": "public_keys"}

    def __init__(self, error=None, public_keys=None, **unknown_fields):
        """Error : Error
        public_keys : typing.Sequence[str]
        """
        error_ = Error.from_json(error) if error else None
        public_keys_ = public_keys

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if public_keys_ is not None and not isinstance(
            public_keys_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected public_keys_ to be a Sequence, received: {type(public_keys_)}"
            )

        self.error = error_
        self.public_keys = public_keys_
        self.unknown_fields = unknown_fields


class SSHPublicKeysResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~SSHPublicKeysResult]"""
        results_ = [SSHPublicKeysResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ScaleApplicationInfo(Type):
    _toSchema = {"num_units": "num-units"}
    _toPy = {"num-units": "num_units"}

    def __init__(self, num_units=None, **unknown_fields):
        """num_units : int"""
        num_units_ = num_units

        # Validate arguments against known Juju API types.
        if num_units_ is not None and not isinstance(num_units_, int):
            raise Exception(
                f"Expected num_units_ to be a int, received: {type(num_units_)}"
            )

        self.num_units = num_units_
        self.unknown_fields = unknown_fields


class ScaleApplicationParams(Type):
    _toSchema = {
        "application_tag": "application-tag",
        "force": "force",
        "scale": "scale",
        "scale_change": "scale-change",
    }
    _toPy = {
        "application-tag": "application_tag",
        "force": "force",
        "scale": "scale",
        "scale-change": "scale_change",
    }

    def __init__(
        self,
        application_tag=None,
        force=None,
        scale=None,
        scale_change=None,
        **unknown_fields,
    ):
        """application_tag : str
        force : bool
        scale : int
        scale_change : int
        """
        application_tag_ = application_tag
        force_ = force
        scale_ = scale
        scale_change_ = scale_change

        # Validate arguments against known Juju API types.
        if application_tag_ is not None and not isinstance(
            application_tag_, (bytes, str)
        ):
            raise Exception(
                f"Expected application_tag_ to be a str, received: {type(application_tag_)}"
            )

        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if scale_ is not None and not isinstance(scale_, int):
            raise Exception(f"Expected scale_ to be a int, received: {type(scale_)}")

        if scale_change_ is not None and not isinstance(scale_change_, int):
            raise Exception(
                f"Expected scale_change_ to be a int, received: {type(scale_change_)}"
            )

        self.application_tag = application_tag_
        self.force = force_
        self.scale = scale_
        self.scale_change = scale_change_
        self.unknown_fields = unknown_fields


class ScaleApplicationResult(Type):
    _toSchema = {"error": "error", "info": "info"}
    _toPy = {"error": "error", "info": "info"}

    def __init__(self, error=None, info=None, **unknown_fields):
        """Error : Error
        info : ScaleApplicationInfo
        """
        error_ = Error.from_json(error) if error else None
        info_ = ScaleApplicationInfo.from_json(info) if info else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if info_ is not None and not isinstance(info_, (dict, ScaleApplicationInfo)):
            raise Exception(
                f"Expected info_ to be a ScaleApplicationInfo, received: {type(info_)}"
            )

        self.error = error_
        self.info = info_
        self.unknown_fields = unknown_fields


class ScaleApplicationResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ScaleApplicationResult]"""
        results_ = [ScaleApplicationResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class ScaleApplicationsParams(Type):
    _toSchema = {"applications": "applications"}
    _toPy = {"applications": "applications"}

    def __init__(self, applications=None, **unknown_fields):
        """Applications : typing.Sequence[~ScaleApplicationParams]"""
        applications_ = [
            ScaleApplicationParams.from_json(o) for o in applications or []
        ]

        # Validate arguments against known Juju API types.
        if applications_ is not None and not isinstance(
            applications_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected applications_ to be a Sequence, received: {type(applications_)}"
            )

        self.applications = applications_
        self.unknown_fields = unknown_fields


class SecretBackend(Type):
    _toSchema = {
        "backend_type": "backend-type",
        "config": "config",
        "name": "name",
        "token_rotate_interval": "token-rotate-interval",
    }
    _toPy = {
        "backend-type": "backend_type",
        "config": "config",
        "name": "name",
        "token-rotate-interval": "token_rotate_interval",
    }

    def __init__(
        self,
        backend_type=None,
        config=None,
        name=None,
        token_rotate_interval=None,
        **unknown_fields,
    ):
        """backend_type : str
        config : typing.Mapping[str, typing.Any]
        name : str
        token_rotate_interval : int
        """
        backend_type_ = backend_type
        config_ = config
        name_ = name
        token_rotate_interval_ = token_rotate_interval

        # Validate arguments against known Juju API types.
        if backend_type_ is not None and not isinstance(backend_type_, (bytes, str)):
            raise Exception(
                f"Expected backend_type_ to be a str, received: {type(backend_type_)}"
            )

        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if token_rotate_interval_ is not None and not isinstance(
            token_rotate_interval_, int
        ):
            raise Exception(
                f"Expected token_rotate_interval_ to be a int, received: {type(token_rotate_interval_)}"
            )

        self.backend_type = backend_type_
        self.config = config_
        self.name = name_
        self.token_rotate_interval = token_rotate_interval_
        self.unknown_fields = unknown_fields


class SecretBackendResult(Type):
    _toSchema = {
        "error": "error",
        "id_": "id",
        "message": "message",
        "num_secrets": "num-secrets",
        "result": "result",
        "status": "status",
    }
    _toPy = {
        "error": "error",
        "id": "id_",
        "message": "message",
        "num-secrets": "num_secrets",
        "result": "result",
        "status": "status",
    }

    def __init__(
        self,
        error=None,
        id_=None,
        message=None,
        num_secrets=None,
        result=None,
        status=None,
        **unknown_fields,
    ):
        """Error : Error
        id_ : str
        message : str
        num_secrets : int
        result : SecretBackend
        status : str
        """
        error_ = Error.from_json(error) if error else None
        id__ = id_
        message_ = message
        num_secrets_ = num_secrets
        result_ = SecretBackend.from_json(result) if result else None
        status_ = status

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if id__ is not None and not isinstance(id__, (bytes, str)):
            raise Exception(f"Expected id__ to be a str, received: {type(id__)}")

        if message_ is not None and not isinstance(message_, (bytes, str)):
            raise Exception(
                f"Expected message_ to be a str, received: {type(message_)}"
            )

        if num_secrets_ is not None and not isinstance(num_secrets_, int):
            raise Exception(
                f"Expected num_secrets_ to be a int, received: {type(num_secrets_)}"
            )

        if result_ is not None and not isinstance(result_, (dict, SecretBackend)):
            raise Exception(
                f"Expected result_ to be a SecretBackend, received: {type(result_)}"
            )

        if status_ is not None and not isinstance(status_, (bytes, str)):
            raise Exception(f"Expected status_ to be a str, received: {type(status_)}")

        self.error = error_
        self.id_ = id__
        self.message = message_
        self.num_secrets = num_secrets_
        self.result = result_
        self.status = status_
        self.unknown_fields = unknown_fields


class SecretContentParams(Type):
    _toSchema = {"checksum": "checksum", "data": "data", "value_ref": "value-ref"}
    _toPy = {"checksum": "checksum", "data": "data", "value-ref": "value_ref"}

    def __init__(self, checksum=None, data=None, value_ref=None, **unknown_fields):
        """Checksum : str
        data : typing.Mapping[str, str]
        value_ref : SecretValueRef
        """
        checksum_ = checksum
        data_ = data
        value_ref_ = SecretValueRef.from_json(value_ref) if value_ref else None

        # Validate arguments against known Juju API types.
        if checksum_ is not None and not isinstance(checksum_, (bytes, str)):
            raise Exception(
                f"Expected checksum_ to be a str, received: {type(checksum_)}"
            )

        if data_ is not None and not isinstance(data_, dict):
            raise Exception(f"Expected data_ to be a Mapping, received: {type(data_)}")

        if value_ref_ is not None and not isinstance(
            value_ref_, (dict, SecretValueRef)
        ):
            raise Exception(
                f"Expected value_ref_ to be a SecretValueRef, received: {type(value_ref_)}"
            )

        self.checksum = checksum_
        self.data = data_
        self.value_ref = value_ref_
        self.unknown_fields = unknown_fields


class SecretRevision(Type):
    _toSchema = {
        "backend_name": "backend-name",
        "create_time": "create-time",
        "expire_time": "expire-time",
        "revision": "revision",
        "update_time": "update-time",
        "value_ref": "value-ref",
    }
    _toPy = {
        "backend-name": "backend_name",
        "create-time": "create_time",
        "expire-time": "expire_time",
        "revision": "revision",
        "update-time": "update_time",
        "value-ref": "value_ref",
    }

    def __init__(
        self,
        backend_name=None,
        create_time=None,
        expire_time=None,
        revision=None,
        update_time=None,
        value_ref=None,
        **unknown_fields,
    ):
        """backend_name : str
        create_time : str
        expire_time : str
        revision : int
        update_time : str
        value_ref : SecretValueRef
        """
        backend_name_ = backend_name
        create_time_ = create_time
        expire_time_ = expire_time
        revision_ = revision
        update_time_ = update_time
        value_ref_ = SecretValueRef.from_json(value_ref) if value_ref else None

        # Validate arguments against known Juju API types.
        if backend_name_ is not None and not isinstance(backend_name_, (bytes, str)):
            raise Exception(
                f"Expected backend_name_ to be a str, received: {type(backend_name_)}"
            )

        if create_time_ is not None and not isinstance(create_time_, (bytes, str)):
            raise Exception(
                f"Expected create_time_ to be a str, received: {type(create_time_)}"
            )

        if expire_time_ is not None and not isinstance(expire_time_, (bytes, str)):
            raise Exception(
                f"Expected expire_time_ to be a str, received: {type(expire_time_)}"
            )

        if revision_ is not None and not isinstance(revision_, int):
            raise Exception(
                f"Expected revision_ to be a int, received: {type(revision_)}"
            )

        if update_time_ is not None and not isinstance(update_time_, (bytes, str)):
            raise Exception(
                f"Expected update_time_ to be a str, received: {type(update_time_)}"
            )

        if value_ref_ is not None and not isinstance(
            value_ref_, (dict, SecretValueRef)
        ):
            raise Exception(
                f"Expected value_ref_ to be a SecretValueRef, received: {type(value_ref_)}"
            )

        self.backend_name = backend_name_
        self.create_time = create_time_
        self.expire_time = expire_time_
        self.revision = revision_
        self.update_time = update_time_
        self.value_ref = value_ref_
        self.unknown_fields = unknown_fields


class SecretValueRef(Type):
    _toSchema = {"backend_id": "backend-id", "revision_id": "revision-id"}
    _toPy = {"backend-id": "backend_id", "revision-id": "revision_id"}

    def __init__(self, backend_id=None, revision_id=None, **unknown_fields):
        """backend_id : str
        revision_id : str
        """
        backend_id_ = backend_id
        revision_id_ = revision_id

        # Validate arguments against known Juju API types.
        if backend_id_ is not None and not isinstance(backend_id_, (bytes, str)):
            raise Exception(
                f"Expected backend_id_ to be a str, received: {type(backend_id_)}"
            )

        if revision_id_ is not None and not isinstance(revision_id_, (bytes, str)):
            raise Exception(
                f"Expected revision_id_ to be a str, received: {type(revision_id_)}"
            )

        self.backend_id = backend_id_
        self.revision_id = revision_id_
        self.unknown_fields = unknown_fields


class SecretValueResult(Type):
    _toSchema = {"data": "data", "error": "error"}
    _toPy = {"data": "data", "error": "error"}

    def __init__(self, data=None, error=None, **unknown_fields):
        """Data : typing.Mapping[str, str]
        error : Error
        """
        data_ = data
        error_ = Error.from_json(error) if error else None

        # Validate arguments against known Juju API types.
        if data_ is not None and not isinstance(data_, dict):
            raise Exception(f"Expected data_ to be a Mapping, received: {type(data_)}")

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        self.data = data_
        self.error = error_
        self.unknown_fields = unknown_fields


class SecretsFilter(Type):
    _toSchema = {
        "label": "label",
        "owner_tag": "owner-tag",
        "revision": "revision",
        "uri": "uri",
    }
    _toPy = {
        "label": "label",
        "owner-tag": "owner_tag",
        "revision": "revision",
        "uri": "uri",
    }

    def __init__(
        self, label=None, owner_tag=None, revision=None, uri=None, **unknown_fields
    ):
        """Label : str
        owner_tag : str
        revision : int
        uri : str
        """
        label_ = label
        owner_tag_ = owner_tag
        revision_ = revision
        uri_ = uri

        # Validate arguments against known Juju API types.
        if label_ is not None and not isinstance(label_, (bytes, str)):
            raise Exception(f"Expected label_ to be a str, received: {type(label_)}")

        if owner_tag_ is not None and not isinstance(owner_tag_, (bytes, str)):
            raise Exception(
                f"Expected owner_tag_ to be a str, received: {type(owner_tag_)}"
            )

        if revision_ is not None and not isinstance(revision_, int):
            raise Exception(
                f"Expected revision_ to be a int, received: {type(revision_)}"
            )

        if uri_ is not None and not isinstance(uri_, (bytes, str)):
            raise Exception(f"Expected uri_ to be a str, received: {type(uri_)}")

        self.label = label_
        self.owner_tag = owner_tag_
        self.revision = revision_
        self.uri = uri_
        self.unknown_fields = unknown_fields


class SetConstraints(Type):
    _toSchema = {"application": "application", "constraints": "constraints"}
    _toPy = {"application": "application", "constraints": "constraints"}

    def __init__(self, application=None, constraints=None, **unknown_fields):
        """Application : str
        constraints : Value
        """
        application_ = application
        constraints_ = Value.from_json(constraints) if constraints else None

        # Validate arguments against known Juju API types.
        if application_ is not None and not isinstance(application_, (bytes, str)):
            raise Exception(
                f"Expected application_ to be a str, received: {type(application_)}"
            )

        if constraints_ is not None and not isinstance(constraints_, (dict, Value)):
            raise Exception(
                f"Expected constraints_ to be a Value, received: {type(constraints_)}"
            )

        self.application = application_
        self.constraints = constraints_
        self.unknown_fields = unknown_fields


class SetModelDefaults(Type):
    _toSchema = {"config": "config"}
    _toPy = {"config": "config"}

    def __init__(self, config=None, **unknown_fields):
        """Config : typing.Sequence[~ModelDefaultValues]"""
        config_ = [ModelDefaultValues.from_json(o) for o in config or []]

        # Validate arguments against known Juju API types.
        if config_ is not None and not isinstance(config_, (bytes, str, list)):
            raise Exception(
                f"Expected config_ to be a Sequence, received: {type(config_)}"
            )

        self.config = config_
        self.unknown_fields = unknown_fields


class ShowSpaceResult(Type):
    _toSchema = {
        "applications": "applications",
        "error": "error",
        "machine_count": "machine-count",
        "space": "space",
    }
    _toPy = {
        "applications": "applications",
        "error": "error",
        "machine-count": "machine_count",
        "space": "space",
    }

    def __init__(
        self,
        applications=None,
        error=None,
        machine_count=None,
        space=None,
        **unknown_fields,
    ):
        """Applications : typing.Sequence[str]
        error : Error
        machine_count : int
        space : Space
        """
        applications_ = applications
        error_ = Error.from_json(error) if error else None
        machine_count_ = machine_count
        space_ = Space.from_json(space) if space else None

        # Validate arguments against known Juju API types.
        if applications_ is not None and not isinstance(
            applications_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected applications_ to be a Sequence, received: {type(applications_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if machine_count_ is not None and not isinstance(machine_count_, int):
            raise Exception(
                f"Expected machine_count_ to be a int, received: {type(machine_count_)}"
            )

        if space_ is not None and not isinstance(space_, (dict, Space)):
            raise Exception(f"Expected space_ to be a Space, received: {type(space_)}")

        self.applications = applications_
        self.error = error_
        self.machine_count = machine_count_
        self.space = space_
        self.unknown_fields = unknown_fields


class ShowSpaceResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ShowSpaceResult]"""
        results_ = [ShowSpaceResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class Space(Type):
    _toSchema = {"error": "error", "id_": "id", "name": "name", "subnets": "subnets"}
    _toPy = {"error": "error", "id": "id_", "name": "name", "subnets": "subnets"}

    def __init__(self, error=None, id_=None, name=None, subnets=None, **unknown_fields):
        """Error : Error
        id_ : str
        name : str
        subnets : typing.Sequence[~Subnet]
        """
        error_ = Error.from_json(error) if error else None
        id__ = id_
        name_ = name
        subnets_ = [Subnet.from_json(o) for o in subnets or []]

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if id__ is not None and not isinstance(id__, (bytes, str)):
            raise Exception(f"Expected id__ to be a str, received: {type(id__)}")

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if subnets_ is not None and not isinstance(subnets_, (bytes, str, list)):
            raise Exception(
                f"Expected subnets_ to be a Sequence, received: {type(subnets_)}"
            )

        self.error = error_
        self.id_ = id__
        self.name = name_
        self.subnets = subnets_
        self.unknown_fields = unknown_fields


class StatusHistoryFilter(Type):
    _toSchema = {"date": "date", "delta": "delta", "exclude": "exclude", "size": "size"}
    _toPy = {"date": "date", "delta": "delta", "exclude": "exclude", "size": "size"}

    def __init__(
        self, date=None, delta=None, exclude=None, size=None, **unknown_fields
    ):
        """Date : str
        delta : int
        exclude : typing.Sequence[str]
        size : int
        """
        date_ = date
        delta_ = delta
        exclude_ = exclude
        size_ = size

        # Validate arguments against known Juju API types.
        if date_ is not None and not isinstance(date_, (bytes, str)):
            raise Exception(f"Expected date_ to be a str, received: {type(date_)}")

        if delta_ is not None and not isinstance(delta_, int):
            raise Exception(f"Expected delta_ to be a int, received: {type(delta_)}")

        if exclude_ is not None and not isinstance(exclude_, (bytes, str, list)):
            raise Exception(
                f"Expected exclude_ to be a Sequence, received: {type(exclude_)}"
            )

        if size_ is not None and not isinstance(size_, int):
            raise Exception(f"Expected size_ to be a int, received: {type(size_)}")

        self.date = date_
        self.delta = delta_
        self.exclude = exclude_
        self.size = size_
        self.unknown_fields = unknown_fields


class StatusHistoryRequest(Type):
    _toSchema = {
        "filter_": "filter",
        "historykind": "historyKind",
        "size": "size",
        "tag": "tag",
    }
    _toPy = {
        "filter": "filter_",
        "historyKind": "historykind",
        "size": "size",
        "tag": "tag",
    }

    def __init__(
        self, filter_=None, historykind=None, size=None, tag=None, **unknown_fields
    ):
        """filter_ : StatusHistoryFilter
        historykind : str
        size : int
        tag : str
        """
        filter__ = StatusHistoryFilter.from_json(filter_) if filter_ else None
        historykind_ = historykind
        size_ = size
        tag_ = tag

        # Validate arguments against known Juju API types.
        if filter__ is not None and not isinstance(
            filter__, (dict, StatusHistoryFilter)
        ):
            raise Exception(
                f"Expected filter__ to be a StatusHistoryFilter, received: {type(filter__)}"
            )

        if historykind_ is not None and not isinstance(historykind_, (bytes, str)):
            raise Exception(
                f"Expected historykind_ to be a str, received: {type(historykind_)}"
            )

        if size_ is not None and not isinstance(size_, int):
            raise Exception(f"Expected size_ to be a int, received: {type(size_)}")

        if tag_ is not None and not isinstance(tag_, (bytes, str)):
            raise Exception(f"Expected tag_ to be a str, received: {type(tag_)}")

        self.filter_ = filter__
        self.historykind = historykind_
        self.size = size_
        self.tag = tag_
        self.unknown_fields = unknown_fields


class StatusHistoryRequests(Type):
    _toSchema = {"requests": "requests"}
    _toPy = {"requests": "requests"}

    def __init__(self, requests=None, **unknown_fields):
        """Requests : typing.Sequence[~StatusHistoryRequest]"""
        requests_ = [StatusHistoryRequest.from_json(o) for o in requests or []]

        # Validate arguments against known Juju API types.
        if requests_ is not None and not isinstance(requests_, (bytes, str, list)):
            raise Exception(
                f"Expected requests_ to be a Sequence, received: {type(requests_)}"
            )

        self.requests = requests_
        self.unknown_fields = unknown_fields


class StatusHistoryResult(Type):
    _toSchema = {"error": "error", "history": "history"}
    _toPy = {"error": "error", "history": "history"}

    def __init__(self, error=None, history=None, **unknown_fields):
        """Error : Error
        history : History
        """
        error_ = Error.from_json(error) if error else None
        history_ = History.from_json(history) if history else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if history_ is not None and not isinstance(history_, (dict, History)):
            raise Exception(
                f"Expected history_ to be a History, received: {type(history_)}"
            )

        self.error = error_
        self.history = history_
        self.unknown_fields = unknown_fields


class StatusHistoryResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~StatusHistoryResult]"""
        results_ = [StatusHistoryResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class StatusParams(Type):
    _toSchema = {"include_storage": "include-storage", "patterns": "patterns"}
    _toPy = {"include-storage": "include_storage", "patterns": "patterns"}

    def __init__(self, include_storage=None, patterns=None, **unknown_fields):
        """include_storage : bool
        patterns : typing.Sequence[str]
        """
        include_storage_ = include_storage
        patterns_ = patterns

        # Validate arguments against known Juju API types.
        if include_storage_ is not None and not isinstance(include_storage_, bool):
            raise Exception(
                f"Expected include_storage_ to be a bool, received: {type(include_storage_)}"
            )

        if patterns_ is not None and not isinstance(patterns_, (bytes, str, list)):
            raise Exception(
                f"Expected patterns_ to be a Sequence, received: {type(patterns_)}"
            )

        self.include_storage = include_storage_
        self.patterns = patterns_
        self.unknown_fields = unknown_fields


class StorageAddParams(Type):
    _toSchema = {"name": "name", "storage": "storage", "unit": "unit"}
    _toPy = {"name": "name", "storage": "storage", "unit": "unit"}

    def __init__(self, name=None, storage=None, unit=None, **unknown_fields):
        """Name : str
        storage : StorageConstraints
        unit : str
        """
        name_ = name
        storage_ = StorageConstraints.from_json(storage) if storage else None
        unit_ = unit

        # Validate arguments against known Juju API types.
        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if storage_ is not None and not isinstance(
            storage_, (dict, StorageConstraints)
        ):
            raise Exception(
                f"Expected storage_ to be a StorageConstraints, received: {type(storage_)}"
            )

        if unit_ is not None and not isinstance(unit_, (bytes, str)):
            raise Exception(f"Expected unit_ to be a str, received: {type(unit_)}")

        self.name = name_
        self.storage = storage_
        self.unit = unit_
        self.unknown_fields = unknown_fields


class StorageAttachmentDetails(Type):
    _toSchema = {
        "life": "life",
        "location": "location",
        "machine_tag": "machine-tag",
        "storage_tag": "storage-tag",
        "unit_tag": "unit-tag",
    }
    _toPy = {
        "life": "life",
        "location": "location",
        "machine-tag": "machine_tag",
        "storage-tag": "storage_tag",
        "unit-tag": "unit_tag",
    }

    def __init__(
        self,
        life=None,
        location=None,
        machine_tag=None,
        storage_tag=None,
        unit_tag=None,
        **unknown_fields,
    ):
        """Life : str
        location : str
        machine_tag : str
        storage_tag : str
        unit_tag : str
        """
        life_ = life
        location_ = location
        machine_tag_ = machine_tag
        storage_tag_ = storage_tag
        unit_tag_ = unit_tag

        # Validate arguments against known Juju API types.
        if life_ is not None and not isinstance(life_, (bytes, str)):
            raise Exception(f"Expected life_ to be a str, received: {type(life_)}")

        if location_ is not None and not isinstance(location_, (bytes, str)):
            raise Exception(
                f"Expected location_ to be a str, received: {type(location_)}"
            )

        if machine_tag_ is not None and not isinstance(machine_tag_, (bytes, str)):
            raise Exception(
                f"Expected machine_tag_ to be a str, received: {type(machine_tag_)}"
            )

        if storage_tag_ is not None and not isinstance(storage_tag_, (bytes, str)):
            raise Exception(
                f"Expected storage_tag_ to be a str, received: {type(storage_tag_)}"
            )

        if unit_tag_ is not None and not isinstance(unit_tag_, (bytes, str)):
            raise Exception(
                f"Expected unit_tag_ to be a str, received: {type(unit_tag_)}"
            )

        self.life = life_
        self.location = location_
        self.machine_tag = machine_tag_
        self.storage_tag = storage_tag_
        self.unit_tag = unit_tag_
        self.unknown_fields = unknown_fields


class StorageAttachmentId(Type):
    _toSchema = {"storage_tag": "storage-tag", "unit_tag": "unit-tag"}
    _toPy = {"storage-tag": "storage_tag", "unit-tag": "unit_tag"}

    def __init__(self, storage_tag=None, unit_tag=None, **unknown_fields):
        """storage_tag : str
        unit_tag : str
        """
        storage_tag_ = storage_tag
        unit_tag_ = unit_tag

        # Validate arguments against known Juju API types.
        if storage_tag_ is not None and not isinstance(storage_tag_, (bytes, str)):
            raise Exception(
                f"Expected storage_tag_ to be a str, received: {type(storage_tag_)}"
            )

        if unit_tag_ is not None and not isinstance(unit_tag_, (bytes, str)):
            raise Exception(
                f"Expected unit_tag_ to be a str, received: {type(unit_tag_)}"
            )

        self.storage_tag = storage_tag_
        self.unit_tag = unit_tag_
        self.unknown_fields = unknown_fields


class StorageAttachmentIds(Type):
    _toSchema = {"ids": "ids"}
    _toPy = {"ids": "ids"}

    def __init__(self, ids=None, **unknown_fields):
        """Ids : typing.Sequence[~StorageAttachmentId]"""
        ids_ = [StorageAttachmentId.from_json(o) for o in ids or []]

        # Validate arguments against known Juju API types.
        if ids_ is not None and not isinstance(ids_, (bytes, str, list)):
            raise Exception(f"Expected ids_ to be a Sequence, received: {type(ids_)}")

        self.ids = ids_
        self.unknown_fields = unknown_fields


class StorageConstraints(Type):
    _toSchema = {"count": "count", "pool": "pool", "size": "size"}
    _toPy = {"count": "count", "pool": "pool", "size": "size"}

    def __init__(self, count=None, pool=None, size=None, **unknown_fields):
        """Count : int
        pool : str
        size : int
        """
        count_ = count
        pool_ = pool
        size_ = size

        # Validate arguments against known Juju API types.
        if count_ is not None and not isinstance(count_, int):
            raise Exception(f"Expected count_ to be a int, received: {type(count_)}")

        if pool_ is not None and not isinstance(pool_, (bytes, str)):
            raise Exception(f"Expected pool_ to be a str, received: {type(pool_)}")

        if size_ is not None and not isinstance(size_, int):
            raise Exception(f"Expected size_ to be a int, received: {type(size_)}")

        self.count = count_
        self.pool = pool_
        self.size = size_
        self.unknown_fields = unknown_fields


class StorageDetachmentParams(Type):
    _toSchema = {"force": "force", "ids": "ids", "max_wait": "max-wait"}
    _toPy = {"force": "force", "ids": "ids", "max-wait": "max_wait"}

    def __init__(self, force=None, ids=None, max_wait=None, **unknown_fields):
        """Force : bool
        ids : StorageAttachmentIds
        max_wait : int
        """
        force_ = force
        ids_ = StorageAttachmentIds.from_json(ids) if ids else None
        max_wait_ = max_wait

        # Validate arguments against known Juju API types.
        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if ids_ is not None and not isinstance(ids_, (dict, StorageAttachmentIds)):
            raise Exception(
                f"Expected ids_ to be a StorageAttachmentIds, received: {type(ids_)}"
            )

        if max_wait_ is not None and not isinstance(max_wait_, int):
            raise Exception(
                f"Expected max_wait_ to be a int, received: {type(max_wait_)}"
            )

        self.force = force_
        self.ids = ids_
        self.max_wait = max_wait_
        self.unknown_fields = unknown_fields


class StorageDetails(Type):
    _toSchema = {
        "attachments": "attachments",
        "kind": "kind",
        "life": "life",
        "owner_tag": "owner-tag",
        "persistent": "persistent",
        "status": "status",
        "storage_tag": "storage-tag",
    }
    _toPy = {
        "attachments": "attachments",
        "kind": "kind",
        "life": "life",
        "owner-tag": "owner_tag",
        "persistent": "persistent",
        "status": "status",
        "storage-tag": "storage_tag",
    }

    def __init__(
        self,
        attachments=None,
        kind=None,
        life=None,
        owner_tag=None,
        persistent=None,
        status=None,
        storage_tag=None,
        **unknown_fields,
    ):
        """Attachments : typing.Mapping[str, ~StorageAttachmentDetails]
        kind : int
        life : str
        owner_tag : str
        persistent : bool
        status : EntityStatus
        storage_tag : str
        """
        attachments_ = {
            k: StorageAttachmentDetails.from_json(v)
            for k, v in (attachments or dict()).items()
        }
        kind_ = kind
        life_ = life
        owner_tag_ = owner_tag
        persistent_ = persistent
        status_ = EntityStatus.from_json(status) if status else None
        storage_tag_ = storage_tag

        # Validate arguments against known Juju API types.
        if attachments_ is not None and not isinstance(attachments_, dict):
            raise Exception(
                f"Expected attachments_ to be a Mapping, received: {type(attachments_)}"
            )

        if kind_ is not None and not isinstance(kind_, int):
            raise Exception(f"Expected kind_ to be a int, received: {type(kind_)}")

        if life_ is not None and not isinstance(life_, (bytes, str)):
            raise Exception(f"Expected life_ to be a str, received: {type(life_)}")

        if owner_tag_ is not None and not isinstance(owner_tag_, (bytes, str)):
            raise Exception(
                f"Expected owner_tag_ to be a str, received: {type(owner_tag_)}"
            )

        if persistent_ is not None and not isinstance(persistent_, bool):
            raise Exception(
                f"Expected persistent_ to be a bool, received: {type(persistent_)}"
            )

        if status_ is not None and not isinstance(status_, (dict, EntityStatus)):
            raise Exception(
                f"Expected status_ to be a EntityStatus, received: {type(status_)}"
            )

        if storage_tag_ is not None and not isinstance(storage_tag_, (bytes, str)):
            raise Exception(
                f"Expected storage_tag_ to be a str, received: {type(storage_tag_)}"
            )

        self.attachments = attachments_
        self.kind = kind_
        self.life = life_
        self.owner_tag = owner_tag_
        self.persistent = persistent_
        self.status = status_
        self.storage_tag = storage_tag_
        self.unknown_fields = unknown_fields


class StorageDetailsListResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : typing.Sequence[~StorageDetails]
        """
        error_ = Error.from_json(error) if error else None
        result_ = [StorageDetails.from_json(o) for o in result or []]

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (bytes, str, list)):
            raise Exception(
                f"Expected result_ to be a Sequence, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class StorageDetailsListResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~StorageDetailsListResult]"""
        results_ = [StorageDetailsListResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class StorageDetailsResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : StorageDetails
        """
        error_ = Error.from_json(error) if error else None
        result_ = StorageDetails.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (dict, StorageDetails)):
            raise Exception(
                f"Expected result_ to be a StorageDetails, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class StorageDetailsResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~StorageDetailsResult]"""
        results_ = [StorageDetailsResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class StorageFilter(Type):
    _toSchema = {}
    _toPy = {}

    def __init__(self, **unknown_fields):
        """ """
        self.unknown_fields = unknown_fields


class StorageFilters(Type):
    _toSchema = {"filters": "filters"}
    _toPy = {"filters": "filters"}

    def __init__(self, filters=None, **unknown_fields):
        """Filters : typing.Sequence[~StorageFilter]"""
        filters_ = [StorageFilter.from_json(o) for o in filters or []]

        # Validate arguments against known Juju API types.
        if filters_ is not None and not isinstance(filters_, (bytes, str, list)):
            raise Exception(
                f"Expected filters_ to be a Sequence, received: {type(filters_)}"
            )

        self.filters = filters_
        self.unknown_fields = unknown_fields


class StoragePool(Type):
    _toSchema = {"attrs": "attrs", "name": "name", "provider": "provider"}
    _toPy = {"attrs": "attrs", "name": "name", "provider": "provider"}

    def __init__(self, attrs=None, name=None, provider=None, **unknown_fields):
        """Attrs : typing.Mapping[str, typing.Any]
        name : str
        provider : str
        """
        attrs_ = attrs
        name_ = name
        provider_ = provider

        # Validate arguments against known Juju API types.
        if attrs_ is not None and not isinstance(attrs_, dict):
            raise Exception(
                f"Expected attrs_ to be a Mapping, received: {type(attrs_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if provider_ is not None and not isinstance(provider_, (bytes, str)):
            raise Exception(
                f"Expected provider_ to be a str, received: {type(provider_)}"
            )

        self.attrs = attrs_
        self.name = name_
        self.provider = provider_
        self.unknown_fields = unknown_fields


class StoragePoolArgs(Type):
    _toSchema = {"pools": "pools"}
    _toPy = {"pools": "pools"}

    def __init__(self, pools=None, **unknown_fields):
        """Pools : typing.Sequence[~StoragePool]"""
        pools_ = [StoragePool.from_json(o) for o in pools or []]

        # Validate arguments against known Juju API types.
        if pools_ is not None and not isinstance(pools_, (bytes, str, list)):
            raise Exception(
                f"Expected pools_ to be a Sequence, received: {type(pools_)}"
            )

        self.pools = pools_
        self.unknown_fields = unknown_fields


class StoragePoolDeleteArg(Type):
    _toSchema = {"name": "name"}
    _toPy = {"name": "name"}

    def __init__(self, name=None, **unknown_fields):
        """Name : str"""
        name_ = name

        # Validate arguments against known Juju API types.
        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        self.name = name_
        self.unknown_fields = unknown_fields


class StoragePoolDeleteArgs(Type):
    _toSchema = {"pools": "pools"}
    _toPy = {"pools": "pools"}

    def __init__(self, pools=None, **unknown_fields):
        """Pools : typing.Sequence[~StoragePoolDeleteArg]"""
        pools_ = [StoragePoolDeleteArg.from_json(o) for o in pools or []]

        # Validate arguments against known Juju API types.
        if pools_ is not None and not isinstance(pools_, (bytes, str, list)):
            raise Exception(
                f"Expected pools_ to be a Sequence, received: {type(pools_)}"
            )

        self.pools = pools_
        self.unknown_fields = unknown_fields


class StoragePoolFilter(Type):
    _toSchema = {"names": "names", "providers": "providers"}
    _toPy = {"names": "names", "providers": "providers"}

    def __init__(self, names=None, providers=None, **unknown_fields):
        """Names : typing.Sequence[str]
        providers : typing.Sequence[str]
        """
        names_ = names
        providers_ = providers

        # Validate arguments against known Juju API types.
        if names_ is not None and not isinstance(names_, (bytes, str, list)):
            raise Exception(
                f"Expected names_ to be a Sequence, received: {type(names_)}"
            )

        if providers_ is not None and not isinstance(providers_, (bytes, str, list)):
            raise Exception(
                f"Expected providers_ to be a Sequence, received: {type(providers_)}"
            )

        self.names = names_
        self.providers = providers_
        self.unknown_fields = unknown_fields


class StoragePoolFilters(Type):
    _toSchema = {"filters": "filters"}
    _toPy = {"filters": "filters"}

    def __init__(self, filters=None, **unknown_fields):
        """Filters : typing.Sequence[~StoragePoolFilter]"""
        filters_ = [StoragePoolFilter.from_json(o) for o in filters or []]

        # Validate arguments against known Juju API types.
        if filters_ is not None and not isinstance(filters_, (bytes, str, list)):
            raise Exception(
                f"Expected filters_ to be a Sequence, received: {type(filters_)}"
            )

        self.filters = filters_
        self.unknown_fields = unknown_fields


class StoragePoolsResult(Type):
    _toSchema = {"error": "error", "storage_pools": "storage-pools"}
    _toPy = {"error": "error", "storage-pools": "storage_pools"}

    def __init__(self, error=None, storage_pools=None, **unknown_fields):
        """Error : Error
        storage_pools : typing.Sequence[~StoragePool]
        """
        error_ = Error.from_json(error) if error else None
        storage_pools_ = [StoragePool.from_json(o) for o in storage_pools or []]

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if storage_pools_ is not None and not isinstance(
            storage_pools_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected storage_pools_ to be a Sequence, received: {type(storage_pools_)}"
            )

        self.error = error_
        self.storage_pools = storage_pools_
        self.unknown_fields = unknown_fields


class StoragePoolsResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~StoragePoolsResult]"""
        results_ = [StoragePoolsResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class StoragesAddParams(Type):
    _toSchema = {"storages": "storages"}
    _toPy = {"storages": "storages"}

    def __init__(self, storages=None, **unknown_fields):
        """Storages : typing.Sequence[~StorageAddParams]"""
        storages_ = [StorageAddParams.from_json(o) for o in storages or []]

        # Validate arguments against known Juju API types.
        if storages_ is not None and not isinstance(storages_, (bytes, str, list)):
            raise Exception(
                f"Expected storages_ to be a Sequence, received: {type(storages_)}"
            )

        self.storages = storages_
        self.unknown_fields = unknown_fields


class StringResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : str
        """
        error_ = Error.from_json(error) if error else None
        result_ = result

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (bytes, str)):
            raise Exception(f"Expected result_ to be a str, received: {type(result_)}")

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class StringResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~StringResult]"""
        results_ = [StringResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class StringsResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : typing.Sequence[str]
        """
        error_ = Error.from_json(error) if error else None
        result_ = result

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (bytes, str, list)):
            raise Exception(
                f"Expected result_ to be a Sequence, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class StringsResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~StringsResult]"""
        results_ = [StringsResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class StringsWatchResult(Type):
    _toSchema = {"changes": "changes", "error": "error", "watcher_id": "watcher-id"}
    _toPy = {"changes": "changes", "error": "error", "watcher-id": "watcher_id"}

    def __init__(self, changes=None, error=None, watcher_id=None, **unknown_fields):
        """Changes : typing.Sequence[str]
        error : Error
        watcher_id : str
        """
        changes_ = changes
        error_ = Error.from_json(error) if error else None
        watcher_id_ = watcher_id

        # Validate arguments against known Juju API types.
        if changes_ is not None and not isinstance(changes_, (bytes, str, list)):
            raise Exception(
                f"Expected changes_ to be a Sequence, received: {type(changes_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if watcher_id_ is not None and not isinstance(watcher_id_, (bytes, str)):
            raise Exception(
                f"Expected watcher_id_ to be a str, received: {type(watcher_id_)}"
            )

        self.changes = changes_
        self.error = error_
        self.watcher_id = watcher_id_
        self.unknown_fields = unknown_fields


class StringsWatchResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~StringsWatchResult]"""
        results_ = [StringsWatchResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class Subnet(Type):
    _toSchema = {
        "cidr": "cidr",
        "life": "life",
        "provider_id": "provider-id",
        "provider_network_id": "provider-network-id",
        "provider_space_id": "provider-space-id",
        "space_tag": "space-tag",
        "status": "status",
        "vlan_tag": "vlan-tag",
        "zones": "zones",
    }
    _toPy = {
        "cidr": "cidr",
        "life": "life",
        "provider-id": "provider_id",
        "provider-network-id": "provider_network_id",
        "provider-space-id": "provider_space_id",
        "space-tag": "space_tag",
        "status": "status",
        "vlan-tag": "vlan_tag",
        "zones": "zones",
    }

    def __init__(
        self,
        cidr=None,
        life=None,
        provider_id=None,
        provider_network_id=None,
        provider_space_id=None,
        space_tag=None,
        status=None,
        vlan_tag=None,
        zones=None,
        **unknown_fields,
    ):
        """Cidr : str
        life : str
        provider_id : str
        provider_network_id : str
        provider_space_id : str
        space_tag : str
        status : str
        vlan_tag : int
        zones : typing.Sequence[str]
        """
        cidr_ = cidr
        life_ = life
        provider_id_ = provider_id
        provider_network_id_ = provider_network_id
        provider_space_id_ = provider_space_id
        space_tag_ = space_tag
        status_ = status
        vlan_tag_ = vlan_tag
        zones_ = zones

        # Validate arguments against known Juju API types.
        if cidr_ is not None and not isinstance(cidr_, (bytes, str)):
            raise Exception(f"Expected cidr_ to be a str, received: {type(cidr_)}")

        if life_ is not None and not isinstance(life_, (bytes, str)):
            raise Exception(f"Expected life_ to be a str, received: {type(life_)}")

        if provider_id_ is not None and not isinstance(provider_id_, (bytes, str)):
            raise Exception(
                f"Expected provider_id_ to be a str, received: {type(provider_id_)}"
            )

        if provider_network_id_ is not None and not isinstance(
            provider_network_id_, (bytes, str)
        ):
            raise Exception(
                f"Expected provider_network_id_ to be a str, received: {type(provider_network_id_)}"
            )

        if provider_space_id_ is not None and not isinstance(
            provider_space_id_, (bytes, str)
        ):
            raise Exception(
                f"Expected provider_space_id_ to be a str, received: {type(provider_space_id_)}"
            )

        if space_tag_ is not None and not isinstance(space_tag_, (bytes, str)):
            raise Exception(
                f"Expected space_tag_ to be a str, received: {type(space_tag_)}"
            )

        if status_ is not None and not isinstance(status_, (bytes, str)):
            raise Exception(f"Expected status_ to be a str, received: {type(status_)}")

        if vlan_tag_ is not None and not isinstance(vlan_tag_, int):
            raise Exception(
                f"Expected vlan_tag_ to be a int, received: {type(vlan_tag_)}"
            )

        if zones_ is not None and not isinstance(zones_, (bytes, str, list)):
            raise Exception(
                f"Expected zones_ to be a Sequence, received: {type(zones_)}"
            )

        self.cidr = cidr_
        self.life = life_
        self.provider_id = provider_id_
        self.provider_network_id = provider_network_id_
        self.provider_space_id = provider_space_id_
        self.space_tag = space_tag_
        self.status = status_
        self.vlan_tag = vlan_tag_
        self.zones = zones_
        self.unknown_fields = unknown_fields


class SubnetV2(Type):
    _toSchema = {
        "cidr": "cidr",
        "id_": "id",
        "life": "life",
        "provider_id": "provider-id",
        "provider_network_id": "provider-network-id",
        "provider_space_id": "provider-space-id",
        "space_tag": "space-tag",
        "status": "status",
        "subnet": "Subnet",
        "vlan_tag": "vlan-tag",
        "zones": "zones",
    }
    _toPy = {
        "Subnet": "subnet",
        "cidr": "cidr",
        "id": "id_",
        "life": "life",
        "provider-id": "provider_id",
        "provider-network-id": "provider_network_id",
        "provider-space-id": "provider_space_id",
        "space-tag": "space_tag",
        "status": "status",
        "vlan-tag": "vlan_tag",
        "zones": "zones",
    }

    def __init__(
        self,
        subnet=None,
        cidr=None,
        id_=None,
        life=None,
        provider_id=None,
        provider_network_id=None,
        provider_space_id=None,
        space_tag=None,
        status=None,
        vlan_tag=None,
        zones=None,
        **unknown_fields,
    ):
        """Subnet : Subnet
        cidr : str
        id_ : str
        life : str
        provider_id : str
        provider_network_id : str
        provider_space_id : str
        space_tag : str
        status : str
        vlan_tag : int
        zones : typing.Sequence[str]
        """
        subnet_ = Subnet.from_json(subnet) if subnet else None
        cidr_ = cidr
        id__ = id_
        life_ = life
        provider_id_ = provider_id
        provider_network_id_ = provider_network_id
        provider_space_id_ = provider_space_id
        space_tag_ = space_tag
        status_ = status
        vlan_tag_ = vlan_tag
        zones_ = zones

        # Validate arguments against known Juju API types.
        if subnet_ is not None and not isinstance(subnet_, (dict, Subnet)):
            raise Exception(
                f"Expected subnet_ to be a Subnet, received: {type(subnet_)}"
            )

        if cidr_ is not None and not isinstance(cidr_, (bytes, str)):
            raise Exception(f"Expected cidr_ to be a str, received: {type(cidr_)}")

        if id__ is not None and not isinstance(id__, (bytes, str)):
            raise Exception(f"Expected id__ to be a str, received: {type(id__)}")

        if life_ is not None and not isinstance(life_, (bytes, str)):
            raise Exception(f"Expected life_ to be a str, received: {type(life_)}")

        if provider_id_ is not None and not isinstance(provider_id_, (bytes, str)):
            raise Exception(
                f"Expected provider_id_ to be a str, received: {type(provider_id_)}"
            )

        if provider_network_id_ is not None and not isinstance(
            provider_network_id_, (bytes, str)
        ):
            raise Exception(
                f"Expected provider_network_id_ to be a str, received: {type(provider_network_id_)}"
            )

        if provider_space_id_ is not None and not isinstance(
            provider_space_id_, (bytes, str)
        ):
            raise Exception(
                f"Expected provider_space_id_ to be a str, received: {type(provider_space_id_)}"
            )

        if space_tag_ is not None and not isinstance(space_tag_, (bytes, str)):
            raise Exception(
                f"Expected space_tag_ to be a str, received: {type(space_tag_)}"
            )

        if status_ is not None and not isinstance(status_, (bytes, str)):
            raise Exception(f"Expected status_ to be a str, received: {type(status_)}")

        if vlan_tag_ is not None and not isinstance(vlan_tag_, int):
            raise Exception(
                f"Expected vlan_tag_ to be a int, received: {type(vlan_tag_)}"
            )

        if zones_ is not None and not isinstance(zones_, (bytes, str, list)):
            raise Exception(
                f"Expected zones_ to be a Sequence, received: {type(zones_)}"
            )

        self.subnet = subnet_
        self.cidr = cidr_
        self.id_ = id__
        self.life = life_
        self.provider_id = provider_id_
        self.provider_network_id = provider_network_id_
        self.provider_space_id = provider_space_id_
        self.space_tag = space_tag_
        self.status = status_
        self.vlan_tag = vlan_tag_
        self.zones = zones_
        self.unknown_fields = unknown_fields


class SubnetsFilters(Type):
    _toSchema = {"space_tag": "space-tag", "zone": "zone"}
    _toPy = {"space-tag": "space_tag", "zone": "zone"}

    def __init__(self, space_tag=None, zone=None, **unknown_fields):
        """space_tag : str
        zone : str
        """
        space_tag_ = space_tag
        zone_ = zone

        # Validate arguments against known Juju API types.
        if space_tag_ is not None and not isinstance(space_tag_, (bytes, str)):
            raise Exception(
                f"Expected space_tag_ to be a str, received: {type(space_tag_)}"
            )

        if zone_ is not None and not isinstance(zone_, (bytes, str)):
            raise Exception(f"Expected zone_ to be a str, received: {type(zone_)}")

        self.space_tag = space_tag_
        self.zone = zone_
        self.unknown_fields = unknown_fields


class SubnetsResult(Type):
    _toSchema = {"error": "error", "subnets": "subnets"}
    _toPy = {"error": "error", "subnets": "subnets"}

    def __init__(self, error=None, subnets=None, **unknown_fields):
        """Error : Error
        subnets : typing.Sequence[~SubnetV2]
        """
        error_ = Error.from_json(error) if error else None
        subnets_ = [SubnetV2.from_json(o) for o in subnets or []]

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if subnets_ is not None and not isinstance(subnets_, (bytes, str, list)):
            raise Exception(
                f"Expected subnets_ to be a Sequence, received: {type(subnets_)}"
            )

        self.error = error_
        self.subnets = subnets_
        self.unknown_fields = unknown_fields


class SubnetsResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~SubnetsResult]"""
        results_ = [SubnetsResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class SummaryWatcherID(Type):
    _toSchema = {"watcher_id": "watcher-id"}
    _toPy = {"watcher-id": "watcher_id"}

    def __init__(self, watcher_id=None, **unknown_fields):
        """watcher_id : str"""
        watcher_id_ = watcher_id

        # Validate arguments against known Juju API types.
        if watcher_id_ is not None and not isinstance(watcher_id_, (bytes, str)):
            raise Exception(
                f"Expected watcher_id_ to be a str, received: {type(watcher_id_)}"
            )

        self.watcher_id = watcher_id_
        self.unknown_fields = unknown_fields


class SupportedFeature(Type):
    _toSchema = {"description": "description", "name": "name", "version": "version"}
    _toPy = {"description": "description", "name": "name", "version": "version"}

    def __init__(self, description=None, name=None, version=None, **unknown_fields):
        """Description : str
        name : str
        version : str
        """
        description_ = description
        name_ = name
        version_ = version

        # Validate arguments against known Juju API types.
        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if version_ is not None and not isinstance(version_, (bytes, str)):
            raise Exception(
                f"Expected version_ to be a str, received: {type(version_)}"
            )

        self.description = description_
        self.name = name_
        self.version = version_
        self.unknown_fields = unknown_fields


class TaggedCredential(Type):
    _toSchema = {"credential": "credential", "tag": "tag"}
    _toPy = {"credential": "credential", "tag": "tag"}

    def __init__(self, credential=None, tag=None, **unknown_fields):
        """Credential : CloudCredential
        tag : str
        """
        credential_ = CloudCredential.from_json(credential) if credential else None
        tag_ = tag

        # Validate arguments against known Juju API types.
        if credential_ is not None and not isinstance(
            credential_, (dict, CloudCredential)
        ):
            raise Exception(
                f"Expected credential_ to be a CloudCredential, received: {type(credential_)}"
            )

        if tag_ is not None and not isinstance(tag_, (bytes, str)):
            raise Exception(f"Expected tag_ to be a str, received: {type(tag_)}")

        self.credential = credential_
        self.tag = tag_
        self.unknown_fields = unknown_fields


class TaggedCredentials(Type):
    _toSchema = {"credentials": "credentials"}
    _toPy = {"credentials": "credentials"}

    def __init__(self, credentials=None, **unknown_fields):
        """Credentials : typing.Sequence[~TaggedCredential]"""
        credentials_ = [TaggedCredential.from_json(o) for o in credentials or []]

        # Validate arguments against known Juju API types.
        if credentials_ is not None and not isinstance(
            credentials_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected credentials_ to be a Sequence, received: {type(credentials_)}"
            )

        self.credentials = credentials_
        self.unknown_fields = unknown_fields


class Tools(Type):
    _toSchema = {"sha256": "sha256", "size": "size", "url": "url", "version": "version"}
    _toPy = {"sha256": "sha256", "size": "size", "url": "url", "version": "version"}

    def __init__(
        self, sha256=None, size=None, url=None, version=None, **unknown_fields
    ):
        """sha256 : str
        size : int
        url : str
        version : Binary
        """
        sha256_ = sha256
        size_ = size
        url_ = url
        version_ = Binary.from_json(version) if version else None

        # Validate arguments against known Juju API types.
        if sha256_ is not None and not isinstance(sha256_, (bytes, str)):
            raise Exception(f"Expected sha256_ to be a str, received: {type(sha256_)}")

        if size_ is not None and not isinstance(size_, int):
            raise Exception(f"Expected size_ to be a int, received: {type(size_)}")

        if url_ is not None and not isinstance(url_, (bytes, str)):
            raise Exception(f"Expected url_ to be a str, received: {type(url_)}")

        if version_ is not None and not isinstance(version_, (dict, Binary)):
            raise Exception(
                f"Expected version_ to be a Binary, received: {type(version_)}"
            )

        self.sha256 = sha256_
        self.size = size_
        self.url = url_
        self.version = version_
        self.unknown_fields = unknown_fields


class UnitInfoResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : UnitResult
        """
        error_ = Error.from_json(error) if error else None
        result_ = UnitResult.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (dict, UnitResult)):
            raise Exception(
                f"Expected result_ to be a UnitResult, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class UnitInfoResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~UnitInfoResult]"""
        results_ = [UnitInfoResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class UnitResources(Type):
    _toSchema = {
        "download_progress": "download-progress",
        "entity": "Entity",
        "resources": "resources",
        "tag": "tag",
    }
    _toPy = {
        "Entity": "entity",
        "download-progress": "download_progress",
        "resources": "resources",
        "tag": "tag",
    }

    def __init__(
        self,
        entity=None,
        download_progress=None,
        resources=None,
        tag=None,
        **unknown_fields,
    ):
        """Entity : Entity
        download_progress : typing.Mapping[str, int]
        resources : typing.Sequence[~Resource]
        tag : str
        """
        entity_ = Entity.from_json(entity) if entity else None
        download_progress_ = download_progress
        resources_ = [Resource.from_json(o) for o in resources or []]
        tag_ = tag

        # Validate arguments against known Juju API types.
        if entity_ is not None and not isinstance(entity_, (dict, Entity)):
            raise Exception(
                f"Expected entity_ to be a Entity, received: {type(entity_)}"
            )

        if download_progress_ is not None and not isinstance(download_progress_, dict):
            raise Exception(
                f"Expected download_progress_ to be a Mapping, received: {type(download_progress_)}"
            )

        if resources_ is not None and not isinstance(resources_, (bytes, str, list)):
            raise Exception(
                f"Expected resources_ to be a Sequence, received: {type(resources_)}"
            )

        if tag_ is not None and not isinstance(tag_, (bytes, str)):
            raise Exception(f"Expected tag_ to be a str, received: {type(tag_)}")

        self.entity = entity_
        self.download_progress = download_progress_
        self.resources = resources_
        self.tag = tag_
        self.unknown_fields = unknown_fields


class UnitResult(Type):
    _toSchema = {
        "address": "address",
        "charm": "charm",
        "leader": "leader",
        "life": "life",
        "machine": "machine",
        "opened_ports": "opened-ports",
        "provider_id": "provider-id",
        "public_address": "public-address",
        "relation_data": "relation-data",
        "tag": "tag",
        "workload_version": "workload-version",
    }
    _toPy = {
        "address": "address",
        "charm": "charm",
        "leader": "leader",
        "life": "life",
        "machine": "machine",
        "opened-ports": "opened_ports",
        "provider-id": "provider_id",
        "public-address": "public_address",
        "relation-data": "relation_data",
        "tag": "tag",
        "workload-version": "workload_version",
    }

    def __init__(
        self,
        address=None,
        charm=None,
        leader=None,
        life=None,
        machine=None,
        opened_ports=None,
        provider_id=None,
        public_address=None,
        relation_data=None,
        tag=None,
        workload_version=None,
        **unknown_fields,
    ):
        """Address : str
        charm : str
        leader : bool
        life : str
        machine : str
        opened_ports : typing.Sequence[str]
        provider_id : str
        public_address : str
        relation_data : typing.Sequence[~EndpointRelationData]
        tag : str
        workload_version : str
        """
        address_ = address
        charm_ = charm
        leader_ = leader
        life_ = life
        machine_ = machine
        opened_ports_ = opened_ports
        provider_id_ = provider_id
        public_address_ = public_address
        relation_data_ = [
            EndpointRelationData.from_json(o) for o in relation_data or []
        ]
        tag_ = tag
        workload_version_ = workload_version

        # Validate arguments against known Juju API types.
        if address_ is not None and not isinstance(address_, (bytes, str)):
            raise Exception(
                f"Expected address_ to be a str, received: {type(address_)}"
            )

        if charm_ is not None and not isinstance(charm_, (bytes, str)):
            raise Exception(f"Expected charm_ to be a str, received: {type(charm_)}")

        if leader_ is not None and not isinstance(leader_, bool):
            raise Exception(f"Expected leader_ to be a bool, received: {type(leader_)}")

        if life_ is not None and not isinstance(life_, (bytes, str)):
            raise Exception(f"Expected life_ to be a str, received: {type(life_)}")

        if machine_ is not None and not isinstance(machine_, (bytes, str)):
            raise Exception(
                f"Expected machine_ to be a str, received: {type(machine_)}"
            )

        if opened_ports_ is not None and not isinstance(
            opened_ports_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected opened_ports_ to be a Sequence, received: {type(opened_ports_)}"
            )

        if provider_id_ is not None and not isinstance(provider_id_, (bytes, str)):
            raise Exception(
                f"Expected provider_id_ to be a str, received: {type(provider_id_)}"
            )

        if public_address_ is not None and not isinstance(
            public_address_, (bytes, str)
        ):
            raise Exception(
                f"Expected public_address_ to be a str, received: {type(public_address_)}"
            )

        if relation_data_ is not None and not isinstance(
            relation_data_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected relation_data_ to be a Sequence, received: {type(relation_data_)}"
            )

        if tag_ is not None and not isinstance(tag_, (bytes, str)):
            raise Exception(f"Expected tag_ to be a str, received: {type(tag_)}")

        if workload_version_ is not None and not isinstance(
            workload_version_, (bytes, str)
        ):
            raise Exception(
                f"Expected workload_version_ to be a str, received: {type(workload_version_)}"
            )

        self.address = address_
        self.charm = charm_
        self.leader = leader_
        self.life = life_
        self.machine = machine_
        self.opened_ports = opened_ports_
        self.provider_id = provider_id_
        self.public_address = public_address_
        self.relation_data = relation_data_
        self.tag = tag_
        self.workload_version = workload_version_
        self.unknown_fields = unknown_fields


class UnitStatus(Type):
    _toSchema = {
        "address": "address",
        "agent_status": "agent-status",
        "charm": "charm",
        "leader": "leader",
        "machine": "machine",
        "opened_ports": "opened-ports",
        "provider_id": "provider-id",
        "public_address": "public-address",
        "subordinates": "subordinates",
        "workload_status": "workload-status",
        "workload_version": "workload-version",
    }
    _toPy = {
        "address": "address",
        "agent-status": "agent_status",
        "charm": "charm",
        "leader": "leader",
        "machine": "machine",
        "opened-ports": "opened_ports",
        "provider-id": "provider_id",
        "public-address": "public_address",
        "subordinates": "subordinates",
        "workload-status": "workload_status",
        "workload-version": "workload_version",
    }

    def __init__(
        self,
        address=None,
        agent_status=None,
        charm=None,
        leader=None,
        machine=None,
        opened_ports=None,
        provider_id=None,
        public_address=None,
        subordinates=None,
        workload_status=None,
        workload_version=None,
        **unknown_fields,
    ):
        """Address : str
        agent_status : DetailedStatus
        charm : str
        leader : bool
        machine : str
        opened_ports : typing.Sequence[str]
        provider_id : str
        public_address : str
        subordinates : typing.Mapping[str, ~UnitStatus]
        workload_status : DetailedStatus
        workload_version : str
        """
        address_ = address
        agent_status_ = DetailedStatus.from_json(agent_status) if agent_status else None
        charm_ = charm
        leader_ = leader
        machine_ = machine
        opened_ports_ = opened_ports
        provider_id_ = provider_id
        public_address_ = public_address
        subordinates_ = {
            k: UnitStatus.from_json(v) for k, v in (subordinates or dict()).items()
        }
        workload_status_ = (
            DetailedStatus.from_json(workload_status) if workload_status else None
        )
        workload_version_ = workload_version

        # Validate arguments against known Juju API types.
        if address_ is not None and not isinstance(address_, (bytes, str)):
            raise Exception(
                f"Expected address_ to be a str, received: {type(address_)}"
            )

        if agent_status_ is not None and not isinstance(
            agent_status_, (dict, DetailedStatus)
        ):
            raise Exception(
                f"Expected agent_status_ to be a DetailedStatus, received: {type(agent_status_)}"
            )

        if charm_ is not None and not isinstance(charm_, (bytes, str)):
            raise Exception(f"Expected charm_ to be a str, received: {type(charm_)}")

        if leader_ is not None and not isinstance(leader_, bool):
            raise Exception(f"Expected leader_ to be a bool, received: {type(leader_)}")

        if machine_ is not None and not isinstance(machine_, (bytes, str)):
            raise Exception(
                f"Expected machine_ to be a str, received: {type(machine_)}"
            )

        if opened_ports_ is not None and not isinstance(
            opened_ports_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected opened_ports_ to be a Sequence, received: {type(opened_ports_)}"
            )

        if provider_id_ is not None and not isinstance(provider_id_, (bytes, str)):
            raise Exception(
                f"Expected provider_id_ to be a str, received: {type(provider_id_)}"
            )

        if public_address_ is not None and not isinstance(
            public_address_, (bytes, str)
        ):
            raise Exception(
                f"Expected public_address_ to be a str, received: {type(public_address_)}"
            )

        if subordinates_ is not None and not isinstance(subordinates_, dict):
            raise Exception(
                f"Expected subordinates_ to be a Mapping, received: {type(subordinates_)}"
            )

        if workload_status_ is not None and not isinstance(
            workload_status_, (dict, DetailedStatus)
        ):
            raise Exception(
                f"Expected workload_status_ to be a DetailedStatus, received: {type(workload_status_)}"
            )

        if workload_version_ is not None and not isinstance(
            workload_version_, (bytes, str)
        ):
            raise Exception(
                f"Expected workload_version_ to be a str, received: {type(workload_version_)}"
            )

        self.address = address_
        self.agent_status = agent_status_
        self.charm = charm_
        self.leader = leader_
        self.machine = machine_
        self.opened_ports = opened_ports_
        self.provider_id = provider_id_
        self.public_address = public_address_
        self.subordinates = subordinates_
        self.workload_status = workload_status_
        self.workload_version = workload_version_
        self.unknown_fields = unknown_fields


class UnitsResolved(Type):
    _toSchema = {"all_": "all", "retry": "retry", "tags": "tags"}
    _toPy = {"all": "all_", "retry": "retry", "tags": "tags"}

    def __init__(self, all_=None, retry=None, tags=None, **unknown_fields):
        """all_ : bool
        retry : bool
        tags : Entities
        """
        all__ = all_
        retry_ = retry
        tags_ = Entities.from_json(tags) if tags else None

        # Validate arguments against known Juju API types.
        if all__ is not None and not isinstance(all__, bool):
            raise Exception(f"Expected all__ to be a bool, received: {type(all__)}")

        if retry_ is not None and not isinstance(retry_, bool):
            raise Exception(f"Expected retry_ to be a bool, received: {type(retry_)}")

        if tags_ is not None and not isinstance(tags_, (dict, Entities)):
            raise Exception(f"Expected tags_ to be a Entities, received: {type(tags_)}")

        self.all_ = all__
        self.retry = retry_
        self.tags = tags_
        self.unknown_fields = unknown_fields


class UnsetModelDefaults(Type):
    _toSchema = {"keys": "keys"}
    _toPy = {"keys": "keys"}

    def __init__(self, keys=None, **unknown_fields):
        """Keys : typing.Sequence[~ModelUnsetKeys]"""
        keys_ = [ModelUnsetKeys.from_json(o) for o in keys or []]

        # Validate arguments against known Juju API types.
        if keys_ is not None and not isinstance(keys_, (bytes, str, list)):
            raise Exception(f"Expected keys_ to be a Sequence, received: {type(keys_)}")

        self.keys = keys_
        self.unknown_fields = unknown_fields


class UpdateChannelArg(Type):
    _toSchema = {"channel": "channel", "force": "force", "tag": "tag"}
    _toPy = {"channel": "channel", "force": "force", "tag": "tag"}

    def __init__(self, channel=None, force=None, tag=None, **unknown_fields):
        """Channel : str
        force : bool
        tag : Entity
        """
        channel_ = channel
        force_ = force
        tag_ = Entity.from_json(tag) if tag else None

        # Validate arguments against known Juju API types.
        if channel_ is not None and not isinstance(channel_, (bytes, str)):
            raise Exception(
                f"Expected channel_ to be a str, received: {type(channel_)}"
            )

        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if tag_ is not None and not isinstance(tag_, (dict, Entity)):
            raise Exception(f"Expected tag_ to be a Entity, received: {type(tag_)}")

        self.channel = channel_
        self.force = force_
        self.tag = tag_
        self.unknown_fields = unknown_fields


class UpdateChannelArgs(Type):
    _toSchema = {"args": "args"}
    _toPy = {"args": "args"}

    def __init__(self, args=None, **unknown_fields):
        """Args : typing.Sequence[~UpdateChannelArg]"""
        args_ = [UpdateChannelArg.from_json(o) for o in args or []]

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, (bytes, str, list)):
            raise Exception(f"Expected args_ to be a Sequence, received: {type(args_)}")

        self.args = args_
        self.unknown_fields = unknown_fields


class UpdateCloudArgs(Type):
    _toSchema = {"clouds": "clouds"}
    _toPy = {"clouds": "clouds"}

    def __init__(self, clouds=None, **unknown_fields):
        """Clouds : typing.Sequence[~AddCloudArgs]"""
        clouds_ = [AddCloudArgs.from_json(o) for o in clouds or []]

        # Validate arguments against known Juju API types.
        if clouds_ is not None and not isinstance(clouds_, (bytes, str, list)):
            raise Exception(
                f"Expected clouds_ to be a Sequence, received: {type(clouds_)}"
            )

        self.clouds = clouds_
        self.unknown_fields = unknown_fields


class UpdateCredentialArgs(Type):
    _toSchema = {"credentials": "credentials", "force": "force"}
    _toPy = {"credentials": "credentials", "force": "force"}

    def __init__(self, credentials=None, force=None, **unknown_fields):
        """Credentials : typing.Sequence[~TaggedCredential]
        force : bool
        """
        credentials_ = [TaggedCredential.from_json(o) for o in credentials or []]
        force_ = force

        # Validate arguments against known Juju API types.
        if credentials_ is not None and not isinstance(
            credentials_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected credentials_ to be a Sequence, received: {type(credentials_)}"
            )

        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        self.credentials = credentials_
        self.force = force_
        self.unknown_fields = unknown_fields


class UpdateCredentialModelResult(Type):
    _toSchema = {"errors": "errors", "name": "name", "uuid": "uuid"}
    _toPy = {"errors": "errors", "name": "name", "uuid": "uuid"}

    def __init__(self, errors=None, name=None, uuid=None, **unknown_fields):
        """Errors : typing.Sequence[~ErrorResult]
        name : str
        uuid : str
        """
        errors_ = [ErrorResult.from_json(o) for o in errors or []]
        name_ = name
        uuid_ = uuid

        # Validate arguments against known Juju API types.
        if errors_ is not None and not isinstance(errors_, (bytes, str, list)):
            raise Exception(
                f"Expected errors_ to be a Sequence, received: {type(errors_)}"
            )

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if uuid_ is not None and not isinstance(uuid_, (bytes, str)):
            raise Exception(f"Expected uuid_ to be a str, received: {type(uuid_)}")

        self.errors = errors_
        self.name = name_
        self.uuid = uuid_
        self.unknown_fields = unknown_fields


class UpdateCredentialResult(Type):
    _toSchema = {"error": "error", "models": "models", "tag": "tag"}
    _toPy = {"error": "error", "models": "models", "tag": "tag"}

    def __init__(self, error=None, models=None, tag=None, **unknown_fields):
        """Error : Error
        models : typing.Sequence[~UpdateCredentialModelResult]
        tag : str
        """
        error_ = Error.from_json(error) if error else None
        models_ = [UpdateCredentialModelResult.from_json(o) for o in models or []]
        tag_ = tag

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if models_ is not None and not isinstance(models_, (bytes, str, list)):
            raise Exception(
                f"Expected models_ to be a Sequence, received: {type(models_)}"
            )

        if tag_ is not None and not isinstance(tag_, (bytes, str)):
            raise Exception(f"Expected tag_ to be a str, received: {type(tag_)}")

        self.error = error_
        self.models = models_
        self.tag = tag_
        self.unknown_fields = unknown_fields


class UpdateCredentialResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~UpdateCredentialResult]"""
        results_ = [UpdateCredentialResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class UpdateSecretBackendArg(Type):
    _toSchema = {
        "config": "config",
        "force": "force",
        "name": "name",
        "name_change": "name-change",
        "reset": "reset",
        "token_rotate_interval": "token-rotate-interval",
    }
    _toPy = {
        "config": "config",
        "force": "force",
        "name": "name",
        "name-change": "name_change",
        "reset": "reset",
        "token-rotate-interval": "token_rotate_interval",
    }

    def __init__(
        self,
        config=None,
        force=None,
        name=None,
        name_change=None,
        reset=None,
        token_rotate_interval=None,
        **unknown_fields,
    ):
        """Config : typing.Mapping[str, typing.Any]
        force : bool
        name : str
        name_change : str
        reset : typing.Sequence[str]
        token_rotate_interval : int
        """
        config_ = config
        force_ = force
        name_ = name
        name_change_ = name_change
        reset_ = reset
        token_rotate_interval_ = token_rotate_interval

        # Validate arguments against known Juju API types.
        if config_ is not None and not isinstance(config_, dict):
            raise Exception(
                f"Expected config_ to be a Mapping, received: {type(config_)}"
            )

        if force_ is not None and not isinstance(force_, bool):
            raise Exception(f"Expected force_ to be a bool, received: {type(force_)}")

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        if name_change_ is not None and not isinstance(name_change_, (bytes, str)):
            raise Exception(
                f"Expected name_change_ to be a str, received: {type(name_change_)}"
            )

        if reset_ is not None and not isinstance(reset_, (bytes, str, list)):
            raise Exception(
                f"Expected reset_ to be a Sequence, received: {type(reset_)}"
            )

        if token_rotate_interval_ is not None and not isinstance(
            token_rotate_interval_, int
        ):
            raise Exception(
                f"Expected token_rotate_interval_ to be a int, received: {type(token_rotate_interval_)}"
            )

        self.config = config_
        self.force = force_
        self.name = name_
        self.name_change = name_change_
        self.reset = reset_
        self.token_rotate_interval = token_rotate_interval_
        self.unknown_fields = unknown_fields


class UpdateSecretBackendArgs(Type):
    _toSchema = {"args": "args"}
    _toPy = {"args": "args"}

    def __init__(self, args=None, **unknown_fields):
        """Args : typing.Sequence[~UpdateSecretBackendArg]"""
        args_ = [UpdateSecretBackendArg.from_json(o) for o in args or []]

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, (bytes, str, list)):
            raise Exception(f"Expected args_ to be a Sequence, received: {type(args_)}")

        self.args = args_
        self.unknown_fields = unknown_fields


class UpdateUserSecretArg(Type):
    _toSchema = {
        "auto_prune": "auto-prune",
        "content": "content",
        "description": "description",
        "existing_label": "existing-label",
        "expire_time": "expire-time",
        "label": "label",
        "params": "params",
        "rotate_policy": "rotate-policy",
        "upsertsecretarg": "UpsertSecretArg",
        "uri": "uri",
    }
    _toPy = {
        "UpsertSecretArg": "upsertsecretarg",
        "auto-prune": "auto_prune",
        "content": "content",
        "description": "description",
        "existing-label": "existing_label",
        "expire-time": "expire_time",
        "label": "label",
        "params": "params",
        "rotate-policy": "rotate_policy",
        "uri": "uri",
    }

    def __init__(
        self,
        upsertsecretarg=None,
        auto_prune=None,
        content=None,
        description=None,
        existing_label=None,
        expire_time=None,
        label=None,
        params=None,
        rotate_policy=None,
        uri=None,
        **unknown_fields,
    ):
        """Upsertsecretarg : UpsertSecretArg
        auto_prune : bool
        content : SecretContentParams
        description : str
        existing_label : str
        expire_time : str
        label : str
        params : typing.Mapping[str, typing.Any]
        rotate_policy : str
        uri : str
        """
        upsertsecretarg_ = (
            UpsertSecretArg.from_json(upsertsecretarg) if upsertsecretarg else None
        )
        auto_prune_ = auto_prune
        content_ = SecretContentParams.from_json(content) if content else None
        description_ = description
        existing_label_ = existing_label
        expire_time_ = expire_time
        label_ = label
        params_ = params
        rotate_policy_ = rotate_policy
        uri_ = uri

        # Validate arguments against known Juju API types.
        if upsertsecretarg_ is not None and not isinstance(
            upsertsecretarg_, (dict, UpsertSecretArg)
        ):
            raise Exception(
                f"Expected upsertsecretarg_ to be a UpsertSecretArg, received: {type(upsertsecretarg_)}"
            )

        if auto_prune_ is not None and not isinstance(auto_prune_, bool):
            raise Exception(
                f"Expected auto_prune_ to be a bool, received: {type(auto_prune_)}"
            )

        if content_ is not None and not isinstance(
            content_, (dict, SecretContentParams)
        ):
            raise Exception(
                f"Expected content_ to be a SecretContentParams, received: {type(content_)}"
            )

        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if existing_label_ is not None and not isinstance(
            existing_label_, (bytes, str)
        ):
            raise Exception(
                f"Expected existing_label_ to be a str, received: {type(existing_label_)}"
            )

        if expire_time_ is not None and not isinstance(expire_time_, (bytes, str)):
            raise Exception(
                f"Expected expire_time_ to be a str, received: {type(expire_time_)}"
            )

        if label_ is not None and not isinstance(label_, (bytes, str)):
            raise Exception(f"Expected label_ to be a str, received: {type(label_)}")

        if params_ is not None and not isinstance(params_, dict):
            raise Exception(
                f"Expected params_ to be a Mapping, received: {type(params_)}"
            )

        if rotate_policy_ is not None and not isinstance(rotate_policy_, (bytes, str)):
            raise Exception(
                f"Expected rotate_policy_ to be a str, received: {type(rotate_policy_)}"
            )

        if uri_ is not None and not isinstance(uri_, (bytes, str)):
            raise Exception(f"Expected uri_ to be a str, received: {type(uri_)}")

        self.upsertsecretarg = upsertsecretarg_
        self.auto_prune = auto_prune_
        self.content = content_
        self.description = description_
        self.existing_label = existing_label_
        self.expire_time = expire_time_
        self.label = label_
        self.params = params_
        self.rotate_policy = rotate_policy_
        self.uri = uri_
        self.unknown_fields = unknown_fields


class UpdateUserSecretArgs(Type):
    _toSchema = {"args": "args"}
    _toPy = {"args": "args"}

    def __init__(self, args=None, **unknown_fields):
        """Args : typing.Sequence[~UpdateUserSecretArg]"""
        args_ = [UpdateUserSecretArg.from_json(o) for o in args or []]

        # Validate arguments against known Juju API types.
        if args_ is not None and not isinstance(args_, (bytes, str, list)):
            raise Exception(f"Expected args_ to be a Sequence, received: {type(args_)}")

        self.args = args_
        self.unknown_fields = unknown_fields


class UpgradeModelParams(Type):
    _toSchema = {
        "agent_stream": "agent-stream",
        "dry_run": "dry-run",
        "ignore_agent_versions": "ignore-agent-versions",
        "model_tag": "model-tag",
        "target_version": "target-version",
    }
    _toPy = {
        "agent-stream": "agent_stream",
        "dry-run": "dry_run",
        "ignore-agent-versions": "ignore_agent_versions",
        "model-tag": "model_tag",
        "target-version": "target_version",
    }

    def __init__(
        self,
        agent_stream=None,
        dry_run=None,
        ignore_agent_versions=None,
        model_tag=None,
        target_version=None,
        **unknown_fields,
    ):
        """agent_stream : str
        dry_run : bool
        ignore_agent_versions : bool
        model_tag : str
        target_version : Number
        """
        agent_stream_ = agent_stream
        dry_run_ = dry_run
        ignore_agent_versions_ = ignore_agent_versions
        model_tag_ = model_tag
        target_version_ = Number.from_json(target_version) if target_version else None

        # Validate arguments against known Juju API types.
        if agent_stream_ is not None and not isinstance(agent_stream_, (bytes, str)):
            raise Exception(
                f"Expected agent_stream_ to be a str, received: {type(agent_stream_)}"
            )

        if dry_run_ is not None and not isinstance(dry_run_, bool):
            raise Exception(
                f"Expected dry_run_ to be a bool, received: {type(dry_run_)}"
            )

        if ignore_agent_versions_ is not None and not isinstance(
            ignore_agent_versions_, bool
        ):
            raise Exception(
                f"Expected ignore_agent_versions_ to be a bool, received: {type(ignore_agent_versions_)}"
            )

        if model_tag_ is not None and not isinstance(model_tag_, (bytes, str)):
            raise Exception(
                f"Expected model_tag_ to be a str, received: {type(model_tag_)}"
            )

        if target_version_ is not None and not isinstance(
            target_version_, (dict, Number)
        ):
            raise Exception(
                f"Expected target_version_ to be a Number, received: {type(target_version_)}"
            )

        self.agent_stream = agent_stream_
        self.dry_run = dry_run_
        self.ignore_agent_versions = ignore_agent_versions_
        self.model_tag = model_tag_
        self.target_version = target_version_
        self.unknown_fields = unknown_fields


class UpgradeModelResult(Type):
    _toSchema = {"chosen_version": "chosen-version", "error": "error"}
    _toPy = {"chosen-version": "chosen_version", "error": "error"}

    def __init__(self, chosen_version=None, error=None, **unknown_fields):
        """chosen_version : Number
        error : Error
        """
        chosen_version_ = Number.from_json(chosen_version) if chosen_version else None
        error_ = Error.from_json(error) if error else None

        # Validate arguments against known Juju API types.
        if chosen_version_ is not None and not isinstance(
            chosen_version_, (dict, Number)
        ):
            raise Exception(
                f"Expected chosen_version_ to be a Number, received: {type(chosen_version_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        self.chosen_version = chosen_version_
        self.error = error_
        self.unknown_fields = unknown_fields


class UpgradeSeriesNotificationParam(Type):
    _toSchema = {"entity": "entity", "watcher_id": "watcher-id"}
    _toPy = {"entity": "entity", "watcher-id": "watcher_id"}

    def __init__(self, entity=None, watcher_id=None, **unknown_fields):
        """Entity : Entity
        watcher_id : str
        """
        entity_ = Entity.from_json(entity) if entity else None
        watcher_id_ = watcher_id

        # Validate arguments against known Juju API types.
        if entity_ is not None and not isinstance(entity_, (dict, Entity)):
            raise Exception(
                f"Expected entity_ to be a Entity, received: {type(entity_)}"
            )

        if watcher_id_ is not None and not isinstance(watcher_id_, (bytes, str)):
            raise Exception(
                f"Expected watcher_id_ to be a str, received: {type(watcher_id_)}"
            )

        self.entity = entity_
        self.watcher_id = watcher_id_
        self.unknown_fields = unknown_fields


class UpgradeSeriesNotificationParams(Type):
    _toSchema = {"params": "params"}
    _toPy = {"params": "params"}

    def __init__(self, params=None, **unknown_fields):
        """Params : typing.Sequence[~UpgradeSeriesNotificationParam]"""
        params_ = [UpgradeSeriesNotificationParam.from_json(o) for o in params or []]

        # Validate arguments against known Juju API types.
        if params_ is not None and not isinstance(params_, (bytes, str, list)):
            raise Exception(
                f"Expected params_ to be a Sequence, received: {type(params_)}"
            )

        self.params = params_
        self.unknown_fields = unknown_fields


class UpgradeSeriesUnitsResult(Type):
    _toSchema = {"error": "error", "unit_names": "unit-names"}
    _toPy = {"error": "error", "unit-names": "unit_names"}

    def __init__(self, error=None, unit_names=None, **unknown_fields):
        """Error : Error
        unit_names : typing.Sequence[str]
        """
        error_ = Error.from_json(error) if error else None
        unit_names_ = unit_names

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if unit_names_ is not None and not isinstance(unit_names_, (bytes, str, list)):
            raise Exception(
                f"Expected unit_names_ to be a Sequence, received: {type(unit_names_)}"
            )

        self.error = error_
        self.unit_names = unit_names_
        self.unknown_fields = unknown_fields


class UpgradeSeriesUnitsResults(Type):
    _toSchema = {"results": "Results"}
    _toPy = {"Results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~UpgradeSeriesUnitsResult]"""
        results_ = [UpgradeSeriesUnitsResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class UpsertSecretArg(Type):
    _toSchema = {
        "content": "content",
        "description": "description",
        "expire_time": "expire-time",
        "label": "label",
        "params": "params",
        "rotate_policy": "rotate-policy",
    }
    _toPy = {
        "content": "content",
        "description": "description",
        "expire-time": "expire_time",
        "label": "label",
        "params": "params",
        "rotate-policy": "rotate_policy",
    }

    def __init__(
        self,
        content=None,
        description=None,
        expire_time=None,
        label=None,
        params=None,
        rotate_policy=None,
        **unknown_fields,
    ):
        """Content : SecretContentParams
        description : str
        expire_time : str
        label : str
        params : typing.Mapping[str, typing.Any]
        rotate_policy : str
        """
        content_ = SecretContentParams.from_json(content) if content else None
        description_ = description
        expire_time_ = expire_time
        label_ = label
        params_ = params
        rotate_policy_ = rotate_policy

        # Validate arguments against known Juju API types.
        if content_ is not None and not isinstance(
            content_, (dict, SecretContentParams)
        ):
            raise Exception(
                f"Expected content_ to be a SecretContentParams, received: {type(content_)}"
            )

        if description_ is not None and not isinstance(description_, (bytes, str)):
            raise Exception(
                f"Expected description_ to be a str, received: {type(description_)}"
            )

        if expire_time_ is not None and not isinstance(expire_time_, (bytes, str)):
            raise Exception(
                f"Expected expire_time_ to be a str, received: {type(expire_time_)}"
            )

        if label_ is not None and not isinstance(label_, (bytes, str)):
            raise Exception(f"Expected label_ to be a str, received: {type(label_)}")

        if params_ is not None and not isinstance(params_, dict):
            raise Exception(
                f"Expected params_ to be a Mapping, received: {type(params_)}"
            )

        if rotate_policy_ is not None and not isinstance(rotate_policy_, (bytes, str)):
            raise Exception(
                f"Expected rotate_policy_ to be a str, received: {type(rotate_policy_)}"
            )

        self.content = content_
        self.description = description_
        self.expire_time = expire_time_
        self.label = label_
        self.params = params_
        self.rotate_policy = rotate_policy_
        self.unknown_fields = unknown_fields


class UserAccess(Type):
    _toSchema = {"access": "access", "user_tag": "user-tag"}
    _toPy = {"access": "access", "user-tag": "user_tag"}

    def __init__(self, access=None, user_tag=None, **unknown_fields):
        """Access : str
        user_tag : str
        """
        access_ = access
        user_tag_ = user_tag

        # Validate arguments against known Juju API types.
        if access_ is not None and not isinstance(access_, (bytes, str)):
            raise Exception(f"Expected access_ to be a str, received: {type(access_)}")

        if user_tag_ is not None and not isinstance(user_tag_, (bytes, str)):
            raise Exception(
                f"Expected user_tag_ to be a str, received: {type(user_tag_)}"
            )

        self.access = access_
        self.user_tag = user_tag_
        self.unknown_fields = unknown_fields


class UserAccessResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : UserAccess
        """
        error_ = Error.from_json(error) if error else None
        result_ = UserAccess.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (dict, UserAccess)):
            raise Exception(
                f"Expected result_ to be a UserAccess, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class UserAccessResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~UserAccessResult]"""
        results_ = [UserAccessResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class UserCloud(Type):
    _toSchema = {"cloud_tag": "cloud-tag", "user_tag": "user-tag"}
    _toPy = {"cloud-tag": "cloud_tag", "user-tag": "user_tag"}

    def __init__(self, cloud_tag=None, user_tag=None, **unknown_fields):
        """cloud_tag : str
        user_tag : str
        """
        cloud_tag_ = cloud_tag
        user_tag_ = user_tag

        # Validate arguments against known Juju API types.
        if cloud_tag_ is not None and not isinstance(cloud_tag_, (bytes, str)):
            raise Exception(
                f"Expected cloud_tag_ to be a str, received: {type(cloud_tag_)}"
            )

        if user_tag_ is not None and not isinstance(user_tag_, (bytes, str)):
            raise Exception(
                f"Expected user_tag_ to be a str, received: {type(user_tag_)}"
            )

        self.cloud_tag = cloud_tag_
        self.user_tag = user_tag_
        self.unknown_fields = unknown_fields


class UserClouds(Type):
    _toSchema = {"user_clouds": "user-clouds"}
    _toPy = {"user-clouds": "user_clouds"}

    def __init__(self, user_clouds=None, **unknown_fields):
        """user_clouds : typing.Sequence[~UserCloud]"""
        user_clouds_ = [UserCloud.from_json(o) for o in user_clouds or []]

        # Validate arguments against known Juju API types.
        if user_clouds_ is not None and not isinstance(
            user_clouds_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected user_clouds_ to be a Sequence, received: {type(user_clouds_)}"
            )

        self.user_clouds = user_clouds_
        self.unknown_fields = unknown_fields


class UserInfo(Type):
    _toSchema = {
        "access": "access",
        "created_by": "created-by",
        "date_created": "date-created",
        "disabled": "disabled",
        "display_name": "display-name",
        "last_connection": "last-connection",
        "username": "username",
    }
    _toPy = {
        "access": "access",
        "created-by": "created_by",
        "date-created": "date_created",
        "disabled": "disabled",
        "display-name": "display_name",
        "last-connection": "last_connection",
        "username": "username",
    }

    def __init__(
        self,
        access=None,
        created_by=None,
        date_created=None,
        disabled=None,
        display_name=None,
        last_connection=None,
        username=None,
        **unknown_fields,
    ):
        """Access : str
        created_by : str
        date_created : str
        disabled : bool
        display_name : str
        last_connection : str
        username : str
        """
        access_ = access
        created_by_ = created_by
        date_created_ = date_created
        disabled_ = disabled
        display_name_ = display_name
        last_connection_ = last_connection
        username_ = username

        # Validate arguments against known Juju API types.
        if access_ is not None and not isinstance(access_, (bytes, str)):
            raise Exception(f"Expected access_ to be a str, received: {type(access_)}")

        if created_by_ is not None and not isinstance(created_by_, (bytes, str)):
            raise Exception(
                f"Expected created_by_ to be a str, received: {type(created_by_)}"
            )

        if date_created_ is not None and not isinstance(date_created_, (bytes, str)):
            raise Exception(
                f"Expected date_created_ to be a str, received: {type(date_created_)}"
            )

        if disabled_ is not None and not isinstance(disabled_, bool):
            raise Exception(
                f"Expected disabled_ to be a bool, received: {type(disabled_)}"
            )

        if display_name_ is not None and not isinstance(display_name_, (bytes, str)):
            raise Exception(
                f"Expected display_name_ to be a str, received: {type(display_name_)}"
            )

        if last_connection_ is not None and not isinstance(
            last_connection_, (bytes, str)
        ):
            raise Exception(
                f"Expected last_connection_ to be a str, received: {type(last_connection_)}"
            )

        if username_ is not None and not isinstance(username_, (bytes, str)):
            raise Exception(
                f"Expected username_ to be a str, received: {type(username_)}"
            )

        self.access = access_
        self.created_by = created_by_
        self.date_created = date_created_
        self.disabled = disabled_
        self.display_name = display_name_
        self.last_connection = last_connection_
        self.username = username_
        self.unknown_fields = unknown_fields


class UserInfoRequest(Type):
    _toSchema = {"entities": "entities", "include_disabled": "include-disabled"}
    _toPy = {"entities": "entities", "include-disabled": "include_disabled"}

    def __init__(self, entities=None, include_disabled=None, **unknown_fields):
        """Entities : typing.Sequence[~Entity]
        include_disabled : bool
        """
        entities_ = [Entity.from_json(o) for o in entities or []]
        include_disabled_ = include_disabled

        # Validate arguments against known Juju API types.
        if entities_ is not None and not isinstance(entities_, (bytes, str, list)):
            raise Exception(
                f"Expected entities_ to be a Sequence, received: {type(entities_)}"
            )

        if include_disabled_ is not None and not isinstance(include_disabled_, bool):
            raise Exception(
                f"Expected include_disabled_ to be a bool, received: {type(include_disabled_)}"
            )

        self.entities = entities_
        self.include_disabled = include_disabled_
        self.unknown_fields = unknown_fields


class UserInfoResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : UserInfo
        """
        error_ = Error.from_json(error) if error else None
        result_ = UserInfo.from_json(result) if result else None

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (dict, UserInfo)):
            raise Exception(
                f"Expected result_ to be a UserInfo, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class UserInfoResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~UserInfoResult]"""
        results_ = [UserInfoResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class UserModel(Type):
    _toSchema = {"last_connection": "last-connection", "model": "model"}
    _toPy = {"last-connection": "last_connection", "model": "model"}

    def __init__(self, last_connection=None, model=None, **unknown_fields):
        """last_connection : str
        model : Model
        """
        last_connection_ = last_connection
        model_ = Model.from_json(model) if model else None

        # Validate arguments against known Juju API types.
        if last_connection_ is not None and not isinstance(
            last_connection_, (bytes, str)
        ):
            raise Exception(
                f"Expected last_connection_ to be a str, received: {type(last_connection_)}"
            )

        if model_ is not None and not isinstance(model_, (dict, Model)):
            raise Exception(f"Expected model_ to be a Model, received: {type(model_)}")

        self.last_connection = last_connection_
        self.model = model_
        self.unknown_fields = unknown_fields


class UserModelList(Type):
    _toSchema = {"user_models": "user-models"}
    _toPy = {"user-models": "user_models"}

    def __init__(self, user_models=None, **unknown_fields):
        """user_models : typing.Sequence[~UserModel]"""
        user_models_ = [UserModel.from_json(o) for o in user_models or []]

        # Validate arguments against known Juju API types.
        if user_models_ is not None and not isinstance(
            user_models_, (bytes, str, list)
        ):
            raise Exception(
                f"Expected user_models_ to be a Sequence, received: {type(user_models_)}"
            )

        self.user_models = user_models_
        self.unknown_fields = unknown_fields


class Value(Type):
    _toSchema = {
        "allocate_public_ip": "allocate-public-ip",
        "arch": "arch",
        "container": "container",
        "cores": "cores",
        "cpu_power": "cpu-power",
        "image_id": "image-id",
        "instance_role": "instance-role",
        "instance_type": "instance-type",
        "mem": "mem",
        "root_disk": "root-disk",
        "root_disk_source": "root-disk-source",
        "spaces": "spaces",
        "tags": "tags",
        "virt_type": "virt-type",
        "zones": "zones",
    }
    _toPy = {
        "allocate-public-ip": "allocate_public_ip",
        "arch": "arch",
        "container": "container",
        "cores": "cores",
        "cpu-power": "cpu_power",
        "image-id": "image_id",
        "instance-role": "instance_role",
        "instance-type": "instance_type",
        "mem": "mem",
        "root-disk": "root_disk",
        "root-disk-source": "root_disk_source",
        "spaces": "spaces",
        "tags": "tags",
        "virt-type": "virt_type",
        "zones": "zones",
    }

    def __init__(
        self,
        allocate_public_ip=None,
        arch=None,
        container=None,
        cores=None,
        cpu_power=None,
        image_id=None,
        instance_role=None,
        instance_type=None,
        mem=None,
        root_disk=None,
        root_disk_source=None,
        spaces=None,
        tags=None,
        virt_type=None,
        zones=None,
        **unknown_fields,
    ):
        """allocate_public_ip : bool
        arch : str
        container : str
        cores : int
        cpu_power : int
        image_id : str
        instance_role : str
        instance_type : str
        mem : int
        root_disk : int
        root_disk_source : str
        spaces : typing.Sequence[str]
        tags : typing.Sequence[str]
        virt_type : str
        zones : typing.Sequence[str]
        """
        allocate_public_ip_ = allocate_public_ip
        arch_ = arch
        container_ = container
        cores_ = cores
        cpu_power_ = cpu_power
        image_id_ = image_id
        instance_role_ = instance_role
        instance_type_ = instance_type
        mem_ = mem
        root_disk_ = root_disk
        root_disk_source_ = root_disk_source
        spaces_ = spaces
        tags_ = tags
        virt_type_ = virt_type
        zones_ = zones

        # Validate arguments against known Juju API types.
        if allocate_public_ip_ is not None and not isinstance(
            allocate_public_ip_, bool
        ):
            raise Exception(
                f"Expected allocate_public_ip_ to be a bool, received: {type(allocate_public_ip_)}"
            )

        if arch_ is not None and not isinstance(arch_, (bytes, str)):
            raise Exception(f"Expected arch_ to be a str, received: {type(arch_)}")

        if container_ is not None and not isinstance(container_, (bytes, str)):
            raise Exception(
                f"Expected container_ to be a str, received: {type(container_)}"
            )

        if cores_ is not None and not isinstance(cores_, int):
            raise Exception(f"Expected cores_ to be a int, received: {type(cores_)}")

        if cpu_power_ is not None and not isinstance(cpu_power_, int):
            raise Exception(
                f"Expected cpu_power_ to be a int, received: {type(cpu_power_)}"
            )

        if image_id_ is not None and not isinstance(image_id_, (bytes, str)):
            raise Exception(
                f"Expected image_id_ to be a str, received: {type(image_id_)}"
            )

        if instance_role_ is not None and not isinstance(instance_role_, (bytes, str)):
            raise Exception(
                f"Expected instance_role_ to be a str, received: {type(instance_role_)}"
            )

        if instance_type_ is not None and not isinstance(instance_type_, (bytes, str)):
            raise Exception(
                f"Expected instance_type_ to be a str, received: {type(instance_type_)}"
            )

        if mem_ is not None and not isinstance(mem_, int):
            raise Exception(f"Expected mem_ to be a int, received: {type(mem_)}")

        if root_disk_ is not None and not isinstance(root_disk_, int):
            raise Exception(
                f"Expected root_disk_ to be a int, received: {type(root_disk_)}"
            )

        if root_disk_source_ is not None and not isinstance(
            root_disk_source_, (bytes, str)
        ):
            raise Exception(
                f"Expected root_disk_source_ to be a str, received: {type(root_disk_source_)}"
            )

        if spaces_ is not None and not isinstance(spaces_, (bytes, str, list)):
            raise Exception(
                f"Expected spaces_ to be a Sequence, received: {type(spaces_)}"
            )

        if tags_ is not None and not isinstance(tags_, (bytes, str, list)):
            raise Exception(f"Expected tags_ to be a Sequence, received: {type(tags_)}")

        if virt_type_ is not None and not isinstance(virt_type_, (bytes, str)):
            raise Exception(
                f"Expected virt_type_ to be a str, received: {type(virt_type_)}"
            )

        if zones_ is not None and not isinstance(zones_, (bytes, str, list)):
            raise Exception(
                f"Expected zones_ to be a Sequence, received: {type(zones_)}"
            )

        self.allocate_public_ip = allocate_public_ip_
        self.arch = arch_
        self.container = container_
        self.cores = cores_
        self.cpu_power = cpu_power_
        self.image_id = image_id_
        self.instance_role = instance_role_
        self.instance_type = instance_type_
        self.mem = mem_
        self.root_disk = root_disk_
        self.root_disk_source = root_disk_source_
        self.spaces = spaces_
        self.tags = tags_
        self.virt_type = virt_type_
        self.zones = zones_
        self.unknown_fields = unknown_fields


class VolumeAttachmentDetails(Type):
    _toSchema = {
        "bus_address": "bus-address",
        "device_link": "device-link",
        "device_name": "device-name",
        "life": "life",
        "plan_info": "plan-info",
        "read_only": "read-only",
        "volumeattachmentinfo": "VolumeAttachmentInfo",
    }
    _toPy = {
        "VolumeAttachmentInfo": "volumeattachmentinfo",
        "bus-address": "bus_address",
        "device-link": "device_link",
        "device-name": "device_name",
        "life": "life",
        "plan-info": "plan_info",
        "read-only": "read_only",
    }

    def __init__(
        self,
        volumeattachmentinfo=None,
        bus_address=None,
        device_link=None,
        device_name=None,
        life=None,
        plan_info=None,
        read_only=None,
        **unknown_fields,
    ):
        """Volumeattachmentinfo : VolumeAttachmentInfo
        bus_address : str
        device_link : str
        device_name : str
        life : str
        plan_info : VolumeAttachmentPlanInfo
        read_only : bool
        """
        volumeattachmentinfo_ = (
            VolumeAttachmentInfo.from_json(volumeattachmentinfo)
            if volumeattachmentinfo
            else None
        )
        bus_address_ = bus_address
        device_link_ = device_link
        device_name_ = device_name
        life_ = life
        plan_info_ = (
            VolumeAttachmentPlanInfo.from_json(plan_info) if plan_info else None
        )
        read_only_ = read_only

        # Validate arguments against known Juju API types.
        if volumeattachmentinfo_ is not None and not isinstance(
            volumeattachmentinfo_, (dict, VolumeAttachmentInfo)
        ):
            raise Exception(
                f"Expected volumeattachmentinfo_ to be a VolumeAttachmentInfo, received: {type(volumeattachmentinfo_)}"
            )

        if bus_address_ is not None and not isinstance(bus_address_, (bytes, str)):
            raise Exception(
                f"Expected bus_address_ to be a str, received: {type(bus_address_)}"
            )

        if device_link_ is not None and not isinstance(device_link_, (bytes, str)):
            raise Exception(
                f"Expected device_link_ to be a str, received: {type(device_link_)}"
            )

        if device_name_ is not None and not isinstance(device_name_, (bytes, str)):
            raise Exception(
                f"Expected device_name_ to be a str, received: {type(device_name_)}"
            )

        if life_ is not None and not isinstance(life_, (bytes, str)):
            raise Exception(f"Expected life_ to be a str, received: {type(life_)}")

        if plan_info_ is not None and not isinstance(
            plan_info_, (dict, VolumeAttachmentPlanInfo)
        ):
            raise Exception(
                f"Expected plan_info_ to be a VolumeAttachmentPlanInfo, received: {type(plan_info_)}"
            )

        if read_only_ is not None and not isinstance(read_only_, bool):
            raise Exception(
                f"Expected read_only_ to be a bool, received: {type(read_only_)}"
            )

        self.volumeattachmentinfo = volumeattachmentinfo_
        self.bus_address = bus_address_
        self.device_link = device_link_
        self.device_name = device_name_
        self.life = life_
        self.plan_info = plan_info_
        self.read_only = read_only_
        self.unknown_fields = unknown_fields


class VolumeAttachmentInfo(Type):
    _toSchema = {
        "bus_address": "bus-address",
        "device_link": "device-link",
        "device_name": "device-name",
        "plan_info": "plan-info",
        "read_only": "read-only",
    }
    _toPy = {
        "bus-address": "bus_address",
        "device-link": "device_link",
        "device-name": "device_name",
        "plan-info": "plan_info",
        "read-only": "read_only",
    }

    def __init__(
        self,
        bus_address=None,
        device_link=None,
        device_name=None,
        plan_info=None,
        read_only=None,
        **unknown_fields,
    ):
        """bus_address : str
        device_link : str
        device_name : str
        plan_info : VolumeAttachmentPlanInfo
        read_only : bool
        """
        bus_address_ = bus_address
        device_link_ = device_link
        device_name_ = device_name
        plan_info_ = (
            VolumeAttachmentPlanInfo.from_json(plan_info) if plan_info else None
        )
        read_only_ = read_only

        # Validate arguments against known Juju API types.
        if bus_address_ is not None and not isinstance(bus_address_, (bytes, str)):
            raise Exception(
                f"Expected bus_address_ to be a str, received: {type(bus_address_)}"
            )

        if device_link_ is not None and not isinstance(device_link_, (bytes, str)):
            raise Exception(
                f"Expected device_link_ to be a str, received: {type(device_link_)}"
            )

        if device_name_ is not None and not isinstance(device_name_, (bytes, str)):
            raise Exception(
                f"Expected device_name_ to be a str, received: {type(device_name_)}"
            )

        if plan_info_ is not None and not isinstance(
            plan_info_, (dict, VolumeAttachmentPlanInfo)
        ):
            raise Exception(
                f"Expected plan_info_ to be a VolumeAttachmentPlanInfo, received: {type(plan_info_)}"
            )

        if read_only_ is not None and not isinstance(read_only_, bool):
            raise Exception(
                f"Expected read_only_ to be a bool, received: {type(read_only_)}"
            )

        self.bus_address = bus_address_
        self.device_link = device_link_
        self.device_name = device_name_
        self.plan_info = plan_info_
        self.read_only = read_only_
        self.unknown_fields = unknown_fields


class VolumeAttachmentPlanInfo(Type):
    _toSchema = {"device_attributes": "device-attributes", "device_type": "device-type"}
    _toPy = {"device-attributes": "device_attributes", "device-type": "device_type"}

    def __init__(self, device_attributes=None, device_type=None, **unknown_fields):
        """device_attributes : typing.Mapping[str, str]
        device_type : str
        """
        device_attributes_ = device_attributes
        device_type_ = device_type

        # Validate arguments against known Juju API types.
        if device_attributes_ is not None and not isinstance(device_attributes_, dict):
            raise Exception(
                f"Expected device_attributes_ to be a Mapping, received: {type(device_attributes_)}"
            )

        if device_type_ is not None and not isinstance(device_type_, (bytes, str)):
            raise Exception(
                f"Expected device_type_ to be a str, received: {type(device_type_)}"
            )

        self.device_attributes = device_attributes_
        self.device_type = device_type_
        self.unknown_fields = unknown_fields


class VolumeDetails(Type):
    _toSchema = {
        "info": "info",
        "life": "life",
        "machine_attachments": "machine-attachments",
        "status": "status",
        "storage": "storage",
        "unit_attachments": "unit-attachments",
        "volume_tag": "volume-tag",
    }
    _toPy = {
        "info": "info",
        "life": "life",
        "machine-attachments": "machine_attachments",
        "status": "status",
        "storage": "storage",
        "unit-attachments": "unit_attachments",
        "volume-tag": "volume_tag",
    }

    def __init__(
        self,
        info=None,
        life=None,
        machine_attachments=None,
        status=None,
        storage=None,
        unit_attachments=None,
        volume_tag=None,
        **unknown_fields,
    ):
        """Info : VolumeInfo
        life : str
        machine_attachments : typing.Mapping[str, ~VolumeAttachmentDetails]
        status : EntityStatus
        storage : StorageDetails
        unit_attachments : typing.Mapping[str, ~VolumeAttachmentDetails]
        volume_tag : str
        """
        info_ = VolumeInfo.from_json(info) if info else None
        life_ = life
        machine_attachments_ = {
            k: VolumeAttachmentDetails.from_json(v)
            for k, v in (machine_attachments or dict()).items()
        }
        status_ = EntityStatus.from_json(status) if status else None
        storage_ = StorageDetails.from_json(storage) if storage else None
        unit_attachments_ = {
            k: VolumeAttachmentDetails.from_json(v)
            for k, v in (unit_attachments or dict()).items()
        }
        volume_tag_ = volume_tag

        # Validate arguments against known Juju API types.
        if info_ is not None and not isinstance(info_, (dict, VolumeInfo)):
            raise Exception(
                f"Expected info_ to be a VolumeInfo, received: {type(info_)}"
            )

        if life_ is not None and not isinstance(life_, (bytes, str)):
            raise Exception(f"Expected life_ to be a str, received: {type(life_)}")

        if machine_attachments_ is not None and not isinstance(
            machine_attachments_, dict
        ):
            raise Exception(
                f"Expected machine_attachments_ to be a Mapping, received: {type(machine_attachments_)}"
            )

        if status_ is not None and not isinstance(status_, (dict, EntityStatus)):
            raise Exception(
                f"Expected status_ to be a EntityStatus, received: {type(status_)}"
            )

        if storage_ is not None and not isinstance(storage_, (dict, StorageDetails)):
            raise Exception(
                f"Expected storage_ to be a StorageDetails, received: {type(storage_)}"
            )

        if unit_attachments_ is not None and not isinstance(unit_attachments_, dict):
            raise Exception(
                f"Expected unit_attachments_ to be a Mapping, received: {type(unit_attachments_)}"
            )

        if volume_tag_ is not None and not isinstance(volume_tag_, (bytes, str)):
            raise Exception(
                f"Expected volume_tag_ to be a str, received: {type(volume_tag_)}"
            )

        self.info = info_
        self.life = life_
        self.machine_attachments = machine_attachments_
        self.status = status_
        self.storage = storage_
        self.unit_attachments = unit_attachments_
        self.volume_tag = volume_tag_
        self.unknown_fields = unknown_fields


class VolumeDetailsListResult(Type):
    _toSchema = {"error": "error", "result": "result"}
    _toPy = {"error": "error", "result": "result"}

    def __init__(self, error=None, result=None, **unknown_fields):
        """Error : Error
        result : typing.Sequence[~VolumeDetails]
        """
        error_ = Error.from_json(error) if error else None
        result_ = [VolumeDetails.from_json(o) for o in result or []]

        # Validate arguments against known Juju API types.
        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if result_ is not None and not isinstance(result_, (bytes, str, list)):
            raise Exception(
                f"Expected result_ to be a Sequence, received: {type(result_)}"
            )

        self.error = error_
        self.result = result_
        self.unknown_fields = unknown_fields


class VolumeDetailsListResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~VolumeDetailsListResult]"""
        results_ = [VolumeDetailsListResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields


class VolumeFilter(Type):
    _toSchema = {"machines": "machines"}
    _toPy = {"machines": "machines"}

    def __init__(self, machines=None, **unknown_fields):
        """Machines : typing.Sequence[str]"""
        machines_ = machines

        # Validate arguments against known Juju API types.
        if machines_ is not None and not isinstance(machines_, (bytes, str, list)):
            raise Exception(
                f"Expected machines_ to be a Sequence, received: {type(machines_)}"
            )

        self.machines = machines_
        self.unknown_fields = unknown_fields


class VolumeFilters(Type):
    _toSchema = {"filters": "filters"}
    _toPy = {"filters": "filters"}

    def __init__(self, filters=None, **unknown_fields):
        """Filters : typing.Sequence[~VolumeFilter]"""
        filters_ = [VolumeFilter.from_json(o) for o in filters or []]

        # Validate arguments against known Juju API types.
        if filters_ is not None and not isinstance(filters_, (bytes, str, list)):
            raise Exception(
                f"Expected filters_ to be a Sequence, received: {type(filters_)}"
            )

        self.filters = filters_
        self.unknown_fields = unknown_fields


class VolumeInfo(Type):
    _toSchema = {
        "hardware_id": "hardware-id",
        "persistent": "persistent",
        "pool": "pool",
        "size": "size",
        "volume_id": "volume-id",
        "wwn": "wwn",
    }
    _toPy = {
        "hardware-id": "hardware_id",
        "persistent": "persistent",
        "pool": "pool",
        "size": "size",
        "volume-id": "volume_id",
        "wwn": "wwn",
    }

    def __init__(
        self,
        hardware_id=None,
        persistent=None,
        pool=None,
        size=None,
        volume_id=None,
        wwn=None,
        **unknown_fields,
    ):
        """hardware_id : str
        persistent : bool
        pool : str
        size : int
        volume_id : str
        wwn : str
        """
        hardware_id_ = hardware_id
        persistent_ = persistent
        pool_ = pool
        size_ = size
        volume_id_ = volume_id
        wwn_ = wwn

        # Validate arguments against known Juju API types.
        if hardware_id_ is not None and not isinstance(hardware_id_, (bytes, str)):
            raise Exception(
                f"Expected hardware_id_ to be a str, received: {type(hardware_id_)}"
            )

        if persistent_ is not None and not isinstance(persistent_, bool):
            raise Exception(
                f"Expected persistent_ to be a bool, received: {type(persistent_)}"
            )

        if pool_ is not None and not isinstance(pool_, (bytes, str)):
            raise Exception(f"Expected pool_ to be a str, received: {type(pool_)}")

        if size_ is not None and not isinstance(size_, int):
            raise Exception(f"Expected size_ to be a int, received: {type(size_)}")

        if volume_id_ is not None and not isinstance(volume_id_, (bytes, str)):
            raise Exception(
                f"Expected volume_id_ to be a str, received: {type(volume_id_)}"
            )

        if wwn_ is not None and not isinstance(wwn_, (bytes, str)):
            raise Exception(f"Expected wwn_ to be a str, received: {type(wwn_)}")

        self.hardware_id = hardware_id_
        self.persistent = persistent_
        self.pool = pool_
        self.size = size_
        self.volume_id = volume_id_
        self.wwn = wwn_
        self.unknown_fields = unknown_fields


class ZoneResult(Type):
    _toSchema = {"available": "available", "error": "error", "name": "name"}
    _toPy = {"available": "available", "error": "error", "name": "name"}

    def __init__(self, available=None, error=None, name=None, **unknown_fields):
        """Available : bool
        error : Error
        name : str
        """
        available_ = available
        error_ = Error.from_json(error) if error else None
        name_ = name

        # Validate arguments against known Juju API types.
        if available_ is not None and not isinstance(available_, bool):
            raise Exception(
                f"Expected available_ to be a bool, received: {type(available_)}"
            )

        if error_ is not None and not isinstance(error_, (dict, Error)):
            raise Exception(f"Expected error_ to be a Error, received: {type(error_)}")

        if name_ is not None and not isinstance(name_, (bytes, str)):
            raise Exception(f"Expected name_ to be a str, received: {type(name_)}")

        self.available = available_
        self.error = error_
        self.name = name_
        self.unknown_fields = unknown_fields


class ZoneResults(Type):
    _toSchema = {"results": "results"}
    _toPy = {"results": "results"}

    def __init__(self, results=None, **unknown_fields):
        """Results : typing.Sequence[~ZoneResult]"""
        results_ = [ZoneResult.from_json(o) for o in results or []]

        # Validate arguments against known Juju API types.
        if results_ is not None and not isinstance(results_, (bytes, str, list)):
            raise Exception(
                f"Expected results_ to be a Sequence, received: {type(results_)}"
            )

        self.results = results_
        self.unknown_fields = unknown_fields
